{"meta":{"title":"王卓然的个人博客","subtitle":null,"description":null,"author":"王卓然","url":"http://wzr1998.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-12-01T11:40:45.440Z","updated":"2020-11-23T11:39:09.974Z","comments":false,"path":"/404.html","permalink":"http://wzr1998.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-12-01T11:40:45.458Z","updated":"2020-11-23T13:38:53.157Z","comments":false,"path":"about/index.html","permalink":"http://wzr1998.github.io/about/index.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930WZR = &#123; name: &#x27;王卓然&#x27;, birthday: &#x27;1998.11.12&#x27;, gender: &#x27;man&#x27;, profession: &#x27;Web Developer &amp; NLP Learner&#x27;, Learning_time: &#x27;3 years&#x27;, address: &#x27;Heilongjiang Harbin&#x27;, education: &#x27;bachelor&#x27;, github: &#x27;https://github.com/wzr1998&#x27;, blog: &#x27;https://wzr1998.github.io&#x27;, email: &#x27;wzr9812@163.com&#x27;, skills: [ [&#x27;HTML5&#x27;, &#x27;CSS3+&#x27;, &#x27;JavaScript&#x27;, &#x27;ES6+&#x27;, &#x27;jQuery&#x27;, &#x27;TypeScript&#x27;], [&#x27;Python&#x27;, &#x27;Java&#x27;, &#x27;PHP&#x27;], [&#x27;Node.js&#x27;, &#x27;Express&#x27;, &#x27;Koa2&#x27;], [&#x27;Vue&#x27;, &#x27;Vue-cli&#x27;, &#x27;Vur-router&#x27;, &#x27;Vuex&#x27;], [&#x27;Webpack&#x27;, &#x27;Gulp&#x27;], [&#x27;Less&#x27;,&#x27;Sass&#x27;], [&#x27;Git&#x27;, &#x27;SVN&#x27;], [&#x27;MySQL&#x27;, &#x27;MongoDB&#x27;], [&#x27;Applet of WeChat&#x27;, &#x27;mpvue&#x27;] ], devTools: [ [&#x27;Sublime Text&#x27;, &#x27;WebStorm&#x27;, &#x27;XCode&#x27;, &#x27;PyCharm&#x27;, &#x27;IDLE&#x27;, &#x27;IDEA&#x27;], [&#x27;Chrome DevTools&#x27;, &#x27;Charles&#x27;], [&#x27;Navicat&#x27;, &#x27;MAMP&#x27;], ] &#125;"},{"title":"书单","date":"2020-12-01T11:40:45.475Z","updated":"2020-11-19T12:37:44.430Z","comments":false,"path":"books/index.html","permalink":"http://wzr1998.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-12-01T11:40:45.490Z","updated":"2020-11-19T17:03:15.966Z","comments":false,"path":"categories/index.html","permalink":"http://wzr1998.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-12-01T11:40:45.507Z","updated":"2020-11-20T04:45:07.772Z","comments":false,"path":"links/index.html","permalink":"http://wzr1998.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-12-01T11:40:45.525Z","updated":"2020-11-19T12:37:44.431Z","comments":false,"path":"repository/index.html","permalink":"http://wzr1998.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-12-01T11:40:45.542Z","updated":"2020-11-19T12:37:44.432Z","comments":false,"path":"tags/index.html","permalink":"http://wzr1998.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"One-Hot Encoding and Ti-idf Representation","slug":"One-Hot-Encoding-and-Ti-idf-Representation","date":"2020-12-09T10:34:23.000Z","updated":"2020-12-10T14:00:15.697Z","comments":true,"path":"posts/7c06db8d/","link":"","permalink":"http://wzr1998.github.io/posts/7c06db8d/","excerpt":"","text":"一、One-Hot Encoding 1. 概念 独热编码即 One-Hot 编码，又称一位有效编码，其方法是使用N位状态寄存器来对N个状态进行编码，每个状态都由他独立的寄存器位，并且在任意时候，其中只有一位有效。例如： 词典V：[我们, 又, 去, 爬山, 今天, 你们, 昨天, 跑步]，只要出现了就表示成1，没有出现就表示成0 (1) 单词单独热编码表示 我们：(1, 0, 0, 0, 0, 0, 0, 0) 你们：(0, 0, 0, 0, 0, 1, 0, 0) 跑步：(0, 0 ,0, 0, 0, 0, 0, 1) 昨天：(0, 0, 0, 0, 0, 0, 1, 0) (2) 句子单独热编码表示(boolean vector) 我们 今天 去 爬山：(1, 0, 1, 1, 1, 0, 0, 0) 你们 昨天 跑步：(0, 0, 0, 0, 0, 1, 1, 1) 你们 又 去 爬山 又 去 跑步：(0, 1, 1, 1, 0, 1, 0, 1) (3) 句子单独热编码表示(count vector) 你们 又 去 爬山 又 去 跑步：(0, 2, 2, 1, 0, 1, 0, 1) 2. 特点 One-Hot 是一个词袋模型，不考虑词与词之间的顺序 它假设词与词相互独立，无法表示出在语义层面上词语词之间的相关信息 向量的维度会随着句子的词的数量类型增大而增大，它得到的特征是离散稀疏的(sparsity) 二、Ti-idf Representation 1. 概念 Ti-idf：Term Frequency and Inverse Document Frequency tfidf(w)=tf(d,w)⋅idf(w)=nd∑i=1nwni⋅logNN(w)tfidf(w)=tf(d, w) \\cdot idf(w) = \\frac {n_d} {\\sum_{i=1}^{n_w} n_i} \\cdot \\log \\frac N {N(w)} tfidf(w)=tf(d,w)⋅idf(w)=​∑​i=1​n​w​​​​n​i​​​​n​d​​​​⋅log​N(w)​​N​​ tf(d,w)tf(d, w)tf(d,w)：文档 d 中 w 的词频 idf(w)=logNN(w)idf(w)=\\log \\frac N {N(w)}idf(w)=log​N(w)​​N​​：单词出现在越少的文章里重要性越高，表示单词的w重要性 NNN：语料库中文档总数 N(w)N(w)N(w)：词语 w 出现在多少个文档 例如： 词库 V=[今天, 上, 数学, 课程, 也, 英语, 有, 意思] ”今天 上 数学 课程“：V1=(1⋅log32, 1⋅log31, 1⋅log32, 1⋅log33, 0, 0, 0, 0)V_1 = (1\\cdot\\log\\frac 3 2,\\ 1\\cdot\\log\\frac 3 1,\\ 1\\cdot\\log\\frac 3 2,\\ 1\\cdot\\log\\frac 3 3,\\ 0,\\ 0,\\ 0,\\ 0)V​1​​=(1⋅log​2​​3​​, 1⋅log​1​​3​​, 1⋅log​2​​3​​, 1⋅log​3​​3​​, 0, 0, 0, 0) “今天 的 数学 课程 有 意思”：V2=(1⋅log32, 0, 1⋅log32, 1⋅log33, 0, 0, 1⋅log32, 1⋅log32)V_2=(1\\cdot\\log\\frac 3 2,\\ 0,\\ 1\\cdot\\log\\frac 3 2,\\ 1\\cdot\\log\\frac 3 3,\\ 0,\\ 0,\\ 1\\cdot\\log\\frac 3 2,\\ 1\\cdot\\log\\frac 3 2)V​2​​=(1⋅log​2​​3​​, 0, 1⋅log​2​​3​​, 1⋅log​3​​3​​, 0, 0, 1⋅log​2​​3​​, 1⋅log​2​​3​​) “英语 课程 也 有 意思”：V3=(0, 0, 0, 1⋅log33, 1⋅log31, 1⋅log31, 1⋅log32, 1⋅log32)V_3=(0,\\ 0,\\ 0,\\ 1\\cdot\\log\\frac 3 3,\\ 1\\cdot\\log\\frac 3 1,\\ 1\\cdot\\log\\frac 3 1,\\ 1\\cdot\\log\\frac 3 2,\\ 1\\cdot\\log\\frac 3 2)V​3​​=(0, 0, 0, 1⋅log​3​​3​​, 1⋅log​1​​3​​, 1⋅log​1​​3​​, 1⋅log​2​​3​​, 1⋅log​2​​3​​) 2. Ti-idf 的缺点 没有考虑特征词的位置因素对文本的区分度，词条出现在文档的不同位置时，对区分度的贡献大小是不一样的 按照传统TF-IDF，往往一些生僻词的IDF(反文档频率)会比较高、因此这些生僻词常会被误认为是文档关键词 传统TF-IDF中的IDF部分只考虑了特征词与它出现的文本数之间的关系，而忽略了特征项在一个类别中不同的类别间的分布情况 对于文档中出现次数较少的重要人名、地名信息提取效果不佳 三、Sentence Similarity 1. 计算距离 欧式距离(Euclidean Distance)： d=∣s1−s2∣=∑i=1n(xi−yi)2d = |s_1 - s_2 | = \\sqrt{\\sum_{i=1}^n{(x_i-y_i)^2}}d=∣s​1​​−s​2​​∣=√​∑​i=1​n​​(x​i​​−y​i​​)​2​​​​​ 曼哈顿距离(Manhattan Distance)：d=∑i=1n∣ai−bi∣d=\\sum_{i=1}^n|a_i-b_i|d=∑​i=1​n​​∣a​i​​−b​i​​∣ 马氏距离(Mahalanobis Distance) 问题：没有考虑方向 2. 计算相似度 余弦相似度： Sim(s1,s2)=s1⋅s2∣s1∣∣s2∣=∑i=1nxi⋅yi∑i=1nxi⋅∑i=1nyiSim(s_1, s_2)=\\frac{s_1 \\cdot s_2} {|s_1||s_2|}=\\frac{\\sum_{i=1}^n{x_i\\cdot y_i}}{\\sqrt{\\sum_{i=1}^n{x_i}}\\cdot \\sqrt{\\sum_{i=1}^n y_i}} Sim(s​1​​,s​2​​)=​∣s​1​​∣∣s​2​​∣​​s​1​​⋅s​2​​​​=​√​∑​i=1​n​​x​i​​​​​⋅√​∑​i=1​n​​y​i​​​​​​​∑​i=1​n​​x​i​​⋅y​i​​​​","categories":[{"name":"nlp","slug":"nlp","permalink":"http://wzr1998.github.io/categories/nlp/"}],"tags":[{"name":"nlp","slug":"nlp","permalink":"http://wzr1998.github.io/tags/nlp/"}]},{"title":"Language Model","slug":"Language-Model","date":"2020-12-06T15:32:33.000Z","updated":"2020-12-10T02:49:06.668Z","comments":true,"path":"posts/5e1c9e40/","link":"","permalink":"http://wzr1998.github.io/posts/5e1c9e40/","excerpt":"","text":"一、概念 定义：对于语言序列 w1,w2,⋯,wnw_1, w_2, \\cdots , w_nw​1​​,w​2​​,⋯,w​n​​ ，Language Model 就是计算该序列的出现概率，即 P(w1,w2,⋯,wn)P(w_1, w_2, \\cdots , w_n)P(w​1​​,w​2​​,⋯,w​n​​) 作用：用来判断一句话是否从语法上顺通 例如：比较 “我今早吃了汉堡” 和 “我吃了今早汉堡” 哪个说得更满足语义要求 二、计算方法 Compute the probability of a sentence or sequence. Based on the chain rule: p(s)=p(w1,w2,w3...wn)=p(w1)⋅p(w2∣w1)⋅p(w3∣w1w2)⋯p(wn∣w1w2…wn)p(s)=p(w_1, w_2, w_3...w_n)=p(w_1) \\cdot p(w_2|w_1) \\cdot p(w_3|w_1w_2) \\cdots p(w_n|w_1w_2 \\ldots w_n)p(s)=p(w​1​​,w​2​​,w​3​​...w​n​​)=p(w​1​​)⋅p(w​2​​∣w​1​​)⋅p(w​3​​∣w​1​​w​2​​)⋯p(w​n​​∣w​1​​w​2​​…w​n​​) 例如：p(我今早吃了汉堡) = p(​我)·p(今早 | 我)·p(吃了 | 我, 今早)·p(汉堡 | 我, 今早, 吃了) 问题：例如在计算 p(汉堡 | 我, 今早, 吃了) 时(当条件很长时)，“我, 今早, 吃了”同时在语料库中出现的概率很少，从而造成数据的稀疏性(sparsity)，概率很可能计算为 0 三、Markov Assumption 1. 概念 马尔可夫假设(Markov assumption)，即假设当单词词出现的概率只依赖于前 n−1n-1n−1 个词，可以得到： p(wi∣w1,w2,w3…wn)=p(wi−(n−1),…,wi−1)p(w_i|w_1, w_2, w_3 \\ldots w_n) = p(w_{i-(n-1)},\\ldots,w_{i-1})p(w​i​​∣w​1​​,w​2​​,w​3​​…w​n​​)=p(w​i−(n−1)​​,…,w​i−1​​) (1) 一般形式如下： 1-garm:p(w1,w2,w3…wm)=∏i=1mp(wi)2-garm:p(w1,w2,w3…wm)=p(w1)∏i=2mp(wi∣wi−1)3-garm:p(w1,w2,w3…wm)=p(w1)⋅p(w2∣w1)∏i=2mp(wi∣wi−2wi−1)...n-garm:p(w1,w2,w3…wm)=p(w1)⋯p(wi∣wn−1wn−2…w1)∏i=n−1mp(wi∣wi−(n−1)wi−(n−2)…wi−1)\\begin{aligned} 1 \\text - garm : p(w_1, w_2, w_3 \\ldots w_m) &amp; = \\prod_{i=1}^m p(w_i)\\\\ 2 \\text - garm : p(w_1, w_2, w_3 \\ldots w_m) &amp; = p(w_1) \\prod_{i=2}^m p(w_i | w_{i-1})\\\\ 3 \\text - garm : p(w_1, w_2, w_3 \\ldots w_m) &amp; = p(w_1) \\cdot p(w_2 | w_1) \\prod_{i=2}^m p(w_i | w_{i-2}w_{i-1})\\\\ &amp; ...\\\\ n \\text - garm : p(w_1, w_2, w_3 \\ldots w_m) &amp; = p(w_1) \\cdots p(w_i | w_{n-1}w_{n-2} \\ldots w_1) \\prod_{i=n-1}^m p(w_i|w_{i-(n-1)}w_{i-(n-2)} \\ldots w_{i-1}) \\end{aligned} ​1-garm:p(w​1​​,w​2​​,w​3​​…w​m​​)​2-garm:p(w​1​​,w​2​​,w​3​​…w​m​​)​3-garm:p(w​1​​,w​2​​,w​3​​…w​m​​)​​n-garm:p(w​1​​,w​2​​,w​3​​…w​m​​)​​​=​i=1​∏​m​​p(w​i​​)​=p(w​1​​)​i=2​∏​m​​p(w​i​​∣w​i−1​​)​=p(w​1​​)⋅p(w​2​​∣w​1​​)​i=2​∏​m​​p(w​i​​∣w​i−2​​w​i−1​​)​...​=p(w​1​​)⋯p(w​i​​∣w​n−1​​w​n−2​​…w​1​​)​i=n−1​∏​m​​p(w​i​​∣w​i−(n−1)​​w​i−(n−2)​​…w​i−1​​)​​ (2) 例如： 1-gram(Unigram Model): p(汉堡 | 我, 今早, 吃了, 一个, 大) = p(汉堡) 2-gram(Bigram Model): p(汉堡 | 我, 今早, 吃了, 一个, 大) = p(汉堡| 大) 3-gram(Tridram Model): p(汉堡 | 我, 今早, 吃了, 一个, 大) = p(汉堡 | 一个, 大) (3) 特点： 对于任意词库 |v| ，存在 p(w1∣&lt;s&gt;)+p(w2∣&lt;s&gt;)+ ... +p(wi∣&lt;s&gt;)=1p(w_1|&lt;s&gt;) + p(w_2|&lt;s&gt;) +\\ ... \\ + p(w_i|&lt;s&gt;)=1p(w​1​​∣&lt;s&gt;)+p(w​2​​∣&lt;s&gt;)+ ... +p(w​i​​∣&lt;s&gt;)=1 根据任意单词&lt;s&gt;&lt;s&gt;&lt;s&gt;出现可能性p(wi∣&lt;s&gt;)p(w_i|&lt;s&gt;)p(w​i​​∣&lt;s&gt;)排序，可用此语言模型生成文本 2. Bigram Model 仅考虑某个单词前一位的情况，为了方便计算，有些时候会在句首添加一个特殊符号，使第一个单词(unigram)也变成 bigram p(w1,w2,w3…wm)=p(w1)∏i=2mp(wi∣wi−1)p(wi∣wi−1)=p(wiwi−1)p(wi)=Count(wiwi−1)Count(wi)\\begin{aligned} &amp; p(w_1, w_2, w_3 \\ldots w_m) = p(w_1) \\prod_{i=2}^m p(w_i | w_{i-1})\\\\\\\\ &amp; p(w_i|w_{i-1}) = \\frac{p(w_i w_{i-1})}{p(w_i)} = \\frac{Count(w_i w_{i-1})}{Count(w_i)} \\end{aligned} ​​​​​​p(w​1​​,w​2​​,w​3​​…w​m​​)=p(w​1​​)​i=2​∏​m​​p(w​i​​∣w​i−1​​)​p(w​i​​∣w​i−1​​)=​p(w​i​​)​​p(w​i​​w​i−1​​)​​=​Count(w​i​​)​​Count(w​i​​w​i−1​​)​​​​ 例如，语料库中有如下句子： 今天 的 天气 很好 啊 我 很 想 出去 运动 但 今天 上午 想 学习 判断：“今天 上午 想 出去 运动” 的概率： P(今天)·P(上午 | 今天)·P(想 | 上午)·P(出去 | 想)·P(运动 | 出去) = 219×12×11×12×11=0.0263\\frac{2}{19} \\times \\frac 1 2 \\times \\frac 1 1 \\times \\frac 1 2 \\times \\frac 1 1 = 0.0263​19​​2​​×​2​​1​​×​1​​1​​×​2​​1​​×​1​​1​​=0.0263 四、Evaluation of Language Model 模型评价方法，理想情况下： 假设有两个语言模型AB 选定一个特定的任务比如拼写纠错、机器翻译 把两个模型A, B都应用在此任务中 最后比较准确率,从而判断AB的表现 但这种评价方式耗时耗力，需对其进行改进。 核心思路：给定一个语料库，可以通过语言模型预测出下一个单词的概率越大越好 Perplexity 困惑度 Perplexity=2−x,x:average log likelihoodPerplexity = 2^{-x} ,\\quad x:average\\ log\\ likelihoodPerplexity=2​−x​​,x:average log likelihood 例如，已有 Bigram：PLM(w1w2…wn)P_{LM}(w_1w_2\\ldots w_n)P​LM​​(w​1​​w​2​​…w​n​​) 则 x=1n(logPLM(w1)+logPLM(w2∣w2)⋯PLM(wi∣wi−1))x= \\frac 1 n (\\log P_{LM}(w_1)+\\log P_{LM}(w_2|w_2)\\cdots P_{LM}(w_i|w_{i-1}))x=​n​​1​​(logP​LM​​(w​1​​)+logP​LM​​(w​2​​∣w​2​​)⋯P​LM​​(w​i​​∣w​i−1​​)) Perplexity=2−xPerplexity = 2^{-x}Perplexity=2​−x​​ 越小，说明语言模型越好 五、Add-one Smoothing(Laplace Smoothing) 1. 原则 平滑操作：把模型中概率为0的情况做单独处理 PMLE(wi∣wi−1)=Count(wi,wi−1)Count(wi−1)PAdd−1(wi∣wi−1)=Count(wi,wi−1)+1Count(wi−1)+V\\begin{aligned} &amp; P_{MLE}(w_i|w_{i-1})=\\frac{Count(w_i, w_{i-1})}{Count(w_{i-1})} \\\\\\\\ &amp; P_{Add-1}(w_i|w_{i-1})=\\frac{Count(w_i, w_{i-1})+1}{Count(w_{i-1})+V} \\end{aligned} ​​​​​​P​MLE​​(w​i​​∣w​i−1​​)=​Count(w​i−1​​)​​Count(w​i​​,w​i−1​​)​​​P​Add−1​​(w​i​​∣w​i−1​​)=​Count(w​i−1​​)+V​​Count(w​i​​,w​i−1​​)+1​​​​ 其中 V 为词库大小，做归一化操作，确保所有单词 ∑i−1nP(Add−1)=1\\sum_{i-1}^nP(Add-1)=1∑​i−1​n​​P(Add−1)=1 2. 案例 有如下语料库： 今天 的 天气 很好 啊 我 很 想 出去 运动 但 今天 上午 想 学习 则 PMLEP_{MLE}P​MLE​​ 与 PAdd−1P_{Add-1}P​Add−1​​ 如下： PMLEP_{MLE}P​MLE​​(没有|上午) = 02=0\\frac 0 2 = 0​2​​0​​=0 PAdd−1P{Add-1}PAdd−1(没有|上午) = 0+12+15=0.0588\\frac{0+1}{2+15}=0.0588​2+15​​0+1​​=0.0588 3. Add-K Smoothing PAdd−1(wi∣wi−1)=Count(wi,wi−1)+KCount(wi−1)+KV\\begin{aligned} &amp; P_{Add-1}(w_i|w_{i-1})=\\frac{Count(w_i, w_{i-1})+K}{Count(w_{i-1})+KV} \\end{aligned} ​​​​P​Add−1​​(w​i​​∣w​i−1​​)=​Count(w​i−1​​)+KV​​Count(w​i​​,w​i−1​​)+K​​​​ 六、Spell Correction 1. 纠错原理 用户输入错误单词 www → 生成编辑距离为1, 2的字符串 cic_ic​i​​ (候选集candidates) → 过滤 → 返回最优 c∗c^*c​∗​​ 2. 过滤方法 假设 www 时拼写错误的单词，改成正确的形式 c∗c^*c​∗​​ ： 把一个可能错误的单词改成正确的形式，希望更改后单词出现的可能性越大越好： c∗=argmaxci{p(ci∣w)},ci∈candidates=argmaxci{p(w∣ci)⋅p(ci)p(w)},ci∈candidates=argmaxci{p(w∣ci)⋅(p(ci)},ci∈candidates\\begin{aligned} c^* &amp; = argmax_{c_i}\\{p(c_i|w)\\}, &amp; c_i \\in candidates\\\\\\\\ &amp; = argmax_{c_i}\\{\\frac{p(w|c_i)\\cdot p(c_i)}{p(w)}\\}, &amp; c_i \\in candidates\\\\\\\\ &amp; = argmax_{c_i}\\{p(w|c_i)\\cdotp(p(c_i)\\}, &amp; c_i \\in candidates \\end{aligned} ​c​∗​​​​​​​​​=argmax​c​i​​​​{p(c​i​​∣w)},​=argmax​c​i​​​​{​p(w)​​p(w∣c​i​​)⋅p(c​i​​)​​},​=argmax​c​i​​​​{p(w∣c​i​​)⋅(p(c​i​​)},​​​c​i​​∈candidates​c​i​​∈candidates​c​i​​∈candidates​​ 其中： p(w∣ci)p(w|c_i)p(w∣c​i​​) 可以代表 www 与 cic_ic​i​​ 的相关性 score p(c)p(c)p(c) 可以变相看作语言模型，代表更改后字符 cic_ic​i​​ 在这句话中出现的概率 (1) p(w∣ci)p(w|c_i)p(w∣c​i​​) 可以有如下两种建模手段 通过Edit Distance： {ifd=1score=0.8ifd=2score=0.2\\begin{cases} if \\quad d=1 &amp; \\text{score=0.8}\\\\ if \\quad d=2 &amp; \\text{score=0.2} \\end{cases} {​ifd=1​ifd=2​​​score=0.8​score=0.2​​ 通过 Collected data：基于现有的统计数据，p(w∣ci)p(w|c_i)p(w∣c​i​​) 可以表示当用户拼 ccc 的时候，有多大概率拼写为 www (2) p(c)p(c)p(c) 可以通过局部语言模型计算，通过比较生成概率判断哪一个候选词出现的可能性大，例如： Computer is a verys‾ interesting subject( no )Computer is a {veryverusvers interesting subject( yes? )\\begin{aligned} \\text{Computer is a } \\underline{\\text{verys}} \\text{ interesting subject} &amp; \\quad(\\ no\\ )\\\\\\\\ \\text{Computer is a } \\begin{cases} \\text{very}\\\\ \\text{verus}\\\\ \\text{vers} \\end{cases} \\text{ interesting subject} &amp; \\quad(\\ yes?\\ ) \\end{aligned} ​Computer is a ​​verys​​ interesting subject​​Computer is a ​⎩​⎪​⎨​⎪​⎧​​​very​verus​vers​​ interesting subject​​​( no )​( yes? )​​ I(I(I( Computer is a very intresting subject )=p() = p()=p( very | is, a )·p( interesting | a, very )·p( subject | very, interesting ))) I(I(I( Computer is a verus intresting subject )=p() = p()=p( verus | is, a )·p( interesting | a, verus )·p( subject | verus, interesting ))) I(I(I( Computer is a vers intresting subject )=p() = p()=p( vers | is, a )·p( interesting | a, vers )·p( subject | vers, interesting )))","categories":[{"name":"nlp","slug":"nlp","permalink":"http://wzr1998.github.io/categories/nlp/"}],"tags":[{"name":"nlp","slug":"nlp","permalink":"http://wzr1998.github.io/tags/nlp/"}]},{"title":"Minimum Edit Distance","slug":"Edit-Distance","date":"2020-12-04T08:43:22.000Z","updated":"2020-12-04T11:15:55.047Z","comments":true,"path":"posts/528e1b0f/","link":"","permalink":"http://wzr1998.github.io/posts/528e1b0f/","excerpt":"","text":"一、概述 1. 概念 最小编辑距离（又称莱文斯坦距离 Levenshtein Distance）是针对两个字符串的差异程度的量化量测。表示一个字符串 str1[1…i] 转换为另一个字符串 str2[1…j] 的最小代价，其字符串操作为： Delete：将 str1[1…i-1] 转化为 str2[1…j] Insert：将 str1[1…i] 转化为 str2[1…j-1] Replace：将 str1[1…i-1] 转化为 str2[1…j-1] 进行替换操作时需要考虑两种情况： 若 str1[i] == str2[j] 表示两个字符串最后一个字符相等，则不需要进行操作 若 str1[i] != str2[j] 则表示两个字符串最后一个字符不等，将 str1[i] 替换为 str2[j] 2. 算法示例 计算 costume 与 custom 的编辑距离 替换 o → u ：costume → custume 替换 u → o：custume → custome 删除 e：custome → custom 二、算法步骤 Define： leva,b(i,j)lev_{a, b}(i, j)lev​a,b​​(i,j) —— Edit distance between str1[1…i] and str2[1…j] leva,b(i,j)={Max(i,j)if Min(i,j)=0Min{leva,b(i−1,j)+1leva,b(i,j−1)+1leva,b(i−1,j−1)+1ai≠bjOtherwise.lev_{a, b}(i, j)=\\begin{cases} Max(i, j) &amp; if\\ Min(i, j) = 0 \\\\ Min \\begin{cases} lev_{a, b}(i-1, j)+1\\\\ lev_{a, b}(i, j-1)+1 \\\\ lev_{a, b}(i-1, j-1)+1_{a_i \\neq b_j} \\end{cases} &amp; Otherwise. \\end{cases} lev​a,b​​(i,j)=​⎩​⎪​⎪​⎪​⎨​⎪​⎪​⎪​⎧​​​Max(i,j)​Min​⎩​⎪​⎨​⎪​⎧​​​lev​a,b​​(i−1,j)+1​lev​a,b​​(i,j−1)+1​lev​a,b​​(i−1,j−1)+1​a​i​​≠b​j​​​​​​​​​if Min(i,j)=0​Otherwise.​​ 当 Min(i,j)=0Min(i, j) = 0Min(i,j)=0 时，str1 或 str2 为空，此时二者编辑距离为非空字符串长度Min(i,j)Min(i, j)Min(i,j) ，代表 i/j 次插入操作 当 Min(i,j)≠0Min(i, j) \\neq 0Min(i,j)≠0 时： 若 str[i] == str[j] (ai≠bia_i \\neq b_ia​i​​≠b​i​​) ，则表示当前两字符串最后一个字符相等，不用进行操作(无代价) 若 str1[i] != str2[j] (ai=bia_i = b_ia​i​​=b​i​​) ，则依次进行 delete：leva,b(i−1,j)lev_{a, b}(i-1, j)lev​a,b​​(i−1,j)、insert：leva,b(i,j−1)lev_{a, b}(i, j-1)lev​a,b​​(i,j−1)、replace ：leva,b(i−1,j−1)lev_{a, b}(i-1, j-1)lev​a,b​​(i−1,j−1) 操作，选出代价最小的操作方案 三、过程演示 以 love 和 gloves 为例，创建结果矩阵： 0 g l o v e s 0 l o v e 1. 当 Min(i,j)=0Min(i, j) = 0Min(i,j)=0 时 第一行（i = 0）初始化： leva,b(0,0)=Max(0,0)=0leva,b(0,1)=Max(0,1)=1leva,b(0,2)=Max(0,2)=2leva,b(0,3)=Max(0,3)=3leva,b(0,4)=Max(0,3)=4leva,b(0,5)=Max(0,3)=5leva,b(0,6)=Max(0,3)=6\\begin{aligned} lev_{a, b}(0, 0) = Max(0, 0) = 0\\\\ lev_{a, b}(0, 1) = Max(0, 1) = 1\\\\ lev_{a, b}(0, 2) = Max(0, 2) = 2\\\\ lev_{a, b}(0, 3) = Max(0, 3) = 3\\\\ lev_{a, b}(0, 4) = Max(0, 3) = 4\\\\ lev_{a, b}(0, 5) = Max(0, 3) = 5\\\\ lev_{a, b}(0, 6) = Max(0, 3) = 6 \\end{aligned} ​lev​a,b​​(0,0)=Max(0,0)=0​lev​a,b​​(0,1)=Max(0,1)=1​lev​a,b​​(0,2)=Max(0,2)=2​lev​a,b​​(0,3)=Max(0,3)=3​lev​a,b​​(0,4)=Max(0,3)=4​lev​a,b​​(0,5)=Max(0,3)=5​lev​a,b​​(0,6)=Max(0,3)=6​​ 第一列（j = 0）初始化： leva,b(0,0)=Max(0,0)=0leva,b(1,0)=Max(1,0)=1leva,b(2,0)=Max(2,0)=2leva,b(3,0)=Max(3,0)=3leva,b(4,0)=Max(4,0)=4\\begin{aligned} lev_{a, b}(0, 0) = Max(0, 0) = 0\\\\ lev_{a, b}(1, 0) = Max(1, 0) = 1\\\\ lev_{a, b}(2, 0) = Max(2, 0) = 2\\\\ lev_{a, b}(3, 0) = Max(3, 0) = 3\\\\ lev_{a, b}(4, 0) = Max(4, 0) = 4\\\\ \\end{aligned} ​lev​a,b​​(0,0)=Max(0,0)=0​lev​a,b​​(1,0)=Max(1,0)=1​lev​a,b​​(2,0)=Max(2,0)=2​lev​a,b​​(3,0)=Max(3,0)=3​lev​a,b​​(4,0)=Max(4,0)=4​​​ 此时结果矩阵： 0 g l o v e s 0 0 1 2 3 4 5 6 l 1 o 2 v 3 e 4 2. 第二行（i=1）推导 leva,b(1,1)=Min{leva,b(0,1)+1, leva,b(1,0)+1, leva,b(0,0)+1}=1leva,b(1,2)=Min{leva,b(0,2)+1, leva,b(1,1)+1, leva,b(0,1)}=1leva,b(1,3)=Min{leva,b(0,3)+1, leva,b(1,2)+1, leva,b(0,2)+1}=2leva,b(1,4)=Min{leva,b(0,4)+1, leva,b(1,3)+1, leva,b(0,3)+1}=3leva,b(1,5)=Min{leva,b(0,5)+1, leva,b(1,4)+1, leva,b(0,4)+1}=4leva,b(1,6)=Min{leva,b(0,6)+1, leva,b(1,5)+1, leva,b(0,5)+1}=5\\begin{aligned} &amp; lev_{a, b}(1, 1) = Min\\{lev_{a, b}(0, 1)+1,\\ lev_{a, b}(1, 0)+1,\\ lev_{a, b}(0, 0)+1\\}&amp;= 1 \\\\ &amp; lev_{a, b}(1, 2) = Min\\{lev_{a, b}(0, 2)+1,\\ lev_{a, b}(1, 1)+1,\\ lev_{a, b}(0, 1)\\}&amp;= 1 \\\\ &amp; lev_{a, b}(1, 3) = Min\\{lev_{a, b}(0, 3)+1,\\ lev_{a, b}(1, 2)+1,\\ lev_{a, b}(0, 2)+1\\}&amp;= 2 \\\\ &amp; lev_{a, b}(1, 4) = Min\\{lev_{a, b}(0, 4)+1,\\ lev_{a, b}(1, 3)+1,\\ lev_{a, b}(0, 3)+1\\}&amp;= 3 \\\\ &amp; lev_{a, b}(1, 5) = Min\\{lev_{a, b}(0, 5)+1,\\ lev_{a, b}(1, 4)+1,\\ lev_{a, b}(0, 4)+1\\}&amp;= 4 \\\\ &amp; lev_{a, b}(1, 6) = Min\\{lev_{a, b}(0, 6)+1,\\ lev_{a, b}(1, 5)+1,\\ lev_{a, b}(0, 5)+1\\}&amp;= 5 \\\\ \\end{aligned} ​​​​​​​​​​lev​a,b​​(1,1)=Min{lev​a,b​​(0,1)+1, lev​a,b​​(1,0)+1, lev​a,b​​(0,0)+1}​lev​a,b​​(1,2)=Min{lev​a,b​​(0,2)+1, lev​a,b​​(1,1)+1, lev​a,b​​(0,1)}​lev​a,b​​(1,3)=Min{lev​a,b​​(0,3)+1, lev​a,b​​(1,2)+1, lev​a,b​​(0,2)+1}​lev​a,b​​(1,4)=Min{lev​a,b​​(0,4)+1, lev​a,b​​(1,3)+1, lev​a,b​​(0,3)+1}​lev​a,b​​(1,5)=Min{lev​a,b​​(0,5)+1, lev​a,b​​(1,4)+1, lev​a,b​​(0,4)+1}​lev​a,b​​(1,6)=Min{lev​a,b​​(0,6)+1, lev​a,b​​(1,5)+1, lev​a,b​​(0,5)+1}​​​=1​=1​=2​=3​=4​=5​​ 此时结果矩阵： 0 g l o v e s 0 0 1 2 3 4 5 6 l 1 1 1 2 3 4 5 o 2 v 3 e 4 2. 第三行（i=2）推导 leva,b(2,1)=Min{leva,b(1,1)+1, leva,b(2,0)+1, leva,b(1,0)+1}=2leva,b(2,2)=Min{leva,b(1,2)+1, leva,b(2,1)+1, leva,b(1,1)+1}=2leva,b(2,3)=Min{leva,b(1,3)+1, leva,b(2,2)+1, leva,b(1,2)}=1leva,b(2,4)=Min{leva,b(1,4)+1, leva,b(2,3)+1, leva,b(1,3)+1}=2leva,b(2,5)=Min{leva,b(1,5)+1, leva,b(2,4)+1, leva,b(1,4)+1}=3leva,b(2,6)=Min{leva,b(1,6)+1, leva,b(2,5)+1, leva,b(1,5)+1}=4\\begin{aligned} &amp; lev_{a, b}(2, 1) = Min\\{lev_{a, b}(1, 1)+1,\\ lev_{a, b}(2, 0)+1,\\ lev_{a, b}(1, 0)+1\\}&amp;= 2 \\\\ &amp; lev_{a, b}(2, 2) = Min\\{lev_{a, b}(1, 2)+1,\\ lev_{a, b}(2, 1)+1,\\ lev_{a, b}(1, 1)+1\\}&amp;= 2 \\\\ &amp; lev_{a, b}(2, 3) = Min\\{lev_{a, b}(1, 3)+1,\\ lev_{a, b}(2, 2)+1,\\ lev_{a, b}(1, 2)\\}&amp;= 1 \\\\ &amp; lev_{a, b}(2, 4) = Min\\{lev_{a, b}(1, 4)+1,\\ lev_{a, b}(2, 3)+1,\\ lev_{a, b}(1, 3)+1\\}&amp;= 2 \\\\ &amp; lev_{a, b}(2, 5) = Min\\{lev_{a, b}(1, 5)+1,\\ lev_{a, b}(2, 4)+1,\\ lev_{a, b}(1, 4)+1\\}&amp;= 3 \\\\ &amp; lev_{a, b}(2, 6) = Min\\{lev_{a, b}(1, 6)+1,\\ lev_{a, b}(2, 5)+1,\\ lev_{a, b}(1, 5)+1\\}&amp;= 4 \\\\ \\end{aligned} ​​​​​​​​​​lev​a,b​​(2,1)=Min{lev​a,b​​(1,1)+1, lev​a,b​​(2,0)+1, lev​a,b​​(1,0)+1}​lev​a,b​​(2,2)=Min{lev​a,b​​(1,2)+1, lev​a,b​​(2,1)+1, lev​a,b​​(1,1)+1}​lev​a,b​​(2,3)=Min{lev​a,b​​(1,3)+1, lev​a,b​​(2,2)+1, lev​a,b​​(1,2)}​lev​a,b​​(2,4)=Min{lev​a,b​​(1,4)+1, lev​a,b​​(2,3)+1, lev​a,b​​(1,3)+1}​lev​a,b​​(2,5)=Min{lev​a,b​​(1,5)+1, lev​a,b​​(2,4)+1, lev​a,b​​(1,4)+1}​lev​a,b​​(2,6)=Min{lev​a,b​​(1,6)+1, lev​a,b​​(2,5)+1, lev​a,b​​(1,5)+1}​​​=2​=2​=1​=2​=3​=4​​ 此时结果矩阵： 0 g l o v e s 0 0 1 2 3 4 5 6 l 1 1 1 2 3 4 5 o 2 2 2 1 2 3 4 v 3 e 4 2. 第四行（i=3）推导 leva,b(3,1)=Min{leva,b(2,1)+1, leva,b(3,0)+1, leva,b(2,0)+1}=3leva,b(3,2)=Min{leva,b(2,2)+1, leva,b(3,1)+1, leva,b(2,1)+1}=3leva,b(3,3)=Min{leva,b(2,3)+1, leva,b(3,2)+1, leva,b(2,2)+1}=2leva,b(3,4)=Min{leva,b(2,4)+1, leva,b(3,3)+1, leva,b(2,3)}=1leva,b(3,5)=Min{leva,b(2,5)+1, leva,b(3,4)+1, leva,b(2,4)+1}=2leva,b(3,6)=Min{leva,b(2,6)+1, leva,b(3,5)+1, leva,b(2,5)+1}=3\\begin{aligned} &amp; lev_{a, b}(3, 1) = Min\\{lev_{a, b}(2, 1)+1,\\ lev_{a, b}(3, 0)+1,\\ lev_{a, b}(2, 0)+1\\}&amp;= 3 \\\\ &amp; lev_{a, b}(3, 2) = Min\\{lev_{a, b}(2, 2)+1,\\ lev_{a, b}(3, 1)+1,\\ lev_{a, b}(2, 1)+1\\}&amp;= 3 \\\\ &amp; lev_{a, b}(3, 3) = Min\\{lev_{a, b}(2, 3)+1,\\ lev_{a, b}(3, 2)+1,\\ lev_{a, b}(2, 2)+1\\}&amp;= 2 \\\\ &amp; lev_{a, b}(3, 4) = Min\\{lev_{a, b}(2, 4)+1,\\ lev_{a, b}(3, 3)+1,\\ lev_{a, b}(2, 3)\\}&amp;= 1 \\\\ &amp; lev_{a, b}(3, 5) = Min\\{lev_{a, b}(2, 5)+1,\\ lev_{a, b}(3, 4)+1,\\ lev_{a, b}(2, 4)+1\\}&amp;= 2 \\\\ &amp; lev_{a, b}(3, 6) = Min\\{lev_{a, b}(2, 6)+1,\\ lev_{a, b}(3, 5)+1,\\ lev_{a, b}(2, 5)+1\\}&amp;= 3 \\\\ \\end{aligned} ​​​​​​​​​​lev​a,b​​(3,1)=Min{lev​a,b​​(2,1)+1, lev​a,b​​(3,0)+1, lev​a,b​​(2,0)+1}​lev​a,b​​(3,2)=Min{lev​a,b​​(2,2)+1, lev​a,b​​(3,1)+1, lev​a,b​​(2,1)+1}​lev​a,b​​(3,3)=Min{lev​a,b​​(2,3)+1, lev​a,b​​(3,2)+1, lev​a,b​​(2,2)+1}​lev​a,b​​(3,4)=Min{lev​a,b​​(2,4)+1, lev​a,b​​(3,3)+1, lev​a,b​​(2,3)}​lev​a,b​​(3,5)=Min{lev​a,b​​(2,5)+1, lev​a,b​​(3,4)+1, lev​a,b​​(2,4)+1}​lev​a,b​​(3,6)=Min{lev​a,b​​(2,6)+1, lev​a,b​​(3,5)+1, lev​a,b​​(2,5)+1}​​​=3​=3​=2​=1​=2​=3​​ 此时结果矩阵： 0 g l o v e s 0 0 1 2 3 4 5 6 l 1 1 1 2 3 4 5 o 2 2 2 1 2 3 4 v 3 3 3 2 1 2 3 e 4 2. 第五行（i=4）推导 leva,b(4,1)=Min{leva,b(3,1)+1, leva,b(4,0)+1, leva,b(3,0)+1}=4leva,b(4,2)=Min{leva,b(3,2)+1, leva,b(4,1)+1, leva,b(3,1)+1}=4leva,b(4,3)=Min{leva,b(3,3)+1, leva,b(4,2)+1, leva,b(3,2)+1}=3leva,b(4,4)=Min{leva,b(3,4)+1, leva,b(4,3)+1, leva,b(3,3)+1}=2leva,b(4,5)=Min{leva,b(3,5)+1, leva,b(4,4)+1, leva,b(3,4)}=1leva,b(4,6)=Min{leva,b(3,6)+1, leva,b(4,5)+1, leva,b(3,5)+1}=2\\begin{aligned} &amp; lev_{a, b}(4, 1) = Min\\{lev_{a, b}(3, 1)+1,\\ lev_{a, b}(4, 0)+1,\\ lev_{a, b}(3, 0)+1\\}&amp;= 4 \\\\ &amp; lev_{a, b}(4, 2) = Min\\{lev_{a, b}(3, 2)+1,\\ lev_{a, b}(4, 1)+1,\\ lev_{a, b}(3, 1)+1\\}&amp;= 4 \\\\ &amp; lev_{a, b}(4, 3) = Min\\{lev_{a, b}(3, 3)+1,\\ lev_{a, b}(4, 2)+1,\\ lev_{a, b}(3, 2)+1\\}&amp;= 3 \\\\ &amp; lev_{a, b}(4, 4) = Min\\{lev_{a, b}(3, 4)+1,\\ lev_{a, b}(4, 3)+1,\\ lev_{a, b}(3, 3)+1\\}&amp;= 2 \\\\ &amp; lev_{a, b}(4, 5) = Min\\{lev_{a, b}(3, 5)+1,\\ lev_{a, b}(4, 4)+1,\\ lev_{a, b}(3, 4)\\}&amp;= 1 \\\\ &amp; lev_{a, b}(4, 6) = Min\\{lev_{a, b}(3, 6)+1,\\ lev_{a, b}(4, 5)+1,\\ lev_{a, b}(3, 5)+1\\}&amp;= 2 \\\\ \\end{aligned} ​​​​​​​​​​lev​a,b​​(4,1)=Min{lev​a,b​​(3,1)+1, lev​a,b​​(4,0)+1, lev​a,b​​(3,0)+1}​lev​a,b​​(4,2)=Min{lev​a,b​​(3,2)+1, lev​a,b​​(4,1)+1, lev​a,b​​(3,1)+1}​lev​a,b​​(4,3)=Min{lev​a,b​​(3,3)+1, lev​a,b​​(4,2)+1, lev​a,b​​(3,2)+1}​lev​a,b​​(4,4)=Min{lev​a,b​​(3,4)+1, lev​a,b​​(4,3)+1, lev​a,b​​(3,3)+1}​lev​a,b​​(4,5)=Min{lev​a,b​​(3,5)+1, lev​a,b​​(4,4)+1, lev​a,b​​(3,4)}​lev​a,b​​(4,6)=Min{lev​a,b​​(3,6)+1, lev​a,b​​(4,5)+1, lev​a,b​​(3,5)+1}​​​=4​=4​=3​=2​=1​=2​​ 此时结果矩阵： 0 g l o v e s 0 0 1 2 3 4 5 6 l 1 1 1 2 3 4 5 o 2 2 2 1 2 3 4 v 3 3 3 2 1 2 3 e 4 4 4 3 2 1 2 四、代码实现 123456789101112131415161718192021222324252627282930313233343536373839# 基于动态规划的解法def edit_dist(str1, str2): # m，n分别字符串str1和str2的长度 m, n = len(str1), len(str2) # 定义不同运算操作的代价 C_insert = C_delete = C_replace = 1 # 构建二位数组来存储子 Edit Distance 的答案 dp = [[0]*(n+1) for x in range(m+1)] # 利用动态规划算法，填充数组 for i in range(m+1): for j in range(n+1): # 假设第一个字符串为空，则转换的代价为j (j次的插入) # 同样的，假设第二个字符串为空，则转换的代价为i (i次的插入) if min(i, j) == 0: dp[i][j] = max(i, j) # 如果最后一个字符相等，就不会产生代价 elif str1[i-1] == str2[j-1]: dp[i][j] = dp[i-1][j-1] # 如果最后一个字符不一样，则考虑多种可能性，并且选择其中最小的值 else: dp[i][j] = min(dp[i][j-1] + C_insert, # Insert dp[i-1][j] + C_delete, # Remove dp[i-1][j-1] + C_replace) # Replace for item in dp: print(item) return dp[m][n]print(edit_dist(&quot;love&quot;, &quot;gloves&quot;)) # 2# [0, 1, 2, 3, 4, 5, 6]# [1, 1, 1, 2, 3, 4, 5]# [2, 2, 2, 1, 2, 3, 4]# [3, 3, 3, 2, 1, 2, 3]# [4, 4, 4, 3, 2, 1, 2]","categories":[{"name":"nlp","slug":"nlp","permalink":"http://wzr1998.github.io/categories/nlp/"}],"tags":[{"name":"nlp","slug":"nlp","permalink":"http://wzr1998.github.io/tags/nlp/"},{"name":"算法","slug":"算法","permalink":"http://wzr1998.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Dynamic Programming","slug":"Minimum-Dynamic-Programming","date":"2020-12-03T13:28:15.000Z","updated":"2020-12-04T11:18:48.165Z","comments":true,"path":"posts/71b19194/","link":"","permalink":"http://wzr1998.github.io/posts/71b19194/","excerpt":"","text":"一、Dynamic Programming 1. 概念 Dynamic programming solves problems by combining the solutions to sub-problems. 为了解决当前问题，不断构造当前问题的子问题，通过计算简单子问题的结果一步步计算复杂问题(多阶段决策最优解) A dynamic-programming algorithm solves every sub-problem just once and then saves its answer in a table, thereby avoiding the work of recomputing the answer every time the sub-problem is encountered. 解决动态规划问题通常会创建一维或二维数组，主要用于存储中间子问题的结果而避免重复计算 案例参考：https://people.cs.clemson.edu/~bcdean/dp_practice/ 2. 动态规划问题特征 最优子结构：通过子问题的最优解，推导问题最优解 无后效性：只关心前一个状态，不关心推导过程 重复子问题：不同的决策阶段有重复的状态 3. 动态规划解题思路 (1). 将原问题分解为子问题 子问题和原问题形式相同或类似。子问题解决了，原问题即解决 (2). 定义数组元素的含义 用一个一维或两维数组保存历史记录，子问题的解一旦求出就保存到数组中，“数组”的大小与用动态规划的时间复杂度直接相关 (3). 找出数组元素之间的关系式(状态转移方程) 找出如何利用历史数据来推出新的元素值，也就是找到数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2] (4). 确定一些初始值 初始化，例如dp[2] 和 dp[1] 是不能再分解的了，所以必须要找到直接获得 dp[2] 和 dp[1] 的值 二、Fibonacci Sequence Fibonacci sequence：1, 1, 2, 3, 5, 8, 13, 21…；f(n)=15(1+52)n−15(1−52)nf(n)=\\frac{1}{\\sqrt{5}}(\\frac{1+\\sqrt{5}}{2})^n-\\frac{1}{\\sqrt{5}}(\\frac{1-\\sqrt{5}}{2})^nf(n)=​√​5​​​​​1​​(​2​​1+√​5​​​​​)​n​​−​√​5​​​​​1​​(​2​​1−√​5​​​​​)​n​​ 转移方程：f(n)=f(n−1)+f(n−2)f(n) = f(n-1) + f(n-2)f(n)=f(n−1)+f(n−2) 1. 递归实现 递归实现，时间复杂度 O(n2)O(n^2)O(n​2​​) ： 123456def fib(i): if i == 1 or i == 2: return 1 else: return fib(i-1) + fib(i-2)fib(10) # 55 存在问题： 时间、空间复杂度高 存在大量重复计算 执行过程如下： 2. 递归算法改进 创建一维数组存储 f(i)f(i)f(i) 值，若之前计算过则直接返回存储值，避免重复计算 123456789101112memo = [0]*100memo[0] = memo[1] = 1def fib(i): if memo[i]: return memo[i] if i &lt; 3: return 1 elif i &gt;= 3: result = fib(i-1) + fib(i-2) memo[i] = result return resultprint(fib(9)) # 34 3. DP 实现 由于 f(1)=f(2)=1f(1) = f(2) = 1f(1)=f(2)=1 已知，则仅需知道 f(i)f(i)f(i) 前两项值即可。 令 a=f(i−2),b=f(i−1),c=f(i)a = f(i-2), b = f(i-1), c = f(i)a=f(i−2),b=f(i−1),c=f(i) ，从 f(3)f(3)f(3) 迭代至 f(n)f(n)f(n) ，代码如下： 1234567891011121314def fib_dp(n): a, b, c = 1, 1, 0 if n == 1 or n == 2: return 1 # i 取0至n-1，对应 Fibonacci Sequence 第1至n位 for i in range(2,n): c = a + b a = b b = c return c print(fib_dp(8)) # 21 三、Maximum Value Continuous Subsequence 问题：给定一个一维数组A[n]，寻找子数组使得它们各数据之和最大。 比如：(1, -1, -2, 3, 5, -1, 4, -2) =&gt; (3, 5, -1, 4) 1. 解题思路 A[j]：数组的第 j 个元素值 M[j]：以j为截止节点的 数据之和最大的 子数组的 数据之和 转移方程 M[j]=Max{M[j−1]+A[j],A[j]}M[j] = \\text Max\\{M[j-1] + A[j], A[j]\\}M[j]=Max{M[j−1]+A[j],A[j]}，时间复杂度O(n) 其中，取 M[j−1]+A[j]M[j-1] + A[j]M[j−1]+A[j] 代表加入第 j 个元素后，j 元素前子数组数据之和可以变得更大，把第 j 个元素加入前边子数组中；取 A[j] 则表示从第 j 位为起始新开一个新窗口。 按照此方法从 M[0] 开始不断进行迭代计算到 M[j]。具体计算过程如下： 2. 代码实现 12345678910111213141516import sysdef max_subseq_sum(arr): max_subsequence_sum = -sys.maxsize # 记录最终最大子序列和的值 max_current = 0 # 记录第i位之前序列最大子序列之和 for i in range(0, len(arr)): subsequence_add = max_current + arr[i] # 迭代计算M[i] = Max&#123;M[i-1] + A[i], A[i]&#125; max_current = subsequence_add if subsequence_add &gt;= arr[i] else arr[i] max_subsequence_sum = max_current if max_subsequence_sum &lt; max_current else max_subsequence_sum return max_subsequence_sumprint(max_subseq_sum([-2, -3, 4, -1, -2, 1, 5, -3])) # 7print(max_subseq_sum([-1, 1, 2, 3, 4, -5, 2, 4])) # 11 四、Coin Change Problem 1. 问题描述 假如有n种硬币，面值分别为 1≤V1&lt;V2&lt;V3…&lt;Vn1\\leq V_1 &lt; V_2 &lt; V_3 \\ldots &lt; V_n1≤V​1​​&lt;V​2​​&lt;V​3​​…&lt;V​n​​ ，想把手里面值为 C 的纸币换成硬币，要求硬币数量越少越好，应如何设计方案？ 2. 解决方案 M[i]：换取面值为 j 纸币的最小硬币数，i从1开始到C不断迭代，迭代过程中一次尝试替换所有硬币种类，选择当前硬币数最小方案，在第i个面值纸币则比较： M(i)={M(j−V1)+1M(j−V2)+1M(j−V3)+1=&gt;M(j)=Min{M(j−Vi)+1}…M(j−Vn)+1\\begin{aligned} M(i)= \\begin{cases} M(j-V_1)+1\\\\ M(j-V_2)+1\\\\ M(j-V_3)+1 \\quad \\quad =&gt; \\quad \\quad M(j) = Min\\{M(j-V_i)+1\\}\\\\ \\ldots\\\\ M(j-V_n)+1 \\end{cases} \\end{aligned} ​M(i)=​⎩​⎪​⎪​⎪​⎪​⎪​⎪​⎨​⎪​⎪​⎪​⎪​⎪​⎪​⎧​​​M(j−V​1​​)+1​M(j−V​2​​)+1​M(j−V​3​​)+1=&gt;M(j)=Min{M(j−V​i​​)+1}​…​M(j−V​n​​)+1​​​​ 例如当 Coins=[1,2,3]; C=7Coins = [1, 2, 3]; \\ \\ \\ C = 7Coins=[1,2,3]; C=7 时，运算过程如下： M(0)=0M(1)=M(1−1)+1=1M(2)=Min{M(2−1)+1,M(2−2)+1}=Min{1+1,0+1}=1M(3)=Min{M(3−1)+1,M(3−2)+1+M(3−3)+1}=Min{1+1, 1+1, 0+1}=1M(4)=Min{M(4−1)+1,M(4−2)+1+M(4−3)+1}=Min{1+1, 1+1, 1+1}=2M(5)=Min{M(5−1)+1,M(5−2)+1+M(5−3)+1}=Min{2+1, 1+1, 1+1}=2M(6)=Min{M(6−1)+1,M(6−2)+1+M(6−3)+1}=Min{2+1, 2+1, 1+1}=2M(7)=Min{M(7−1)+1,M(7−2)+1+M(7−3)+1}=Min{2+1, 2+1, 2+1}=3\\begin{aligned} &amp; M(0) = 0\\\\\\\\ &amp; M(1) = M(1-1)+1 = 1\\\\\\\\ &amp; M(2) = Min\\{M(2-1)+1, M(2-2)+1\\} = Min\\{1+1, 0+1\\} = 1\\\\\\\\ &amp; M(3) = Min\\{M(3-1)+1, M(3-2)+1 + M(3-3)+1\\} = Min\\{1+1, \\ 1+1, \\ 0+1\\} = 1\\\\\\\\ &amp; M(4) = Min\\{M(4-1)+1, M(4-2)+1 + M(4-3)+1\\} = Min\\{1+1, \\ 1+1, \\ 1+1\\} = 2\\\\\\\\ &amp; M(5) = Min\\{M(5-1)+1, M(5-2)+1 + M(5-3)+1\\} = Min\\{2+1, \\ 1+1, \\ 1+1\\} = 2\\\\\\\\ &amp; M(6) = Min\\{M(6-1)+1, M(6-2)+1 + M(6-3)+1\\} = Min\\{2+1, \\ 2+1, \\ 1+1\\} = 2\\\\\\\\ &amp; M(7) = Min\\{M(7-1)+1, M(7-2)+1 + M(7-3)+1\\} = Min\\{2+1, \\ 2+1, \\ 2+1\\} = 3\\\\ \\end{aligned} ​​​​​​​​​​​​​​​​​​​M(0)=0​M(1)=M(1−1)+1=1​M(2)=Min{M(2−1)+1,M(2−2)+1}=Min{1+1,0+1}=1​M(3)=Min{M(3−1)+1,M(3−2)+1+M(3−3)+1}=Min{1+1, 1+1, 0+1}=1​M(4)=Min{M(4−1)+1,M(4−2)+1+M(4−3)+1}=Min{1+1, 1+1, 1+1}=2​M(5)=Min{M(5−1)+1,M(5−2)+1+M(5−3)+1}=Min{2+1, 1+1, 1+1}=2​M(6)=Min{M(6−1)+1,M(6−2)+1+M(6−3)+1}=Min{2+1, 2+1, 1+1}=2​M(7)=Min{M(7−1)+1,M(7−2)+1+M(7−3)+1}=Min{2+1, 2+1, 2+1}=3​​ 3. 代码实现 123456789101112131415161718192021import sys# coins: 硬币的面值序列；C: 需要换的纸币面值def minCoins(coins, C): # table[i] 存储换取面值为i的纸币，需要用到的最少量的硬币数，同时进行初始化 table = [0] + [sys.maxsize] * C # 对于每一种价值i来计算，最少用多少硬币可以换取？ for i in range(1, C+1): # 循环各硬币 for j in range(len(coins)): if (coins[j] &lt;= i): # 目前纸币面值i足够换取当前硬币coins[j] sub_res = table[i-coins[j]] # sub_res 表示换取其中一个硬币剩下的钱 if sub_res + 1 &lt; table[i]: table[i] = sub_res + 1 print(table) # [0, 1, 1, 1, 2, 2, 2, 3] return table[C]print(minCoins([1, 2, 3], 7)) # 3","categories":[{"name":"算法","slug":"算法","permalink":"http://wzr1998.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://wzr1998.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Python 杂记(不定时更新)","slug":"Python-杂记","date":"2020-12-03T13:03:23.000Z","updated":"2020-12-03T13:26:39.810Z","comments":true,"path":"posts/481fac7e/","link":"","permalink":"http://wzr1998.github.io/posts/481fac7e/","excerpt":"","text":"一、arr[~i] 1. 概念 ~ ：按位取反运算符，对数据的每个二进制位取反,即把1变为0,把0变为1 。在数值上 ~x 等同于 -x-1 ，例如： x 二进制表示为：0011 1100，十进制对应 60 ~x 二进制表示为：1100 0011，十进制对应 -61 2. 应用 可用于 reverse 操作，arr[~i] 对应末尾索引为 0 序列的右数第 i 位 arr[i] 与 arr[~i] 距离序列左右两端距离相等，成对称关系 例：列表 reverse 操作： 12345678import mathnum_list = [i for i in range(10)]print(num_list[~3]) # 6print(num_list) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]for i in range(math.floor(len(num_list)/2)): num_list[i], num_list[~i] = num_list[~i], num_list[i]print(num_list) # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]","categories":[{"name":"Python","slug":"Python","permalink":"http://wzr1998.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://wzr1998.github.io/tags/Python/"}]},{"title":"递归类算法时间复杂度一般情况","slug":"递归类算法时间复杂度一般情况","date":"2020-11-28T17:10:22.000Z","updated":"2020-12-04T10:41:46.478Z","comments":true,"path":"posts/bf975941/","link":"","permalink":"http://wzr1998.github.io/posts/bf975941/","excerpt":"","text":"一、递归函数一般形式 1. 递归算法时间复杂度有如下形式： T(n)=a∗T(nb)+O(nd)T(nb)=a∗T(nb2)+O(ndbd)T(nb2)=a∗T(nb3)+O(nd(b2)d)…T(nbk)=a∗T(nbk+1)+O(nd(bk)d)\\begin{aligned} &amp; T(n)=a*T(\\frac{n}{b})+O(n^d)\\\\\\\\ &amp; T(\\frac{n}{b})=a*T(\\frac{n}{b^2})+O(\\frac{n^d}{b^d})\\\\\\\\ &amp; T(\\frac{n}{b^2})=a*T(\\frac{n}{b^3})+O(\\frac{n^d}{(b^2)^d})\\\\\\\\ &amp; \\ldots\\\\\\\\ &amp; T(\\frac{n}{b^k})=a*T(\\frac{n}{b^{k+1}})+O(\\frac{n^d}{(b^k)^d})\\\\\\\\ \\end{aligned} ​​​​​​​​​​​​​​T(n)=a∗T(​b​​n​​)+O(n​d​​)​T(​b​​n​​)=a∗T(​b​2​​​​n​​)+O(​b​d​​​​n​d​​​​)​T(​b​2​​​​n​​)=a∗T(​b​3​​​​n​​)+O(​(b​2​​)​d​​​​n​d​​​​)​…​T(​b​k​​​​n​​)=a∗T(​b​k+1​​​​n​​)+O(​(b​k​​)​d​​​​n​d​​​​)​​ T(n)T(n)T(n) 为当前函数总时间复杂度 aaa 为当前递归函数分为子函数个数 bbb 为当前递归函数子函数运算量 O(nd)O(n^d)O(n​d​​) 为当前递归函数内部运算时间复杂度 2. 将各子式带入，经历iii 次递归后得到 T()T()T() 最终时间复杂度： T(n)=a∗T(nb)+O(nd)=a2∗T(nb2)+a∗ndbd+nd=a3∗T(nb3)+a2∗nd(b2)d+a∗nd+nd=…=ak∗T(1)+∑i=1k−1aind(bi)d=O(∑i=1k−1aind(bi)d)\\begin{aligned} T(n) &amp; =a*T(\\frac{n}{b})+O(n^d)\\\\\\\\ &amp; =a^2*T(\\frac{n}{b^2})+a*\\frac{n^d}{b^d}+n^d\\\\\\\\ &amp; =a^3*T(\\frac{n}{b^3})+a^2*\\frac{n^d}{(b^2)^d}+a*n^d+n^d\\\\\\\\ &amp; =\\ldots\\\\\\\\ &amp; =a^k*T(1)+\\displaystyle\\sum_{i=1}^{k-1}a^i\\frac{n^d}{(b^i)^d}\\\\\\\\ &amp; = O(\\displaystyle\\sum_{i=1}^{k-1}a^i\\frac{n^d}{(b^i)^d}) \\end{aligned} ​T(n)​​​​​​​​​​​​​=a∗T(​b​​n​​)+O(n​d​​)​=a​2​​∗T(​b​2​​​​n​​)+a∗​b​d​​​​n​d​​​​+n​d​​​=a​3​​∗T(​b​3​​​​n​​)+a​2​​∗​(b​2​​)​d​​​​n​d​​​​+a∗n​d​​+n​d​​​=…​=a​k​​∗T(1)+​i=1​∑​k−1​​a​i​​​(b​i​​)​d​​​​n​d​​​​​=O(​i=1​∑​k−1​​a​i​​​(b​i​​)​d​​​​n​d​​​​)​​ 因此，T(n)=O(∑i=1k−1aind(bi)d)=O(∑i=1k−1(abd)ind)T(n)= O(\\displaystyle\\sum_{i=1}^{k-1}a^i\\frac{n^d}{(b^i)^d})= O(\\displaystyle\\sum_{i=1}^{k-1}(\\frac{a}{b^d})^in^d)T(n)=O(​i=1​∑​k−1​​a​i​​​(b​i​​)​d​​​​n​d​​​​)=O(​i=1​∑​k−1​​(​b​d​​​​a​​)​i​​n​d​​) 为等比数列前 k−1k-1k−1 项和，首项、公比如下： a0=abdndq=abds=a0(1−qk)1−qa_0=\\frac{a}{b^d}n^d \\quad\\quad\\quad q=\\frac{a}{b^d} \\quad\\quad\\quad s=\\frac{a_0(1-q^k)}{1-q} a​0​​=​b​d​​​​a​​n​d​​q=​b​d​​​​a​​s=​1−q​​a​0​​(1−q​k​​)​​ 3. 则递归算法时间复杂度 T()T()T() 为： T(n)={O(nd)abd&lt;1O(k∗nd)abd=1O(qk∗nd)abd&gt;1T(n)= \\begin{cases} O(n^d) &amp; \\frac{a}{b^d}&lt;1\\\\\\\\ O(k*n^d) &amp; \\frac{a}{b^d}=1\\\\\\\\ O(q^k*n^d) &amp; \\frac{a}{b^d}&gt;1 \\end{cases} T(n)=​⎩​⎪​⎪​⎪​⎪​⎪​⎪​⎪​⎨​⎪​⎪​⎪​⎪​⎪​⎪​⎪​⎧​​​O(n​d​​)​​O(k∗n​d​​)​​O(q​k​​∗n​d​​)​​​​b​d​​​​a​​&lt;1​​b​d​​​​a​​=1​​b​d​​​​a​​&gt;1​​ 其中： O(k∗nd)=O(ndlogbn)≤O(ndlog2n)O(qk∗nd)=O(nd∗(abd)logbn)=O(nd∗alogbnbdlogbn)=O(nd∗alogbnnd)=alogbn=aloganlogab=n1logab=blogba\\begin{aligned} &amp; O(k*n^d)=O(n^d\\log_b n) \\leq O(n^d\\log_2 n)\\\\\\\\ &amp; O(q^k*n^d) = O(n^d*(\\frac{a}{b^d})^{\\log_b n}) = O(n^d*\\frac{a^{\\log_b n}}{b^{d\\log_b n}}) =O(n^d*\\frac{a^{\\log_b n}}{n^d}) = a^{\\log_b n} = a^{\\frac{\\log_a n}{\\log_a b}} = n^{\\frac1 {\\log_a b}} = b^{\\log_b a}\\\\ \\end{aligned} ​​​​​​​O(k∗n​d​​)=O(n​d​​log​b​​n)≤O(n​d​​log​2​​n)​O(q​k​​∗n​d​​)=O(n​d​​∗(​b​d​​​​a​​)​log​b​​n​​)=O(n​d​​∗​b​dlog​b​​n​​​​a​log​b​​n​​​​)=O(n​d​​∗​n​d​​​​a​log​b​​n​​​​)=a​log​b​​n​​=a​​log​a​​b​​log​a​​n​​​​=n​​log​a​​b​​1​​​​=b​log​b​​a​​​​ 4. 因此递归算法时间复杂度 T()T()T() 最终为： T(n)={O(nd)abd&lt;1O(ndlogbn)abd=1O(nlogba)abd&gt;1T(n)= \\begin{cases} O(n^d) &amp; \\frac{a}{b^d}&lt;1\\\\\\\\ O(n^d\\log_b n) &amp; \\frac{a}{b^d}=1\\\\\\\\ O(n^{\\log_b a}) &amp; \\frac{a}{b^d}&gt;1 \\end{cases} T(n)=​⎩​⎪​⎪​⎪​⎪​⎪​⎪​⎪​⎨​⎪​⎪​⎪​⎪​⎪​⎪​⎪​⎧​​​O(n​d​​)​​O(n​d​​log​b​​n)​​O(n​log​b​​a​​)​​​​b​d​​​​a​​&lt;1​​b​d​​​​a​​=1​​b​d​​​​a​​&gt;1​​ 5. Application to common algorithms 二、案例：Merge Sort 基本步骤： 分解：将n个元素分成个含n/2个元素的子序列。 解决：用合并排序法对两个子序列递归的排序。 合并：合并两个已排序的子序列已得到排序结果。 结合递归函数时间复杂度一般形式：a=2, b=1, d=1。因此时间复杂度为： O(n)=nlognO(n)=nlognO(n)=nlogn","categories":[{"name":"算法","slug":"算法","permalink":"http://wzr1998.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://wzr1998.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"nlp: Maximum Matching","slug":"nlp-Maximum-Matching","date":"2020-11-16T05:36:34.000Z","updated":"2020-12-03T13:00:23.408Z","comments":true,"path":"posts/69585860/","link":"","permalink":"http://wzr1998.github.io/posts/69585860/","excerpt":"","text":"一、中文分词算法概览 1. 基于词表的分词算法 正向最大匹配法 逆向最大匹配法 双向最大匹配算法 2. 基于统计模型的分词算法 基于N-gram语言模型的分词方法 3. 基于序列标注的分词算法 基于HMM的分词方法 基于CRF的分词方法 基于深度学习的端到端的分词方法 二、Forward Max Matching 1. 算法概述 对于输入的一段文本从左至右、以贪心的方式 出当前位置上长度最大的词。正向最大匹配法是基于词典的分词方法 ，其分词原理是：单词的颗粒度越大，所能表示的含义越确切。 2. 算法步骤 一般从一个字符串的开始位置，选择一个最大长度的词长的片段，如果序列不足最大词长，则选择全部序列。 首先看该片段是否在词典中，如果是，则算为一个分出来的词，如果不是，则从右边开始，减少一个字符，然后看短一点的这个片段是否在词典中，依次循环，逐到只剩下一个字。 序列变为第2步骤截取分词后，剩下的部分序列 分词过程如下： index 0 1 2 3 4 5 6 7 8 9 10 data 我 本 科 毕 业 于 黑 龙 江 大 学 pos remain characters start character max matching 0 我本科毕业于黑龙江大学 我 我 1 本科毕业于黑龙江大学 本 本科 3 毕业于黑龙江大学 毕 毕业 5 于黑龙江大学 于 于 6 黑龙江大学 黑 黑龙江大学 3. 代码实现 1234567891011121314151617181920212223# 导入字典word_dic = []with open(&quot;./dic.txt&quot;, &quot;r&quot;, encoding=&quot;utf8&quot;) as dic: for word in dic: word_dic.append(word.strip())# 前向最大匹配算法def FMM(ori_sentence, word_dic): sentence = ori_sentence.strip() sentence_split = [] dict_max_length = max(len(word) for word in word_dic) while sentence: split_length = min(len(sentence), dict_max_length) sub_sentence = sentence[0:split_length] while split_length: if sub_sentence in word_dic or split_length == 1: sentence_split.append(sub_sentence) sentence = sentence[split_length:] break else: sub_sentence = sub_sentence[:-1] split_length -= 1 return sentence_split 三、Backward Max Matching 1. 算法概述 基本原理与正向最大匹配法类似，只是分词顺序变为从右至左。 分词过程如下： index 0 1 2 3 4 5 6 7 8 9 10 data 我 本 科 毕 业 于 黑 龙 江 大 学 pos remain characters start character max matching 6 我本科毕业于黑龙江大学 黑 黑龙江大学 5 我本科毕业于 于 于 3 我本科毕业 毕 毕业 1 我本科 本 本科 0 我 我 我 2. 代码实现 123456789101112131415161718192021222324# 导入字典word_dic = []with open(&quot;./dic.txt&quot;, &quot;r&quot;, encoding=&quot;utf8&quot;) as dic: for word in dic: word_dic.append(word.strip())# 后向最大匹配算法def BMM(ori_sentence, word_dic): sentence = ori_sentence.strip() sentence_split = [] max_dict_length = max(len(word) for word in word_dic) while sentence: split_length = min(len(sentence), max_dict_length) sub_sentence = sentence[-split_length:] while split_length: if sub_sentence in word_dic or split_length == 1: sentence_split.append(sub_sentence) sentence = sentence[0:-split_length] break else: split_length -= 1 sub_sentence = sub_sentence[1:] sentence_split.reverse() # 无返回值，直接改变原列表 return sentence_split 3. 算法问题 FMM或BMM对于一些有歧义的词处理能力一般。举个例子： 结婚的和尚未结婚的，使用FMM很可能分成结婚/的/和尚/未/结婚/的； 为人民办公益，使用BMM可能会分成为人/民办/公益。 四、Bi-directction Matching 1. 算法概述：采用启发式原则 如果正反向分词结果词数不同，则取分词数量较少的那个。 如果分词结果词数相同 分词结果相同，就说明没有歧义，可返回任意一个。 分词结果不同，返回其中单字较少的那个。 2. 代码实现 12345678910111213141516171819202122232425262728# 导入字典word_dic = []with open(&quot;./dic.txt&quot;, &quot;r&quot;, encoding=&quot;utf8&quot;) as dic: for word in dic: word_dic.append(word.strip())# 双向最大匹配算法def MM(ori_sentence, word_dic): sentence = ori_sentence.strip() FMM_split = FMM(sentence, word_dic) BMM_split = BMM(sentence, word_dic) if len(BMM_split) != len(FMM_split): return BMM_split if len(BMM_split) &lt; len(FMM_split) else FMM_split else: FMM_single = 0 BMM_single = 0 is_same = 1 for i in range(len(FMM_split)): if FMM_split[i] != BMM_split[i]: is_same = 0 if len(FMM_split[i]) == 1: FMM_single += 1 if len(BMM_split[i]) == 1: BMM_single += 1 if is_same: return FMM_split else: return FMM_split if FMM_single &lt;= BMM_single else BMM_split 五、MM分词结果案例 放大图片 六、常用分词工具包 Jieba分词：https://github.com/fxsjy/jieba SnowNLP：https://github.com/isnowfy/snownlp LTP：http://www.ltp-cloud.com/ HanNLP：https://github.com/hankcs/HanLP/","categories":[{"name":"nlp","slug":"nlp","permalink":"http://wzr1998.github.io/categories/nlp/"}],"tags":[{"name":"nlp","slug":"nlp","permalink":"http://wzr1998.github.io/tags/nlp/"},{"name":"nlp分词","slug":"nlp分词","permalink":"http://wzr1998.github.io/tags/nlp%E5%88%86%E8%AF%8D/"}]},{"title":"Python Spider Tool","slug":"Python-Spider-Tool","date":"2020-11-10T05:55:44.000Z","updated":"2020-12-03T07:42:47.509Z","comments":true,"path":"posts/aeee0d4/","link":"","permalink":"http://wzr1998.github.io/posts/aeee0d4/","excerpt":"","text":"案例：爬取b站直播平台主播数据 一、引入 re、urllib 12345from urllib import requestimport sslimport re# Mac 端需配置ssl，不然会报错ssl._create_default_https_context = ssl._create_unverified_context 二、获取 HTML 文档 1234URL = &quot;https://live.bilibili.com/p/eden/area-tags?areaId=0&amp;parentAreaId=6&quot;data_HTTPResponse = request.urlopen(URL)data_bytes = data_HTTPResponse.read()data_text = str(data_bytes, encoding=&quot;utf-8&quot;) 三、正则匹配 1234567891011pattern_wrap = &#x27;&lt;div class=&quot;room-anchor card-text p-relative&quot;([\\w\\W]+?)&lt;/div&gt;&#x27;pattern_name = &#x27;&lt;span title=[\\w\\W]+?&gt;([\\w\\W]+?)&lt;/span&gt;&#x27;pattern_count = &#x27;&lt;span class[\\w\\W]+?&gt;([\\w\\W]+?)&lt;/span&gt;&#x27;up_list = re.findall(pattern_wrap, data_text)result_list = []for item in up_list: name = re.findall(pattern_name, item)[0] count = re.findall(pattern_count, item)[0] result_list.append([name, count]) 四、数据清洗 1234567for item in result_list: if &quot;万&quot; in item[ 1 ]: num = re.findall(&#x27;([\\d\\.]+)&#x27; , item[ 1 ]) item[ 1 ] = int(float(num[ 0 ]) * 10000) item[ 1 ] = int(item[ 1 ]) print(item) 五、代码封装 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869from urllib import requestimport sslimport ressl._create_default_https_context = ssl._create_unverified_contextclass Spider: URL = &#x27;&#x27; WEB_DATA = &#x27;&#x27; PATTERN = [] @classmethod def __get_data(cls): data = request.urlopen(cls.URL) cls.WEB_DATA = str(data.read(), encoding=&quot;utf-8&quot;) @classmethod def __spider_data(cls): def fn(pattern, text): if type(pattern) == str: # 当前为正则 spider_text = re.findall(pattern, text) return spider_text elif type(pattern) == dict: # 当前为外包裹 spider_text_list = re.findall(pattern[&quot;pattern&quot;], text) # 有多组匹配结果 data_list = [] for i in range(len(spider_text_list)): # 遍历每个匹配结果，在匹配结果中继续筛选 current_spider_data = [] for child_pattern in pattern[&quot;children&quot;]: # 根据包裹中子正则继续在匹配结果匹配 data = fn(child_pattern, spider_text_list[i]) # 可能是单一文字，可能是文字子列表 current_spider_data += data data_list.append(current_spider_data) return data_list return fn(cls.PATTERN, cls.WEB_DATA) def get_data(self,pattern, fn): self.__class__.PATTERN = pattern self.result = data = self.__class__.__spider_data() fn(data) return data def __init__(self, URL, **kwargs): self.__class__.URL = URL self.__class__.__get_data()if __name__ == &#x27;__main__&#x27;: pattern = &#123; &quot;pattern&quot;: &#x27;&lt;div class=&quot;room-anchor card-text p-relative&quot;([\\w\\W]+?)&lt;/div&gt;&#x27;, &quot;children&quot;: [ &#x27;&lt;span title=[\\w\\W]+?&gt;([\\w\\W]+?)&lt;/span&gt;&#x27;, &#x27;&lt;span class[\\w\\W]+?&gt;([\\w\\W]+?)&lt;/span&gt;&#x27;, ] &#125; spider = Spider(&quot;https://live.bilibili.com/p/eden/area-tags?areaId=0&amp;parentAreaId=6&quot;) def parse(data): for item in data: if &quot;万&quot; in item[1]: num = re.findall(&#x27;([\\d\\.]+)&#x27;, item[1]) item[ 1 ] = int(float(num[0]) * 10000) print(item) spider.get_data(pattern, parse) 六、爬取结果","categories":[{"name":"Python","slug":"Python","permalink":"http://wzr1998.github.io/categories/Python/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://wzr1998.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"Python","slug":"Python","permalink":"http://wzr1998.github.io/tags/Python/"}]},{"title":"Python RegExp","slug":"Python-RegExp","date":"2020-11-05T05:24:33.000Z","updated":"2020-11-26T05:59:00.544Z","comments":true,"path":"posts/cd073991/","link":"","permalink":"http://wzr1998.github.io/posts/cd073991/","excerpt":"","text":"Python 正则表达式 一、正则基础 正则：是一个特殊的字符序列，用于快速检索文本，实现查找、替换等操作 （一）元字符 \\d、\\D：数字、非数字；等同于[0-9] \\w、\\W：字符、非字符 ( 字母 ，数字，下划线 )；等同于[A-Za-z0-9_] \\s、\\S : 空白字符、非空白字符(空格、回车、制表符等)；等同于[ \\f\\n\\r\\t\\v] \\b、\\B : 独立的部分 （ 起始，结束，空格 ）、非独立的部分 .：匹配除换行符 \\n 外的其他所有字符 （二）字符集、取反、范围 方括号，方括号内字符是或的关系，^ 为取反，- 表范围 &quot;a[bc]d&quot;：匹配abd、acd &quot;a[^bc]d&quot;：匹配除abd、acd外所有字符 &quot;a[x-z]b&quot;：匹配axb、ayb、azb （三）数量词 花括号，花括号内表示前一单个字符出现范围，默认采用贪婪模式，在满足条件范围内匹配最长字符串 [a-z]&#123;a,b&#125;：匹配任意a到b位字母的排列组合 wzr*：* 前字符匹配0次或无限多次(wz/wzr/wzrr/wzrrr…)；等同于 wzr&#123;0,&#125; wzr+：+ 前字符至少出现1次(wzr/wzrr/wzrrr…)；等同于 wzr&#123;1,&#125; wzr?：? 前字符出现0次或1次(wz/wzr)；等同于 wzr&#123;0,1&#125;，&quot;?&quot; 是数量词 非贪婪模式：在数量词后加&quot;?&quot;，如 \\w&#123;3,6&#125;? 则至多匹配三个字符，等同于 \\w&#123;3&#125;， “?” 是转换非贪婪模式的关键字 （四）组 小括号，小括号内字符串表示一组，括号内文字相互是且的关系，并返回组内内容，默认正则整体是一个组 (python)&#123;1,3&#125; 表示字符串内重复出现1次至三次python 单次匹配时若存在组的嵌套则采用深度优先搜索顺序排列 12345678910111213141516171819# 单一组string1 = &quot;111222333444&quot;print(re.findall(&quot;\\d(\\d)\\d&quot;, string1))# [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]# 多个组string2 = &quot;11011220223303344044&quot;print(re.findall(&quot;\\d(\\d)0(\\d)\\d&quot;, string2))# [(&#x27;1&#x27;, &#x27;1&#x27;), (&#x27;2&#x27;, &#x27;2&#x27;), (&#x27;3&#x27;, &#x27;3&#x27;), (&#x27;4&#x27;, &#x27;4&#x27;)]# 嵌套组string3 = &quot;11011220223303344044&quot;print(re.findall(&quot;\\d(\\d(\\d)\\d)\\d&quot;, string3))# [(&#x27;101&#x27;, &#x27;0&#x27;), (&#x27;202&#x27;, &#x27;0&#x27;), (&#x27;303&#x27;, &#x27;0&#x27;), (&#x27;404&#x27;, &#x27;0&#x27;)]# 嵌套混合组string4 = &quot;1181011228202233830334484044&quot;print(re.findall(&quot;\\d((\\d)8(\\d))0(\\d)\\d&quot;, string4))# [(&#x27;181&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;1&#x27;), (&#x27;282&#x27;, &#x27;2&#x27;, &#x27;2&#x27;, &#x27;2&#x27;), (&#x27;383&#x27;, &#x27;3&#x27;, &#x27;3&#x27;, &#x27;3&#x27;), (&#x27;484&#x27;, &#x27;4&#x27;, &#x27;4&#x27;, &#x27;4&#x27;)] （五）边界匹配符 ^ ：从字符串开始位置匹配 $ ：从字符串末尾位置匹配 ^1\\d&#123;6&#125;0350$ ：匹配尾号 “0350” 的手机号 （六）python匹配模式参数（flags） re.I：不区分大小写（同 re.IGNORECASE ） re.S：让 . 元字符匹配所有字符，包括换行符 \\n（同 re.DOTALL ） re.M：多行模式匹配（同 re.MULTILINE ） ，如 ^123 可匹配字符串 “121\\n123” re.DEBUG：显示编译时的debug信息 不同匹配模式参数之间用 “|” 连接 二、python正则表达式 python中引入正则模块： 1import re 1. re.findall 1re.findall(pattern, string, flags=0) 查找字符串，返回匹配列表 2. re.sub 1re.sub(pattern, repl/convert, string, count=0, flags=0) 字符串替换，返回替换后的字符串，其中 repl 为替换的字符串，也可以是 convert 变幻函数，count 为期望替换的次数 convert(value) 变幻函数内接收当前匹配对象 value，函数返回值为 re.sub 替换结果 1234567891011str_nums = &quot;3627a949bbc0455js0537499py54171go152c++7854&quot;# 把字母替换为&quot;|&quot;：print(re.sub(&#x27;[a-z+]+&#x27;, &#x27;|&#x27;, str_nums))# 3627|949|0455|0537499|54171|152|7854# 把所有小于5的数字替换为0，大于5的数字替换为1：def convert(value): return str(0 if int(value.group()) &lt; 5 else 1)print(re.sub(&#x27;\\d&#x27;, convert, str_nums))# 0101a101bbc0011js0101011py10010go010c++1110 3. re.match 1re.match(pattern, string, flags=0) 从首字母开始匹配，返回匹配结果对象，只会匹配一次，若没有匹配则返回 None 4. re.search 1re.search(pattern, string, flags=0) 搜索整个字符串，直到找到满足条件的结果，只会匹配一次，返回匹配结果对象 5. group分组 re.sub 内替换函数中接收的参数和 re.match、re.search 返回查找对象为 re.Match object 格式 re_obj.span(i) 返回第i个分组所在索引(tuple)，规则同序列切片 re_obj.group(i) 取第i个分组内字符串，各组排序为照先后顺序和深度优先搜索顺序，默认取第0位(全部)；若存在多个数字则返回匹配字符元组(tuple) 12345678910111213string = &quot;1181011228202233830334484044&quot;print(re.findall(&quot;\\d((\\d)8(\\d))0(\\d)\\d&quot;, string))# [(&#x27;181&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;1&#x27;), (&#x27;282&#x27;, &#x27;2&#x27;, &#x27;2&#x27;, &#x27;2&#x27;), (&#x27;383&#x27;, &#x27;3&#x27;, &#x27;3&#x27;, &#x27;3&#x27;), (&#x27;484&#x27;, &#x27;4&#x27;, &#x27;4&#x27;, &#x27;4&#x27;)]def convert(value): print(value.group(0, 1, 2), value.span(1)) return &quot;#&quot;print(re.sub(&#x27;\\d((\\d)8(\\d))0(\\d)\\d&#x27;, convert, string))# (&#x27;1181011&#x27;, &#x27;181&#x27;, &#x27;1&#x27;) (1, 4)# (&#x27;2282022&#x27;, &#x27;282&#x27;, &#x27;2&#x27;) (8, 11)# (&#x27;3383033&#x27;, &#x27;383&#x27;, &#x27;3&#x27;) (15, 18)# (&#x27;4484044&#x27;, &#x27;484&#x27;, &#x27;4&#x27;) (22, 25)# ####","categories":[{"name":"Python","slug":"Python","permalink":"http://wzr1998.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://wzr1998.github.io/tags/Python/"}]},{"title":"Python Functional Programming","slug":"Python-Functional-Programming","date":"2020-11-02T05:24:33.000Z","updated":"2020-11-26T05:56:46.624Z","comments":true,"path":"posts/c337333b/","link":"","permalink":"http://wzr1998.github.io/posts/c337333b/","excerpt":"","text":"python 函数式编程 函数式编程关心数据的映射，命令式编程关心解决问题的步骤 一、lambda表达式(匿名函数) python lambda 表达式语法为 lambda parameters: expression ，后接单行表达式，等同于ES6 中 a =&gt; 2a，默认返回表达式执行结果 可用变量指向lambda表达式创建的匿名函数，也可直接调用 在函数式编程中常用作算子 12345678fn_lambda = lambda x, y: x + yprint(fn_lambda(1, 2)) # 3print((lambda a: 2 * a)(3))# 6print((lambda a: print(2 * a, end=&quot;,&quot;))(3))# 6, None 二、map 函数 映射，同ES6 arr.map，语法：map(function, iterable, ...) 返回一个保存每一项计算结果的迭代器( &lt;class 'map'&gt; )，当有多个可迭代对象时以短的为主 12345num_list1 = [1, 2, 3, 4, 5]num_list2 = (6, 7, 8, 9)result_list = map(lambda i, j: i + j, num_list1, num_list2)print(list(result_list))# [7, 9, 11, 13] 三、reduce 函数 归约，需从 functools 模块中导入 reduce 函数 语法：reduce(function, iterable[, initializer]) 执行过程同 ES6 arr.reduce 12345from functools import reducereduce_result1 = reduce(lambda result, current: result + current*2, [1, 2, 3, 4])reduce_result2 = reduce(lambda result, current: result + current*2, [1, 2, 3, 4], 0)print(reduce_result1) # 19print(reduce_result2) # 20 四、filter 函数 用 iterable 中函数 function 返回真的那些元素，构建一个新的迭代器，同ES6 arr.filter 1234num_list = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]filter_result = filter(lambda i: 3 &lt;= i &lt;= 7, num_list) print(list(filter_result))[3, 5, 7, 4, 6] 五、List Comprehension 列表推导式：根据已有列表推导出新的列表 通过for循环，遍历出序列中元素进行for前表达式运算，for后可加if条件做选择性筛选，生成经表达式运算后的元素列表（括号内部分，可用于生成列表、集合、字典、实参列表） 1234567891011121314# 原始列表list_origin = [1, 2, 3, 4, 5, 6]# 列表推导式list_square = [i**2 for i in list_origin]print(list_square) # [1, 4, 9, 16, 25, 36]# 有选择性的筛选list_square_filter = [i**3 for i in list_origin if i % 2 == 0]print(list_square_filter) # [4, 16, 36]# 做函数实参列表max_list_item = max(i**2 for i in list_origin)print(max_list_item) # 36 列表推导式支持复杂嵌套循环，从左到右对应从外到内for循环，右侧(内部)可用左侧(外部)中循环变量 12345678matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9],]list_matrix_item = [item for row in matrix for item in row]print(list_matrix_item) # [1, 2, 3, 4, 5, 6, 7, 8, 9] 字典推导式 12345678910# 原始字典dict_age_origin = &#123;&quot;LiHua&quot;: 20, &quot;XiaoMing&quot;: 16, &quot;XiaoHong&quot;: 22, &quot;WZR&quot;: 18, &quot;RanBB&quot;: 14&#125;# 利用列表推导式通过字典生成键值列表list_minors = [name for name, age in dict_age_origin.items() if age &lt; 18]print(list_minors) # [&#x27;XiaoMing&#x27;, &#x27;RanBB&#x27;]# 通过条件筛选构成新字典dict_minors = &#123;name: age for name, age in dict_age_origin.items() if age &lt; 18&#125;print(dict_minors) # &#123;&#x27;XiaoMing&#x27;: 16, &#x27;RanBB&#x27;: 14&#125;","categories":[{"name":"Python","slug":"Python","permalink":"http://wzr1998.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://wzr1998.github.io/tags/Python/"}]},{"title":"Python OOA","slug":"Python-OOA","date":"2020-10-30T05:24:33.000Z","updated":"2020-11-26T05:32:21.723Z","comments":true,"path":"posts/e4b335f4/","link":"","permalink":"http://wzr1998.github.io/posts/e4b335f4/","excerpt":"","text":"一、类的定义 类名首字母大写，推荐采用驼峰式命名 创建实例对象时没有关键字 new 可通过 isinstance(obj, ClassName) 判断对象obj是不是ClassName类的实例对象返回bool(子类也属于父类的一种类型，考虑继承关系) 1234567class ClassName: &lt;statement-1&gt; . . . &lt;statement-N&gt;obj = ClassName() 二、__init__ 构造函数 实例化对象时自动调用__init__ 构造函数初始化(函数名固定)，不能返回除None外的任何值，不建议显示设定返回值，默认返回当前实例对象 三、类变量&amp;类方法 类变量：定义在类中的变量是类变量，通过 ClassName.attr 或 self.__class__.sttr 获取，在全局和实例方法中都可以获取 类方法：在函数前添加装饰器 @classmethod，类方法第一个形参接收 cls 参数指向当前类，在调用时不需要传入 self，调用时默认第一个实参对应方法第二个形参；python中允许通过实例对象调用类方法(类似JS原型链)，但并不推荐 实例对象 obj.__class__ 指向创建该实例对象的类 类也可以调用实例方法，但python不会自动传入self对象，需要手动传入(多此一举) 1234567891011class Count: _count = 0 #类变量 def __init__(self): self.__class__._count += 1 @classmethod def print_count(cls): #类方法 print(cls._count)count_obj1 = Count()count_obj2 = Count()count_obj3 = Count()Count.print_count() #3 四、实例变量&amp;实例方法 实例变量：实例变量挂载在构造函数或实例方法内 self 参数中，创建实例对象时默认调用构造函数初始化，通过 obj.attr 获取 实例方法：定义在类中无装饰器的方法，实例方法第一个形参接收 self 参数指向当前实例对象(等同于this)，在调用时不需要传入 self，调用时默认第一个实参对应方法第二个形参 可通过 obj.__dict__ 获取实例对象下所有实例变量和值组成的字典 变量查找顺序：当获取对象实例变量时，若不存在该实例变量则会访问类变量，若仍未找到则继续逐级访问父类(类似JS原型链) 12345678910class People: def __init__(self, name, age, say): self.name = name self.say = say self.age = age def hello(self): print(str(self.age) + &quot;岁的&quot; + self.name + &quot;说:&quot;, self.say)wzr = People(&quot;卓然&quot;, 18, &quot;早安！打工人！&quot;)wzr.hello() #18岁的卓然说: 早安！打工人！print(wzr.__dict__) #&#123;&#x27;name&#x27;: &#x27;卓然&#x27;, &#x27;say&#x27;: &#x27;早安！打工人！&#x27;, &#x27;age&#x27;: 18&#125; 五、静态方法 在函数前添加装饰器 @staticmethod，没有默认接收的其他参数，形参列表与实参相对应 类和实例对象都可调用静态方法 1234567class ClassStatic: @staticmethod def tool_max(param_list): return max(param_list)obj = ClassStatic()print(ClassStatic.tool_max([2, 3, 4])) #4print(obj.tool_max([4, 5, 6])) #6 六、私有变量&amp;私有方法 在变量或方法前加双下划线可以把其设置为私有，python内部会将其更改为 _ClassName__* 格式；可以通过改名后的变量名间接读取私有变量，但不推荐 在变量或方法前后添加分别双下划线则会转变为公开，此为python内部变量写法 若后续存在 obj.__param = * 不会报错，会为其新添加一个 __param 属性，不影响私有变量(私有变量之前已改名) 私有变量只能在类的内部访问，通过类内部的方法改变 123456789101112131415161718192021class ClassPrivate: def __init__(self, name): self.name = name self.__weight = 0 self.__eat_weight = 0 def eat(self): self.__eat_weight += 1 print(&quot;%s又吃了一大碗饭，现在已经%d斤了，不能再吃啦！&quot; % (self.name, self.__get_weight())) def set_weight(self, weight): self.__weight = weight print(&quot;天了噜！%s居然都%d斤了，真是不敢相信！&quot; % (self.name, weight)) def __get_weight(self): return self.__weight + self.__eat_weightwzr_pri = ClassPrivate(&quot;然宝宝&quot;)wzr_pri.set_weight(90)wzr_pri.eat()wzr_pri.eat()#天了噜！然宝宝居然都90斤了，真不敢相信！#然宝宝又吃了一大碗饭，现在已经91斤了，不能再吃啦！#然宝宝又吃了一大碗饭，现在已经92斤了，不能再吃啦！ 七、继承 （一）单一继承 子类可以继承父类的类变量、构造函数、实例方法，python中类的继承直接在定义时传入父类即可 子类可通过 ChildClass.__base__ 或 ChildClass.__bases__ 查看父类(类变量) 1. 子类调用父类构造函数 直接调用父类构造函数：SuperClass.__init__(self, [Arg...])，实参与形参对应，显式传入子类self变量 使用super关键字：super(SubClass, self).__init__(Arg...)，super传入子类和子类self变量，__init__ 构造函数内传入父类除self外其他参数 2. 子类获取父类数据 子类已经继承父类所有信息，可通过子类中self对象获取父类变量 子类与父类有同名变量时，可通过 super(SuperClass, self) 对象获取父类中类变量、调用类方法 1234567891011121314151617class Human: def __init__(self, name): self.name = name def get_name(self): print(self.name)class Student(Human): def __init__(self, name, school): #Human.__init__(self, name) super(Student, self).__init__(name) #需不需要传的问题 self.school = school def get_school(self): print(self.school)rbb = Student(&quot;然宝宝&quot;, &quot;CAU&quot;)rbb.get_name() #然宝宝rbb.get_school() #CAUprint(Student.__base__) #&lt;class &#x27;__main__.Human&#x27;&gt;print(isinstance(rbb, Student), isinstance(rbb, Human))#True True （二）多重继承","categories":[{"name":"Python","slug":"Python","permalink":"http://wzr1998.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://wzr1998.github.io/tags/Python/"}]},{"title":"Python Function","slug":"Python-Function","date":"2020-10-28T05:24:33.000Z","updated":"2020-11-26T05:31:19.767Z","comments":true,"path":"posts/9169d8a8/","link":"","permalink":"http://wzr1998.github.io/posts/9169d8a8/","excerpt":"","text":"Python 函数 一、函数定义 12def fn(a, b): return a+b 二、返回多个参数 函数返回值可以有多个参数，返回一个序列，通过序列解包逐一取值 123def max_min(list_arg): return max(list_arg), min(list_arg)max_num, min_num = max_min(range(1, 10, 3)) #7, 1 三、关键字参数 在函数调用时，传入实参时明确对应形参，可以任意指定实参顺序调用函数 1234def say(people, word): print(people + &quot; say: &quot; + word)say(word=&quot;王卓然&quot;, people=&quot;卓然牛牛牛&quot;)say(**&#123;&quot;people&quot;: &quot;卓然&quot;, &quot;word&quot;: &quot;卓然666&quot;&#125;) 四、默认参数 可在函数形参部分设定默认值，对应位置未传入实参时则使用默认参数 默认参数后不能存在其他必须参数，默认参数列表要在形参列表最后 默认参数可以和关键参数配合使用 123456789def user(name, age=18, sex=1, school=&quot;HLJU&quot;): print( &quot;name: &quot; + name, &quot;sex: &quot; + (&quot;男&quot; if sex else &quot;女&quot;), &quot;age: &quot; + str(age), &quot;school: &quot; + school )user(&quot;王卓然&quot;) # name: 王卓然 sex: 男 age: 18 school: HLJUuser(&quot;然宝宝&quot;, sex=0, age=14, school=&quot;CAU&quot;) # name: 然宝宝 sex: 女 age: 18 school: CAU 默认参数只会执行一次。若默认值尽量设置为不可变对象。若为可变对象，则函数多次执行时形参指向相同默认对象 1234567def f(a, L=[]): L.append(a) return L, id(L)print(f(1)) #([1], 4325750784)print(f(2)) #([1, 2], 4325750784)print(f(3)) #([1, 2, 3], 4325750784) 五、可变参数(转元组) 在函数形参中可以设置 *prarm_list 来接收函数调用时的剩余全部实参形成元组，同ES6中rest参数 序列内子序列可使用 *list 展开子序列，同ES6中展开运算符 123456def fn_rest(a, *Arg, b=233): print(a, b, Arg)fn_rest(1, 2, 3, 4, 5) #1 233 (2, 3, 4, 5)fn_rest(1, *(2, 3, 4, 5), b=666) #1 233 (2, 3, 4, 5)print([1, *[2, 3, *(4, 5)]]) #[1, 2, 3, 4, 5] 六、可变关键字参数(转字典) 当函数存在一个形式为 **prarm_dict 的最后一个形参时，会接收一个字典，其中包含除了与已有形参相对应的关键字参数以外的所有关键字参数。 这可以与可变参数 *prarm_list组合使用 注意：*name 必须出现在 **name 之前 123456def fn_dict(prarm, *prarm_tuple, **prarm_dict): print(prarm, prarm_tuple, end=&quot;：&quot;) for key, value in prarm_dict.items(): print(key + &quot;:&quot; + value, end=&quot;,&quot;)fn_dict(&quot;王卓然&quot;, &quot;敲&quot;, &quot;喜&quot;, &quot;欢&quot;, fruit=&quot;橘子&quot;, drinks=&quot;快乐水&quot;, activity=&quot;吃吃喝喝玩玩睡睡&quot;)#王卓然 (&#x27;敲&#x27;, &#x27;喜&#x27;, &#x27;欢&#x27;)：fruit:橘子,drinks:快乐水,activity:吃吃喝喝玩玩睡睡, 七、作用域&amp;作用域链 同ES5没有块级作用域，for、if、while等语句不能构成块级作用域，外部可以引用for循环内部变量 作用域链与其他主流编程语言相同 1234if 1: num = 1print(num)# 1，没有块级作用域 改变变量作用域范围 1. global 关键字 在函数内部定义全局变量，模块内可全局使用，其他模块可导入 12345678# 错误：global_num = 1def fn_global(i): global_num += i # 先声明变量num，在赋值时其自身为Nonefn_global(2)print(global_num)# UnboundLocalError: local variable &#x27;num&#x27; referenced before assignment 123456789# 正确：global_num = 1def fn_global(i): global num global_num += ifn_global(2)print(global_num)# 3 2. nonlocal 关键字 在函数内部定义非局部变量，将变量指向之前在最近的上级作用域中绑定的除全局变量外的变量 常用于在函数内改变上级作用域变量(闭包) 12345678910# 错误：def outer_fn(i): sum_num = i def inner_fn(j): sum_num += j print(sum_num) inner_fn(2)outer_fn(1)# UnboundLocalError: local variable &#x27;sum_num&#x27; referenced before assignment 1234567891011# 正确：def outer_fn(i): sum_num = i def inner_fn(j): nonlocal sum_num # 使inner_fn函数中sum_num变量指向上层outer_fn函数中sum_num sum_num += j print(sum_num) inner_fn(2)outer_fn(1)# 3 八、闭包 原理、含义、用法同JavaScript 例：利用闭包实现add函数，调用时每次在之前结果上叠加计算 123456789101112131415161718def add_create(total): def add(current): nonlocal total total += current return total return addadd = add_create(1)print(add(2), add(3), add(4), add(5)) # 3 6 10 15# 无限次链式调用def add_create(total): def add(current): nonlocal total total += current return &#123;&quot;data&quot;: total, &quot;add&quot;: add&#125; return addprint(add_create(1)(2)[&quot;add&quot;](3)[&quot;add&quot;](4)[&quot;add&quot;](5)[&quot;data&quot;]) #15 查看闭包中保存的变量 returnFn._code__.co_freevars[i]：查看闭包中第i个变量名 returnFn.__closure__[i].cell_contents：查看闭包中第i个变量的值 1234567891011121314151617# 闭包&amp;查看闭包中变量def hello_create(name): def say_hello(text): print(&quot;&#123;&#125;说：&#123;&#125;&quot;.format(name, text)) return say_hello wzr_say = hello_create(&quot;王卓然&quot;)wzr_say(&quot;今天也要加油鸭！&quot;) # 王卓然说：今天也要加油鸭！wzr_say(&quot;今晚敲冷哒！&quot;) # 王卓然说：今晚敲冷哒！rbb_say = hello_create(&quot;然宝宝&quot;)rbb_say(&quot;又是开心的一天！&quot;) # 然宝宝说：又是开心的一天！rbb_say(&quot;然宝宝要征服全世界！&quot;) # 然宝宝说：然宝宝要征服全世界！print(wzr_say.__code__.co_freevars[0]) # nameprint(wzr_say.__closure__[0].cell_contents) # 王卓然 九、装饰器 python装饰器本质是一个语法糖，在不改变原有函数结构前提下增加函数功能，装饰器函数返回原有函数和新增需求代码的封装函数，常用于AOP 1. 基本形式 1234567891011def decorator(func): def inner_fn(*Arg, **kwargs): return func(*Arg, **kwargs) # 传出被装饰函数的返回值 return inner_fn@decoratordef fn(): pass fn() 调用时，装饰器函数 decorator 内会自动传入被装饰函数，返回其内部封装后 inner_fn 函数，内部执行被装饰函数。 inner_fn 函数会接收被封装函数调用时传入的实参，通常采用 *Arg, **kwargs 格式形参接收实参列表 案例：计算调用阶乘函数运行时间 123456789101112131415161718import timedef decorator_fn(func): t1 = time.time() def inner_fn(*Arg, **kwargs): return func(*Arg, **kwargs) t2 = time.time() print(&quot;函数用时：&quot;, t2-t1) return inner_fn@decorator_fndef factorial_fn(n): # return reduce(lambda factorial, cur: factorial*cur, range(1, n+1), 1) return 1 if not n-1 else n * factorial_fn(n-1)print(factorial_fn(50))# 函数用时： 9.5367431640625e-07# 30414093201713378043612608166064768844377641568960512000000000000 2. 含参装饰器 含参装饰器传入参数时返回装饰器函数，相比普通装饰器函数多嵌套一层函数接收装饰器参数，常用于python框架 12345678910111213def decorator(param): def decorator_fn(func): def inner_fn(*args, **kwargs): return func(*args, **kwargs) return inner_fn return decorator_fn@decorator(param=1)def fn(): passfn()","categories":[{"name":"Python","slug":"Python","permalink":"http://wzr1998.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://wzr1998.github.io/tags/Python/"}]},{"title":"Python Control Flow Statements","slug":"Python-Control-Flow-Statements","date":"2020-10-27T05:24:33.000Z","updated":"2020-11-26T05:29:38.644Z","comments":true,"path":"posts/e231d803/","link":"","permalink":"http://wzr1998.github.io/posts/e231d803/","excerpt":"","text":"一、python书写规范 1.缩进(四个空格)可以决定代码块，以简化其他语言的&quot;{}&quot; 2.pass：占位，构建代码骨架 常量大写 函数冒号前没有空格 二、条件控制 1. if 判断 if - [elif] - else 123456789101112print(&quot;请输入成绩&quot;) score = int(input())if score &gt; 100: print(&quot;输入错误&quot;)elif 90 &lt;= score &lt;= 100: print(&quot;优秀&quot;)elif 80 &lt;= score &lt; 90: print(&quot;良好&quot;)elif 60 &lt;= score &lt; 80: print(&quot;及格&quot;)else: print(&quot;不及格&quot;) 2. 三元表达式 1234567# if 语句：if a &gt; b: c = aelse: c = b# 等价于三元表达式：c = a if a &gt; b else b 三、循环 1.while/while-else 常用于递归、有具体目标结束事件 123456count = 1while count &lt; 3: print(count) count += 1else: print(&quot;count=3&quot;) 2.for/for-else 主要用于遍历序列/集合/字典 12345678for_list = [[1,2,3], [4,5]]for item in for_list: for num in item: if num == 5: continue print(num)else: print(&quot;循环结束&quot;) 3.for-range() 123for i in range(0, 10, 2): #range(start, stop[, step]) print(i, end=&#x27;|&#x27;)# =&gt; 0|2|4|6|8| 可以考虑序列切片实现：list[start: end[: step]] 3.跳出循环 1.break：跳出整个循环，不会执行else 2.continue：跳出当前循环","categories":[{"name":"Python","slug":"Python","permalink":"http://wzr1998.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://wzr1998.github.io/tags/Python/"}]},{"title":"Python Packages & Modules","slug":"Python-Packages-Modules","date":"2020-10-27T05:24:33.000Z","updated":"2020-11-26T05:30:39.798Z","comments":true,"path":"posts/5e80d71d/","link":"","permalink":"http://wzr1998.github.io/posts/5e80d71d/","excerpt":"","text":"一、基础概念 python组织结构：包、模块、类(函数、变量) 命名空间：package1.package2.module，与物理位置相对应 python当导入其他模块时会自动执行被导入模块的全部代码，但当同一模块被其他模块多次导入时只会被执行一次 避免人为的循环导入 ​ 包和模块不会被重复导入 ​ 避免人为的循环导入 二、import 1. import 导入其他模块，可以通过 as 为其重命名 1import module [as name] 2. form…import 从指定模块中导入内部函数、变量，或导入其他模块 1from module import name1[, name2[, ... nameN]] [as name] 3. form…import * 从指定模块中导入其内部所有项目，被导入模块可以通过模块内置变量 __all__ 设定具体内容 123456789&#x27;&#x27;&#x27;main.py&#x27;&#x27;&#x27;from math import *print(add_fn(math_a, math_b))&#x27;&#x27;&#x27;math.py&#x27;&#x27;&#x27;__all__ = [&#x27;math_a&#x27;, &#x27;math_b&#x27;, &#x27;add_fn&#x27;]math_a, math_b = 1, 2def add_fn(x, y): return x + y 三、__init__.py 每一个包内必须包含 __init__.py 文件，当导入模块时 __init__.py 会被自动执行，常用来导入包内各模块所需的公共模块，进行初始化操作 四、模块内置变量 1.dir() 通过 dir() 函数查看模块内部全部变量，返回一个字符串列表，其中包括模块内置变量和自定义变量。模块内置变量如下： 1[&#x27;__annotations__&#x27;, &#x27;__builtins__&#x27;, &#x27;__cached__&#x27;, &#x27;__doc__&#x27;, &#x27;__file__&#x27;, &#x27;__loader__&#x27;, &#x27;__name__&#x27;, &#x27;__package__&#x27;, &#x27;__spec__&#x27;] dir(module) 可以查看指定模块内的变量 2. 普通模块 __name__ ：命名空间 __package__ ：模块所在包 __doc__ ：模块注释（&quot;&quot;&quot;text&quot;&quot;&quot; 中内容） __file__ ：模块完整物理路径 3. 入口文件 3.1 内置变量 __name__ ：固定输出 __main__ 可以通过if __name__ == &quot;__main__&quot;:判断模块执行时是否为入口文件 __package__ ：不属于任何包，返回None 3.2 把入口文件当作模块来调用 加入参数 -m ，注意执行文件格式为命名空间，不是物理路径 1python -m package.module 五、相对导入和绝对导入 123456789101112python├── package1 &#x2F;&#x2F;顶级包│ ├── __init__.py│ └── module1.py├── package2 &#x2F;&#x2F;顶级包│ ├── __init__.py│ ├── module2.py│ └── package2_1│ ├── __init__.py│ └── module2_1.py├── __init__.py└── app.py 12&quot;&quot;&quot; app.py &quot;&quot;&quot;import package1.module1, package2.package2_1.module2_1 12&quot;&quot;&quot; module2.py &quot;&quot;&quot;m2=&quot;module2&quot; 123&quot;&quot;&quot; module2_1.py &quot;&quot;&quot;m2_1=&quot;module2_1&quot; 1.相对导入 从顶级包开始，以点的方式连接，逐级往下到引用的模块的引入方式 各模块所对应的顶级包为与入口文件平级的文件夹 module1导入module2_1 1234&quot;&quot;&quot; module1.py &quot;&quot;&quot;import package2.package2_1.module2_1 as module2_1print(module2_1.m2_1) #module2_1 2.相对导入 从当前路径开始，按照相对路径导入， . 为当前路径；.. 为上级路径；... 为上上级路径，以此类推… 注意： 只能通过 form...import 形式导入 不能在入口文件中使用(python通过 __name__ 定位) 只能在顶级包内部导入，路径不能到顶级包以上 module2_1导入module2 1234&quot;&quot;&quot; module2_1.py &quot;&quot;&quot;from ..module2 import m2print(m2) #module2 ​","categories":[{"name":"Python","slug":"Python","permalink":"http://wzr1998.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://wzr1998.github.io/tags/Python/"}]},{"title":"Python variable, Operators and Expressions","slug":"Python-variable-Operators-and-Expressions","date":"2020-10-24T05:24:33.000Z","updated":"2020-11-26T05:30:21.177Z","comments":true,"path":"posts/18d55266/","link":"","permalink":"http://wzr1998.github.io/posts/18d55266/","excerpt":"","text":"一、变量 1.定义：直接声明，区分大小写，动态语言，弱引用类型，用&quot;=&quot;赋值 12num = 1list = [1,2,3,4,5] 2.命名规则 变量只能使用字母、数字、下划线，首字母不能是数字 不能使用系统保留关键字：and; if; import… 3.值类型与引用类型：与C、JavaScript相同 ​ 值类型(不可变)：int; str; tuple ​ 引用类型(可变)：list; set; dict 4.id()函数：显示变量内存地址 二、序列封包&amp;序列解包&amp;链式赋值 序列封包 把多个值赋给一个变量时，Python会自动的把多个值封装成元组 123def fn(a): return a, a*2, a*3, a*4nums = fn(2) #(2, 4, 6, 8) 序列解包 类似ES6的解构赋值，可使用 * 接受剩余部分(首尾或中间只能有一个) 1234567891011121314a, b, c, d = fn(2)print(a, b, c, d) #2 4 6 8x, y, *z = fn(2)print(x, y, z) #2 4 [6, 8]j, *q, k = fn(2)print(j, q, k) #2 [4, 6] 8*l, m, n = fn(2)print(l, m, n) #[2, 4] 6 8(aa, bb), [cc, dd, (ee, ff)] = (11, 22), [33, 44, (55, 66)]print(aa, bb, cc, dd, ee, ff) 链式赋值 12a=b=c=1print(a, b, c) #1, 1, 1 三、运算符 （一）运算符优先级 运算符说明 Python运算符 优先级 结合性 小括号 ( ) 19 无 索引运算符 x[i] 或 x[i1: i2 [:i3]] 18 左 属性访问 x.attribute 17 左 乘方 ** 16 左 按位取反 ~ 15 右 符号运算符 +（正号）、-（负号） 14 右 乘除 *、/、//、% 13 左 加减 +、- 12 左 位移 &gt;&gt;、&lt;&lt; 11 左 按位与 &amp; 10 右 按位异或 ^ 9 左 按位或 | 8 左 比较运算符 ==、!=、&gt;、&gt;=、&lt;、&lt;= 7 左 is 运算符 is、not is 6 左 in 运算符 in、not in 5 左 逻辑非 not 4 右 逻辑与 and 3 左 逻辑或 or 2 左 逗号运算符 exp1, exp2 1 左 （二）算数运算符 1234567加：+减：-乘：*除：/整除：//取余：%乘方：** （三）赋值运算符 先运算，再赋值，没有自增自减 12345678=+=-=*=/=//=%=**= （四）比较(关系)运算符 返回bool 数字、字符串、元组、列表等都可以比较(按位比较) 123456==!=&gt;&lt;&gt;=&lt;= 1234a=1a+=a&gt;=1print(a) #2#赋值从右到左运算：a+=a&gt;=1 =&gt; a+=True =&gt; a=2 （五）逻辑运算符 操作bool，返回bool；操作非bool元素时先转换bool，返回原则与JS相同 假值：0、&quot;&quot;、[]、()、{} 优先级：not &gt; and &gt; or 1234and # &amp;&amp; 与or # || 或not # ! 非 （六）成员预算符 判断一个元素是否在一组元素(str、list、tuple、set)中，返回bool；对于dict，判断其key 123innot in （七）身份运算符 比较两个变量内存地址是否相等，比较id()，返回bool， 123isnot is 注意：两个变量存储相同数字/字符串，is判断为True IDLE中数字不超过256为True，否则为False（与python缓存机制有关） （八）位运算符 把数字当作二进制数进行运算 1234567&amp;：按位与|：按位或^：按位异或~：按位取反&lt;&lt;：左移&gt;&gt;：右移 三、表达式 表达式：表达式(Expression)是运算符(operator)和操作数(operand)所构成的序列 相同优先级默认左结合，赋值运算右结合","categories":[{"name":"Python","slug":"Python","permalink":"http://wzr1998.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://wzr1998.github.io/tags/Python/"}]},{"title":"Python Data Type","slug":"Python-Data-Type","date":"2020-10-20T05:24:33.000Z","updated":"2020-12-01T12:21:58.050Z","comments":true,"path":"posts/6c1fe4ee/","link":"","permalink":"http://wzr1998.github.io/posts/6c1fe4ee/","excerpt":"","text":"Python数据类型 一、Number 数字 （一）类型 正数：int；浮点数：float；判断数据类型：type(obj) （二）计算 1+0.1 =&gt; 1.1 =&gt; float 1+1.0 =&gt; 2.0 =&gt; float 1*1.0 =&gt; 1.0 =&gt; float type(1/2) =&gt; 0.5 =&gt; float type(1//2) =&gt; 0 =&gt; int =&gt; 整除(保留正数部分) （三）进制 表示方式： 二进制(0b)：0b11 =&gt; 3 八进制(0o)：0o11 =&gt; 9 十六进制(0x)：0x1f =&gt; 31 进制转换 转换函数内可以放不同进制类型数字 转化成二进制：bin() 转换成十进制：int() 转换成八进制：oct() 转换成十六进制：hex() 二、 序列（不是python数据类型） 序列包括：str; list; tuple 序号：[]取值，每一个元素都有一个序号 切片：list[i:j:d] 取值，从第 i 位取到第 j-1 位，步长为d(可选) 可以进行“+/*”操作 通过in/not in判断元素是否在序列中 查看序列长度：len() 查看最大/最小元素：max() / min() 三、Str 字符串 （一）表示方式 单引号、双引号 引号成对出现，引号中间可以有不同类型引号 12&quot;let&#x27;s go&quot;&#x27;let\\&#x27;s go&#x27; 单引号/双引号换行： 123&quot;hello\\world&quot;#输出：helloworld 三引号 三引号内不字符串可以换行(添加\\n)，三个单引号或三个双引号都可以 1234567891011&#x27;&#x27;&#x27;pythonpythonpython&#x27;&#x27;&#x27;&quot;&quot;&quot;pythonpythonpython&quot;&quot;&quot; （二）转义字符 作用：表示无法“看见“的字符、与语言本身有冲突的字符 \\n：换行 \\'：单引号 \\t：横向制表符 \\n：换行 \\t：回车 （三）输出原始字符串 在字符串引号前加’r’ 123print(r&quot;c:\\n1\\n2\\n3&quot;)# c:\\n1\\n2\\n3# 原封不动输出字符串内容，不然\\n会换行 （四）字符串运算 12345671.加法：&quot;hello&quot;+&quot;world&quot; =&gt; &quot;helloworld&quot;2.乘法：&quot;hello&quot;*3 =&gt; &quot;hellohellohello&quot;3.下标： (1)正数：&quot;hello&quot;[2] =&gt; e (2)负数：&quot;hello&quot;[-4] =&gt; e #步长，从字符串最后往回数 (3)范围：&quot;hello&quot;[2:4] =&gt; ll #从起始数字开始，读取到终止数字前一位4.查看ASCLL码：ord() 四、list 列表 （一）定义/访问 定义：[1, 2, 3, 4, 5] 列表内对数据类型无要求：[1, &quot;str&quot;, True, [1, 2, 3]] 访问列表内元素：list[1]、list[-2] 切片操作同样返回一个列表：list[1:3] （二）列表操作 加法：[1,2]+[3,4] =&gt; [1,2,3,4] 乘法：[1]*3 =&gt; [1,1,1] 五、tuple 元组 与列表类似，用圆括号定义，如： 1(1, &quot;str&quot;, True, (1,2,3) ) 若圆括号内只有一个元素，则不表示元组，python解析为优先级运算： 1type((1)) &#x3D;&gt; &lt;class &#39;int&#39;&gt; 定义只有一个元素的元组：在单一元素后加括号 1type((1,)) =&gt; &lt;class &#x27;tuple&#x27;&gt; 定义一个空的元组：一个空的圆括号 12type(()) =&gt; &lt;class &#x27;tuple&#x27;&gt; 六、set 集合 （一）定义 花括号：&#123;1,2,3,4,5&#125; 定义空集合：set() （二）特点 无序，不能[]取值，不能进行切片操作 不重复：&#123;1,1,2,2,3,3,4&#125; ==转换==&gt; &#123;1,2,3&#125; （三）操作 判断长度：len() 判断知否存在：in / not in 求差集：&#123;1,2,3,4,5&#125; - &#123;2,3&#125; ==&gt; &#123;1,4,5&#125; 求交集：&#123;1,2,3,4,5&#125; &amp; &#123;2,3&#125; ==&gt; &#123;2,3&#125; 求并集：&#123;1,2,3,4,5&#125; | &#123;5,6&#125; ==&gt; &#123;1,2,3,4,5,6&#125; 七、dict 字典 花括号定义：&#123;key1 : value1, key2 : value2...&#125;，同JavaScript中Json对象 定义空的字典：&#123;&#125; 注意： 不能有重复的key key必须为不可变的类型：int; str value可为任意类型：str; int; float; list; set; list… 取值：dict[&quot;key&quot;] 八、枚举 python中的创建枚举类型需引入标准库中 enum 模块 继承 Enum 类可创建一个枚举对象，继承 IngEnum 模块则枚举的值只能为数字 特点：常量、不可重复、不可更改 枚举的三个特征 枚举类型：Enum.VALUE，类型为 &lt;enum 'Color'&gt; 枚举的名字：Enum.VALUE.value，不可重复 枚举的值：Enum.VALUE.name，若枚举中存在两个值相同的类型，则第二个会被当作第一个的别名 12345678from enum import Enumclass Color(Enum): RED = 1 GREEN = 2 BLUE = 3print(Color.RED, Color.RED.name, Color.RED.value)# Color.RED 1 RED 自动设定枚举的值： 12345678from enum import Enum, autoclass Color(Enum): RED = auto() GREEN = auto() BLUE = auto()print(Color.BLUE, Color.BLUE.name, Color.BLUE.value)# Color.BLUE BLUE 3 遍历 可通过 Enum.__members__ 遍历重名枚举元素 1234567891011121314151617from enum import Enumclass Color(Enum): RED = 1 GREEN = 1 BLUE = 2for item in Color: print(item, end=&quot; | &quot;)# Color.RED | Color.BLUE |for item in Color.__members__: print(item, type(item), end=&quot; | &quot;)# RED &lt;class &#x27;str&#x27;&gt; | GREEN &lt;class &#x27;str&#x27;&gt; | BLUE &lt;class &#x27;str&#x27;&gt; | print(type(Color.__members__))# &lt;class &#x27;mappingproxy&#x27;&gt; 通过值寻找枚举元素 12345678from enum import Enumclass Color(Enum): RED = 1 GREEN = 2 BLUE = 3print(Color(2))# Color.GREEN unique装饰器 引入unique装饰器则枚举的值不能重复 12345678from enum import Enum, unique@uniqueclass Color(Enum): RED = 1 GREEN = 1 BLUE = 2# 报错：ValueError: duplicate values found in &lt;enum &#x27;Color1&#x27;&gt;: GREEN -&gt; RED","categories":[{"name":"Python","slug":"Python","permalink":"http://wzr1998.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://wzr1998.github.io/tags/Python/"}]},{"title":"2019 黑大信管夏令营：JavaScript 事件循环、this 指向问题","slug":"19信管夏令营：JavaScript-事件循环、this-指向问题","date":"2019-07-20T05:14:54.000Z","updated":"2020-11-26T05:19:15.147Z","comments":true,"path":"posts/f3d4e09e/","link":"","permalink":"http://wzr1998.github.io/posts/f3d4e09e/","excerpt":"","text":"第一题： 1234567891011121314151617function fn1()&#123; console.log(1); setTimeout(function()&#123; console.log(2); &#125;,0); console.log(3)&#125;(function IIFE(fn2)&#123; console.log(4); setTimeout(function()&#123; console.log(5); fn2(); console.log(6); &#125;,0); console.log(7);&#125;)(fn1)//输出：______、______、______、______、______、______、______ 第二题： 1234567891011121314function fn()&#123; var n = 1; function add()&#123; n++; console.log(n); &#125; return &#123; n : n, add : add &#125;&#125;var obj1 = fn();var obj2 = fn();obj1.add(); //输出__________________obj1.add(); //输出__________________console.log(obj1.n) //输出__________________obj2.add(); //输出__________________ 第三题： 123456789foo(); //输出__________________function foo()&#123; console.log(1); &#125;foo(); //输出__________________foo=function()&#123; console.log(3); &#125;foo(); //输出__________________function foo()&#123; console.log(2); &#125;foo(); //输出__________________console.log(typeof foo) //输出__________________console.log(typeof typeof foo)//输出__________________ 第四题： 123456(function IIFE()&#123; console.log(this); //输出__________________ setTimeout(function()&#123; console.log(this); //输出__________________ &#125;,1000);&#125;)() 第五题： 123456789101112(function IIFE() &#123; setTimeout(function() &#123; console.log(1) &#125;, 0); new Promise(function(resolve)&#123; console.log(2); resolve() console.log(3); &#125;).then(function() &#123; console.log(4); &#125;); console.log(5);&#125;)()//输出顺序：________、________、________、________、________ 第六题： 123456789var a = 1;var obj = &#123; a : 2, fn : function()&#123; var that = this; return function()&#123; return that.a; &#125;; &#125;&#125;;console.log( obj.fn()() ); //输出__________________ 第七题： 123456789101112var a = 1function fn1()&#123; console.log(this.a) &#125;var obj2 = &#123; a : 3, fn : fn1 &#125;var obj1 = &#123; a : 2, obj2: obj2 &#125;obj1.obj2.fn(); //输出__________________var fn2 = obj1.obj2.fnfn2(); //输出__________________fn2.call(obj1); //输出__________________var fn3 = fn2.bind(obj2)fn3(); //输出__________________( obj2.fn = obj2.fn )() //输出__________________( obj1.obj2.fn , obj2.fn )() //输出__________________ 第八题： 123456789101112var obj = &#123; x : 0, fn : function(x) &#123; this.x = x; console.log(this.x); function fn1(x) &#123; this.x = x; &#125;; fn1(++x); &#125; &#125;; obj.fn(1); //输出__________________console.log(obj.x); //输出__________________console.log(x); //输出__________________ 第九题： 123456789101112131415function Foo() &#123; getName = function () &#123; alert (1); &#125;; return this;&#125;Foo.getName = function () &#123; alert (2); &#125;;Foo.prototype.getName = function () &#123; alert (3); &#125;;var getName = function () &#123; alert (4); &#125;;function getName() &#123; alert (5); &#125;Foo.getName(); //输出__________________getName(); //输出__________________Foo().getName(); //输出__________________getName(); //输出__________________new Foo.getName(); //输出__________________new Foo().getName(); //输出__________________new new Foo().getName(); //输出__________________","categories":[{"name":"面试题","slug":"面试题","permalink":"http://wzr1998.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://wzr1998.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"2019 黑大信管夏令营：JavaScript 作用域、变量提升、闭包相关考题","slug":"19信管夏令营：JavaScript-作用域、变量提升、闭包相关考题","date":"2019-07-18T05:14:54.000Z","updated":"2020-11-26T05:18:56.400Z","comments":true,"path":"posts/c7172ffd/","link":"","permalink":"http://wzr1998.github.io/posts/c7172ffd/","excerpt":"","text":"第一题： 123456function foo(str, a)&#123; eval( str ); console.log(a, b) //输出______________________&#125;var b = 2;foo( &quot;var b = 3;&quot;, 1 ); // 1, 3 第二题： 1234567var obj = &#123; a : 1, b : 2 &#125;with(obj)&#123; a = 111; b = 222; c = 333&#125;console.log(obj) //输出__________________ 第三题： 1234567foo(); //输出__________________function foo()&#123; console.log(1); &#125;foo(); //输出__________________foo=function()&#123; console.log(3); &#125;foo(); //输出__________________function foo()&#123; console.log(2); &#125;foo(); //输出__________________ 第四题： 1234567var foo = 1;(function()&#123; console.log(foo); //输出__________________ var foo = 2; console.log(foo); //输出__________________&#125;)()console.log(foo); //输出__________________ 第五题： 123456oo(); //输出__________________var foo = 0;function foo()&#123; console.log(1); &#125;foo(); //输出__________________foo = function()&#123; console.log(2); &#125;;foo(); //输出__________________ 第六题： 1234567var foo = 1;(function(foo)&#123; console.log(foo); //输出__________________ var foo = 2; console.log(foo); //输出__________________&#125;)(foo)console.log(foo); //输出__________________ 第七题： 12345678(function test()&#123; var a=b=5; console.log(a); //输出__________________ console.log(b); //输出__________________&#125;)();console.log(a); //输出__________________console.log(b); //输出__________________console.log(b === window.b) //输出__________________ 第八题： 1console.log(typeof null) //输出__________________ 第九题： 1234567or (var i = 0; i &lt; 4; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 100);&#125;依次输出：_______、_______、_______、_______、_______ 第十题： 123456789101112131415161718function fn()&#123; var n = 1; function add()&#123; n++; console.log(n); &#125; return &#123; n : n, add : add &#125;&#125;var obj1 = fn();var obj2 = fn();obj1.add(); //输出__________________obj1.add(); //输出__________________console.log(obj1.n) //输出__________________obj2.add(); //输出__________________ 第十一题： 1234567var fnList = [ ];for (var i = 0; i &lt; 3; i++) &#123; fnList[i] = function () &#123; console.log(i); &#125;;&#125;fnList[1](); //输出__________________ 第十二题： 1234567891011function fun(a, b) &#123; console.log(a, b) return &#123; fun: function(c) &#123; return fun(c, a); &#125; &#125;;&#125;var a = fun(0).fun(1) //输出____________、____________a.fun(2) //输出__________________a.fun(3) //输出__________________","categories":[{"name":"面试题","slug":"面试题","permalink":"http://wzr1998.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://wzr1998.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"黑龙江大学信管创业基地 2018级第一次次考核面试题","slug":"黑大信管创业基地-18级第一次考核面试题","date":"2019-06-01T05:14:54.000Z","updated":"2020-11-26T05:19:54.751Z","comments":true,"path":"posts/cb1b645b/","link":"","permalink":"http://wzr1998.github.io/posts/cb1b645b/","excerpt":"","text":"CSS 选择符有哪些? id 选择器( # myid) 类选择器(.myclassname) 标签选择器(div, h1, p) 相邻选择器(h1 + p) 子选择器(ul &lt; li) 后代选择器(li a) 通配符选择器( * ) 属性选择器(a[rel = “external”]) 伪类选择器(a: hover, li: nth - child) 有哪些选择符，优先级的计算公式是什么?行内样式和!important 哪个优先级高? !important &gt; #ID &gt; .class &gt; 标签选择符 !important 优先级高 哪些属性可以继承? 可继承: font-size font-family color, UL LI DL DD DT; 不可继承 :border padding margin width height ; 优先级就近原则，样式定义最近者为准; 载入样式以最后载入的定位为准; CSS3 新增伪类有那些? p:first-of-type p:last-of-type p:only-of-type p:only-child p:nth-child(2) :enabled、:disabled 控制表单控件的禁用状态。 :checked，单选框或复选框被选中。 简述一下 src 与 href 的区别。 src 用于替换当前元素，href 用于在当前文档和引用资源之间确立联系。 src 是 source 的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置;在请求src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片 和 frame 等元素。 href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素(锚点) 或当前文档(链接)之间的链接，如果我们在文档中添加 rgba()和 opacity 的透明效果有什么不同? rgba()和opacity都能实现透明效果， opacity作用于元素，以及元素内的所有内容的透明度， 而 rgba()只作用于元素的颜色或其背景色。(设置 rgba 透明的元素的子元素不会继承透明效果!) CSS长度单位、px 和 em 的区别。 px 和 em 都是长度单位，区别是，px 的值是固定的，指定是多少就是多少，计算比较容易。 em 得值不是固定的，并且 em 会继承父级元素的字体大小。 浏览器的默认字体高都是 16px。所以未经调整的浏览器都符合: 1em=16px。那么 12px=0.75em, 10px=0.625em。 display:none 与 visibility:hidden 的区别是什么? display : 隐藏对应的元素但不挤占该元素原来的空间。visibility: 隐藏对应的元素并且挤占该元素原来的空间。即是，使用 CSS display:none 属性后，HTML 元素(对象)的宽度、高度等各种属性值都将 “丢失”;而使用 visibility:hidden 属性后，HTML 元素(对象)仅仅是在视觉上看不见(完 全透明)，而它所占据的空间位置仍然存在。 html 语义化是什么? 当页面样式加载失败的时候能够让页面呈现出清晰的结构 有利于 seo 优化，利于被搜索引擎收录(更便于搜索引擎的爬虫程序来识别) 便于项目的开发及维护，使 html 代码更具有可读性，便于其他设备解析。 清除浮动的方式： 父级div定义height 最后一个浮动元素后加空div标签 并添加样式clear:both。 包含浮动元素的父标签添加样式overflow为hidden或auto。 父级div定义zoom position 的属性值及其意义、相对于谁定位、有何特点 relative：生成相对定位的元素，相对于其正常位置进行定位。 absolute：生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。 fixed (老 IE 不支持) 生成绝对定位的元素，相对于浏览器窗口进行定位。 inherit 规定从父元素继承 position 属性的值。 static 默认值。没有定位，元素出现在正常的流中 *(忽略 top, bottom, left, right z-index 声明)。 元素竖向的百分比设定是相对于容器的高度吗？ 当按百分比设定一个元素的宽度时，它是相对于父容器的宽度计算的，但是，对于一些表示竖向距离的属性，例如 padding-top , padding-bottom , margin-top , margin-bottom 等，当按百分比设定它们时，依据的也是父容器的宽度，而不是高度 未知宽高元素如何水平垂直居中 JS获取DOM元素的方法 javascript 的 typeof 返回哪些数据类型，typeof null 返回？ object number function boolean underfind string 例举 3 种强制类型转换和 2 种隐式类型转换? 强制(parseInt,parseFloat,Number()) 隐式(==) 1==”1”//true null==undefined//true DOM元素绑定事件的方法 call 、 apply 和 bind的用法和区别 如何阻止事件冒泡和默认事件 e. stopPropagation();//标准浏览器 隐式(==) 1==”1”//true null==undefined//true event.canceBubble=true;//ie9 之前 阻止默认事件:return false e.preventDefault(); ”==”和“===”的不同，null==undefined返回？ 前者会自动转换类型，后者不会 看下列代码输出为何?解释原因 1234var a;alert(typeof a); // “undefined” //alert(b); // 报错b=10;alert(typeof b);//”number” 看代码给答案 12345var a = new Object(); a.value = 1;b = a;b.value = 2; alert(a.value); // 2 看下列代码，将会输出什么?(变量声明提升) 1234567var foo = 1;function fn()&#123; console.log(foo); var foo = 2; console.log(foo);&#125;fn() 函数声明和函数表达式的区别，如何判断？ 字符串反转，如将 ‘12345678’ 变成 ‘87654321’ var str = ‘12345678’; str = str.split(’’).reverse().join(’’); 输出结果? 12345678function fn(obj)&#123; obj.num= 1; obj = new Object(); obj.num = 2;&#125;;var obj = new Object();fn(obj);alert(obj.name); //1 内部 加减运算 alert(‘5’+3); //53 string alert(‘5’+‘3’); //53 string alert(‘5’-3); //2 number alert(‘5’-‘3’); //2 number Javascript 中 callee 和 caller 的作用? fn.caller: 是返回一个对函数的引用，该函数调用了当前函数; arguments.callee: 是返回正在被执行的 function 函数，也就是所指定的 function 对象的正文。 下列 JavaScript 代码执行后，依次 alert 的结果是 12345678(function test()&#123; var a=b=5;&#125;)();alert(a);alert(b);alert(typeof a);alert(typeof b);//报错 5 undefined number","categories":[{"name":"面试题","slug":"面试题","permalink":"http://wzr1998.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://wzr1998.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"Vue 源码学习之:虚拟 DOM","slug":"Vue源码学习之-虚拟DOM","date":"2018-11-14T04:29:15.000Z","updated":"2020-11-26T05:11:13.070Z","comments":true,"path":"posts/838157aa/","link":"","permalink":"http://wzr1998.github.io/posts/838157aa/","excerpt":"","text":"一、 virtual Node 路径：src/core/vdom/vnode.js 类型：元素、组件、函数式组件、文本、注释、克隆节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768export default class VNode &#123; tag: string | void; //节点标签 data: VNodeData | void; //节点数据，文本/注释没有 children: ?Array&lt;VNode&gt;;//节点子元素 text: string | void; elm: Node | void; ns: string | void; context: Component | void; // rendered in this component&#x27;s scope key: string | number | void; componentOptions: VNodeComponentOptions | void; componentInstance: Component | void; // component instance parent: VNode | void; // component placeholder node // strictly internal raw: boolean; // contains raw HTML? (server only) isStatic: boolean; // hoisted static node isRootInsert: boolean; // necessary for enter transition check isComment: boolean; // empty comment placeholder? isCloned: boolean; // is a cloned node? isOnce: boolean; // is a v-once node? asyncFactory: Function | void; // async component factory function asyncMeta: Object | void; isAsyncPlaceholder: boolean; ssrContext: Object | void; fnContext: Component | void; // real context vm for functional nodes fnOptions: ?ComponentOptions; // for SSR caching devtoolsMeta: ?Object; // used to store functional render context for devtools fnScopeId: ?string; // functional scope id support constructor ( tag?: string, data?: VNodeData, children?: ?Array&lt;VNode&gt;, text?: string, elm?: Node, context?: Component, componentOptions?: VNodeComponentOptions, asyncFactory?: Function ) &#123; this.tag = tag this.data = data this.children = children this.text = text this.elm = elm this.ns = undefined this.context = context this.fnContext = undefined this.fnOptions = undefined this.fnScopeId = undefined this.key = data &amp;&amp; data.key this.componentOptions = componentOptions this.componentInstance = undefined this.parent = undefined this.raw = false this.isStatic = false this.isRootInsert = true this.isComment = false this.isCloned = false this.isOnce = false this.asyncFactory = asyncFactory this.asyncMeta = undefined this.isAsyncPlaceholder = false &#125; get child (): Component | void &#123; return this.componentInstance &#125;&#125; 二、虚拟DOM整体流程 整体流程：$mount → mountComponent → vm._update(vm._render(), hydrating) → __patch__ 1. muontComponent：src/core/instance/lifecycle.js vdom树首页生成、渲染发生在 mountComponent 函数中 更新函数内部调用渲染函数的结果，渲染函数返回虚拟DOM： 123updateComponent = () =&gt; &#123; vm._update(vm._render(), hydrating)&#125; 构造一个Watcher，把刚才的到的 updateComponent更新函数传入 1234567new Watcher(vm, updateComponent, noop, &#123; before () &#123; if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, &#x27;beforeUpdate&#x27;) &#125; &#125;&#125;, true /* isRenderWatcher */) 完成后派发 mounted 钩子 12345if (vm.$vnode == null) &#123; vm._isMounted = true callHook(vm, &#x27;mounted&#x27;)&#125;return vm 2. _render：src/core/instance/render.js 作用：生成虚拟dom 获取render函数：从选项中获取render函数，或编译器生成的render函数 1const &#123; render, _parentVnode &#125; = vm.$options 若当前vm对象存在父元素，则处理插槽 1234567if (_parentVnode) &#123; vm.$scopedSlots = normalizeScopedSlots( _parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots )&#125; 执行render函数：代理vm对象后作为执行上下文，形参传入 createElement 函数，返回虚拟DOM 1vnode = render.call(vm._renderProxy, vm.$createElement) 返回vnode 1return vnode 3. _update：src/core/instance/lifecycle.js 接收虚拟DOM，执行 __patch__ 函数打补丁，接收新旧两个DOM元素比较区别，进行DOM操作 如果是首次渲染，__patch__ 传入DOM元素和接收的 VNode 做比较 不是首次渲染，__patch__ 传入旧的 VNode 对象和新接收的 VNode 做比较 123456789Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123; const vm: Component = this if (!prevVnode) &#123;//initial render vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) &#125; else &#123; // updates vm.$el = vm.__patch__(prevVnode, vnode) &#125;&#125; 4. __patch__ 函数 判断当前是否是浏览器环境，如果是则赋值为 patch 函数：src/platforms/web/runtime/index.js 12Vue.prototype.__patch__ = inBrowser ? patch : noop patch 函数，使用 createPatchFunction 函数，对核心patch函数进行扩展，把虚拟DOM操作转化为真是DOM操作的具体实现 路径：src/platforms/web/runtime/patch.js 12345678import * as nodeOps from &#x27;web/runtime/node-ops&#x27;import &#123; createPatchFunction &#125; from &#x27;core/vdom/patch&#x27;import baseModules from &#x27;core/vdom/modules/index&#x27;import platformModules from &#x27;web/runtime/modules/index&#x27;//在应用了所有内置模块之后，应该最后应用指令模块。const modules = platformModules.concat(baseModules)export const patch: Function = createPatchFunction(&#123; nodeOps, modules &#125;) nodeOps(node operations)：封装原生DOM操作。 路径：src/platforms/web/runtime/node-ops.js modules：操作标签属性、样式、事件等 路径：src/platforms/web/runtime/modules文件夹下 createPatchFunction：根据不同平台配置信息返回对应patch函数（工厂函数） 路径：src/core/vdom/patch.js 5. createPatchFunction 工厂函数 作用：根据不同平台配置信息返回对应patch函数 路径：src/core/vdom/patch.js patching算法： 利用diff算法将新老VNode节点进行比对，然后根据比较结果进行最小量DOM操作，而不是将整个视图根据新的VNode重绘。 diff算法: 通过同层的树节点进行比较而非对树进行逐层搜索遍历的方式，时间复杂度是O(n)，同层级只做增删改三件事。 new VNode不存在就删; old VNode不存在就增; 都存在就比较类型，类型不同直接替换、类型相同执行更新(比较各自属性和子元素)，执行 patchVnode 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//700行开始，createPatchFunction函数的返回值，一个patch函数return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) &#123; /*vnode不存在则删*/ if (isUndef(vnode)) &#123; if (isDef(oldVnode)) invokeDestroyHook(oldVnode) return &#125; let isInitialPatch = false const insertedVnodeQueue = [] if (isUndef(oldVnode)) &#123; /*oldVnode不存在则创建新节点*/ isInitialPatch = true createElm(vnode, insertedVnodeQueue, parentElm, refElm) &#125; else &#123; /*标记旧的VNode是否有nodeType，如果是它就是一个DOM元素*/ const isRealElement = isDef(oldVnode.nodeType) if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123; /*是同一个节点的时候做更新*/ patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) //重点 &#125; else &#123; /*带编译器版本才会出现的情况:传了dom元素进来*/ if (isRealElement) &#123; // 挂载一个真实元素，创建一个空的VNode节点替换它 oldVnode = emptyNodeAt(oldVnode) &#125; /*取代现有元素*/ const oldElm = oldVnode.elm const parentElm = nodeOps.parentNode(oldElm) createElm( vnode, insertedVnodeQueue, oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm) ) if (isDef(parentElm)) &#123; /*移除老节点*/ removeVnodes(parentElm, [oldVnode], 0, 0) &#125; else if (isDef(oldVnode.tag)) &#123; /*调用destroy钩子*/ invokeDestroyHook(oldVnode) &#125; &#125; &#125; /*调用insert钩子*/ invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch) return vnode.elm&#125; patchVnode函数 两个VNode相同执行更新操作，包括三种操作:属性更新、文本更新、子节点更新，规则如下: 如果新旧VNode都是静态的，同时它们的key相同(代表同一节点)，并且新的VNode是clone或者是标记了v-once，那么只需要替换elm以及componentInstance即可。 新老节点均有children子节点，则对子节点进行diff操作，调用updateChildren，这个updateChildren也是diff的核心。 如果老节点没有子节点而新节点存在子节点，先清空老节点DOM的文本内容，然后为当前DOM节点加入子节 点。 当新节点没有子节点而老节点有子节点的时候，则移除该DOM节点的所有子节点。 当新老节点都无子节点的时候，只是文本的替换。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/*patch VNode节点*/function patchVnode (oldVnode, vnode,insertedVnodeQueue, ownerArray,index,removeOnly)&#123; /*两个VNode节点相同则直接返回*/ if (oldVnode === vnode) &#123; return &#125; if (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) &#123; // clone reused vnode vnode = ownerArray[index] = cloneVNode(vnode) &#125; const elm = vnode.elm = oldVnode.elm /*如果新旧VNode都是静态的，同时它们的key相同(代表同一节点)， 并且新的VNode是clone或者是标记了once(标记v-once属性，只渲染一次)， 那么只需要替换elm以及componentInstance即可。*/ if (isTrue(vnode.isStatic) &amp;&amp; isTrue(oldVnode.isStatic) &amp;&amp; vnode.key === oldVnode.key &amp;&amp; (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) &#123; vnode.elm = oldVnode.elm vnode.componentInstance = oldVnode.componentInstance return &#125; /*如果存在data.hook.prepatch则要先执行*/ let i const data = vnode.data if (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) &#123; i(oldVnode, vnode) &#125; const oldCh = oldVnode.children const ch = vnode.children /*执行属性、事件、样式等等更新操作*/ if (isDef(data) &amp;&amp; isPatchable(vnode)) &#123; for (i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode) if (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode) &#125; /*开始判断children的各种情况*/ /*如果这个VNode节点没有text文本时*/ if (isUndef(vnode.text)) &#123; if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123; /*新老节点均有children子节点，则对子节点进行diff操作，调用updateChildren*/ if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly) //重点 &#125; else if (isDef(ch))&#123; /*如果老节点没有子节点而新节点存在子节点，先清空elm的文本内容，然后为当前节点加入子节点*/ if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, &#x27;&#x27;) addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue) &#125; else if (isDef(oldCh)) &#123; /*当新节点没有子节点而老节点有子节点的时候，则移除所有ele的子节点*/ removeVnodes(elm, oldCh, 0, oldCh.length - 1) &#125; else if (isDef(oldVnode.text)) &#123; //当新老节点都无子节点的时候，只是文本的替换，因为这个逻辑中新节点text不存在，所以清除ele文本 nodeOps.setTextContent(elm, &#x27;&#x27;) &#125; &#125; else if (oldVnode.text !== vnode.text) &#123; /*当新老节点text不一样时，直接替换这段文本*/ nodeOps.setTextContent(elm, vnode.text) &#125; /*调用postpatch钩子*/ if (isDef(data)) &#123; if (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) i(oldVnode, vnode) &#125;&#125; updateChildren函数 未完待续…","categories":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/tags/Vue/"},{"name":"源码","slug":"源码","permalink":"http://wzr1998.github.io/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"Vue 源码学习之:Vue 数据响应式原理","slug":"Vue源码学习之-Vue数据响应式原理","date":"2018-11-10T04:29:15.000Z","updated":"2020-11-26T05:10:31.977Z","comments":true,"path":"posts/8eff7241/","link":"","permalink":"http://wzr1998.github.io/posts/8eff7241/","excerpt":"","text":"在Vue中数据的变化会作用于UI而不用进行DOM操作，使用 Object.defineProperty() 方法，通过定义属性的 setter 方法拦截对象属性的更变，从而将数值变化转变为UI变化； Vue中数据响应化使用了观察者模式： defineReactive中的getter和setter相当于发布订阅行为 Dep相当于主题Subject，维护订阅者，通知观察者更新 Watcher相当于观察者Observer，执行更新 Vue中的Observer不是上边说的观察者，它和data中的对象一一对应，有内嵌的对象就会有child和Observer与之对应 具体实现是在Vue初始化时，调用 initState 方法，在内部调用 data 、props 等。(路径：src/core/instance/state.js) 一、 initState 函数 路径：src/core/instance/state.js 初始化props、method、data、computed、watch 重点关注6-10行对data的初始化，若存在 data 选项则执行 initData 函数 123456789101112131415export function initState (vm: Component) &#123; vm._watchers = [] const opts = vm.$options if (opts.props) initProps(vm, opts.props) if (opts.methods) initMethods(vm, opts.methods) if (opts.data) &#123; initData(vm) &#125; else &#123; observe(vm._data = &#123;&#125;, true /* asRootData */) &#125; if (opts.computed) initComputed(vm, opts.computed) if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125;&#125; 二、initData 函数 路径：src/core/instance/state.js 12345678910function initData (vm: Component) &#123; let data = vm.$options.data //若data为函数，则获取返回值对象 data = vm._data = typeof data === &#x27;function&#x27; ? getData(data, vm) : data || &#123;&#125; // 做数据代理：proxy(vm, `_data`, key) // 响应化数据： observe(data, true /* asRootData */)&#125; 三、observe 函数：数据响应化 路径：src/core/observer/index.js 如果当前属性已有观察者 value.__ob__ 则直接返回，没有则创建一个observe观察者 123456789101112131415161718192021export function observe (value: any, asRootData: ?boolean): Observer | void &#123; if (!isObject(value) || value instanceof VNode) &#123; return &#125; let ob: Observer | void if (hasOwn(value, &#x27;__ob__&#x27;) &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__ &#125; else if ( shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) &#123; ob = new Observer(value) &#125; if (asRootData &amp;&amp; ob) &#123; ob.vmCount++ &#125; return ob&#125; 四、Observe类： 路径：src/core/observer/index.js Observer对象根据数据类型执行对应的响应化操作，core/observer/index.js 123456789101112131415161718192021222324252627282930313233343536export class Observer &#123; value: any; dep: Dep; vmCount: number; // number of vms that have this object as root $data constructor (value: any) &#123; this.value = value this.dep = new Dep() this.vmCount = 0 def(value, &#x27;__ob__&#x27;, this) if (Array.isArray(value)) &#123; //判断该属性是否为数组 if (hasProto) &#123; protoAugment(value, arrayMethods) &#125; else &#123; copyAugment(value, arrayMethods, arrayKeys) &#125; this.observeArray(value) &#125; else &#123; this.walk(value) &#125; &#125; //普通属性对象，遍历对象所有属性，并转换为getter/setter walk (obj: Object) &#123; const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i]) //进行普通属性响应化 &#125; &#125; //数组属性，对数组每一项单独执行响应化操作 observeArray (items: Array&lt;any&gt;) &#123; for (let i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) &#125; &#125;&#125; 五、defineReactive函数 路径：src/core/observer/index.js defineReactive定义对象属性的getter/setter，getter负责添加依赖，setter负责通知更新 12345678910111213141516171819202122232425262728293031323334353637383940export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean )&#123; const dep = new Dep() // 一个key一个Dep实例 if (arguments.length === 2) &#123; val = obj[key] &#125; // 递归执行子对象响应化 let childOb = !shallow &amp;&amp; observe(val) // 定义当前对象getter/setter Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; // getter被调用时若存在依赖则追加 if (Dep.target) &#123; dep.depend() // 若存在子observer，则依赖也追加到子ob if (childOb) &#123; childOb.dep.depend() if (Array.isArray(value)) &#123; dependArray(value) // 数组需特殊处理 &#125; &#125; &#125; return value &#125;, set: function reactiveSetter (newVal) &#123; if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; val = newVal // 更新值 childOb = !shallow &amp;&amp; observe(newVal) // 递归更新子对象 dep.notify() // 通知更新 &#125; &#125;)&#125; 六、Dep类 负责管理一组Watcher，包括watcher实例的增删及通知更新 路径：core/observer/dep.js 12345678910111213141516171819202122232425262728export default class Dep &#123; static target: ?Watcher; // 依赖收集时的wacher引用 subs: Array&lt;Watcher&gt;; // watcher数组 constructor () &#123; this.subs = [] &#125; //添加watcher实例 addSub (sub: Watcher) &#123; this.subs.push(sub) &#125; //删除watcher实例 removeSub (sub: Watcher) &#123; remove(this.subs, sub) &#125; //watcher和dep相互保存引用 depend () &#123; if (Dep.target) &#123; Dep.target.addDep(this) &#125; &#125; notify () &#123; // stabilize the subscriber list first const subs = this.subs.slice() for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125;&#125; 七、Watcher类 Watcher解析一个表达式并收集依赖，当数值变化时触发回调函数，常用于$watch API和指令中。 一个组件有一个对应的Watcher，数值变化会触发其update函数导致重新渲染 何时创建：新组件生成或使用 $watch API 路径：src/core/observer/watcher.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980export default class Watcher &#123; constructor ( vm: Component, expOrFn: string | Function, cb: Function, options?: ?Object, isRenderWatcher?: boolean ) &#123; this.vm = vm // 组件保存render watcher if (isRenderWatcher) &#123; vm._watcher = this &#125; // 组件保存非render watcher vm._watchers.push(this) // options... // 将表达式解析为getter函数 // 那些和组件实例对应的Watcher创建时会传递组件更新函数进来 if (typeof expOrFn === &#x27;function&#x27;) &#123; this.getter = expOrFn &#125; else &#123; // 这种是$watch传递进来的表达式，它们需要解析为函数 this.getter = parsePath(expOrFn) if (!this.getter) &#123; this.getter = noop &#125; &#125; // 若非延迟watcher，立即调用getter this.value = this.lazy ? undefined : this.get() &#125; //模拟getter, 重新收集依赖re-collect dependencies get () &#123; // Dep.target = this pushTarget(this) let value const vm = this.vm try &#123; // 从组件中获取到value同时触发依赖收集 value = this.getter.call(vm, vm) &#125; catch (e) &#123;&#125; finally &#123; // deep watching，递归触发深层属性 if (this.deep) &#123; traverse(value) &#125; popTarget() this.cleanupDeps() &#125; return value &#125; addDep (dep: Dep) &#123; const id = dep.id if (!this.newDepIds.has(id)) &#123; // watcher保存dep引用 this.newDepIds.add(id) this.newDeps.push(dep) // dep添加watcher if (!this.depIds.has(id)) &#123; dep.addSub(this) &#125; &#125; &#125; update () &#123; // 更新逻辑 if (this.lazy) &#123; this.dirty = true &#125; else if (this.sync) &#123; this.run() &#125; else &#123; //默认lazy和sync都是false，所以会走该逻辑 //对数据做异步的批量更新 queueWatcher(this) &#125; &#125;&#125; 八、数组的响应化操作 数组数据变化采取的策略是拦截push、pop、splice等方法执行dep通知。 为数组原型中的7个可以改变内容的方法定义拦截器 1. dep函数：src/core/util/lang.js 利用defineProperty函数，在赋值时进行额外的操作 12345678export function def (obj: Object, key: string, val: any, enumerable?: boolean) &#123; Object.defineProperty(obj, key, &#123; value: val, enumerable: !!enumerable, writable: true, configurable: true &#125;)&#125; 2. 拦截器：src\\core\\observer\\array.js 运用装饰器模式 1234567891011121314151617181920212223242526272829303132333435// 数组原型const arrayProto = Array.prototype// 修改后的原型export const arrayMethods = Object.create(arrayProto) // 七个待修改方法const methodsToPatch = [&#x27;push&#x27;,&#x27;pop&#x27;,&#x27;shift&#x27;,&#x27;unshift&#x27;,&#x27;splice&#x27;,&#x27;sort&#x27;,&#x27;reverse&#x27;]//拦截这些方法，额外发送变更通知methodsToPatch.forEach(function (method) &#123; // 原始数组方法 const original = arrayProto[method] // 修改这些方法的descriptor def(arrayMethods, method, function mutator (...args) &#123; // 原始操作 const result = original.apply(this, args) // 获取ob实例用于发送通知 const ob = this.__ob__ // 三个能新增元素的方法特殊处理 let inserted switch (method) &#123; case &#x27;push&#x27;: case &#x27;unshift&#x27;: inserted = args break case &#x27;splice&#x27;: inserted = args.slice(2) break &#125; // 若有新增则做响应处理 if (inserted) ob.observeArray(inserted) // 通知更新 ob.dep.notify() return result &#125;)&#125;) 3. Observe中覆盖数组原型：src/core/observer/index.js 123456if (Array.isArray(value)) &#123; // 替换数组原型 protoAugment(value, arrayMethods) // value.__proto__ = arrayMethods this.observeArray(value) //遍历数组每一项，调用observe函数实现响应化&#125; 4. defineReactive中对数组做特殊处理：src/core/observer/index.js 12345678910111213141516// getter处理中if (Array.isArray(value)) &#123; dependArray(value)&#125;// 数组中所有项添加依赖，将来数组里面就可以通过__ob__.dep发送通知 function dependArray (value: Array&lt;any&gt;) &#123; for (let e, i = 0, l = value.length; i &lt; l; i++) &#123; e = value[i] e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend() if (Array.isArray(e)) &#123; dependArray(e) &#125; &#125; &#125; 九、Vue异步更新队列 Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的 所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免 不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重 的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then 、 MutationObserver 和 setImmediate ， 如果执行环境不支持，则会采用setTimeout(fn, 0) 代替。 1. Wacher类中update函数：src/core/observer/watcher.js 满足条件执行queueWatcher函数 1234567891011update () &#123; /* istanbul ignore else */ if (this.lazy) &#123; this.dirty = true &#125; else if (this.sync) &#123; this.run() &#125; else &#123; queueWatcher(this) &#125;&#125; 2. queueWatcher函数：src/core/observer/scheduler.js(调度器) 执行watcher入队操作，若存在重复id则跳过 1234567891011121314151617181920212223// watcher入队export function queueWatcher (watcher: Watcher) &#123; const id = watcher.id if (has[id] == null) &#123; // id不存在才会入队 has[id] = true if (!flushing) &#123; // 没有在执行刷新则进入队尾 queue.push(watcher) &#125; else &#123; // 若已刷新, 按id顺序插入到队列 // 若已经过了, 则下次刷新立即执行 let i = queue.length - 1 while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123; i-- &#125; queue.splice(i + 1, 0, watcher) &#125; // 刷新队列 if (!waiting) &#123; waiting = true nextTick(flushSchedulerQueue) &#125; &#125; &#125; 3. nextTick函数：src/core/util/next-tick.js nextTick按照特定异步策略执行队列刷新操作，按Promise.then 、 MutationObserver 、 setImmediate 、setTimeout(fn, 0) 顺序退化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// nextTick异步执行策略，src\\core\\util\\next-tick.jsexport function nextTick (cb?: Function, ctx?: Object) &#123; let _resolve // 注意cb不是立刻执行，而是加入到回调数组，等待调用 callbacks.push(() =&gt; &#123; if (cb) &#123; try &#123; cb.call(ctx) // 真正执行cb &#125; catch (e) &#123; handleError(e, ctx, &#x27;nextTick&#x27;) &#125; &#125; else if (_resolve) &#123; _resolve(ctx) &#125; &#125;) // 没有处在挂起状态则开始异步执行过程 if (!pending) &#123; pending = true timerFunc() &#125; // $flow-disable-line if (!cb &amp;&amp; typeof Promise !== &#x27;undefined&#x27;) &#123; return new Promise(resolve =&gt; &#123; _resolve = resolve &#125;) &#125; &#125;let timerFunc// nextTick异步行为利用微任务队列，可通过Promise或MutationObserver交互 // 首选Promise，次选MutationObserverif (typeof Promise !== &#x27;undefined&#x27; &amp;&amp; isNative(Promise)) &#123; const p = Promise.resolve() timerFunc = () =&gt; &#123; p.then(flushCallbacks) // IOS hack if (isIOS) setTimeout(noop) &#125; isUsingMicroTask = true&#125; else if (!isIE &amp;&amp; typeof MutationObserver !== &#x27;undefined&#x27; &amp;&amp; ( isNative(MutationObserver) || // PhantomJS and iOS 7.x MutationObserver.toString() === &#x27;[object MutationObserverConstructor]&#x27;)) &#123; // 不能用Promise时:PhantomJS, iOS7, Android 4.4 let counter = 1 const observer = new MutationObserver(flushCallbacks) const textNode = document.createTextNode(String(counter)) observer.observe(textNode, &#123; characterData: true &#125;) timerFunc = () =&gt; &#123; counter = (counter + 1) % 2 textNode.data = String(counter) &#125; isUsingMicroTask = true&#125; else if (typeof setImmediate !== &#x27;undefined&#x27; &amp;&amp; isNative(setImmediate)) &#123; // 回退到setImmediate.它利用的是宏任务队列 timerFunc = () =&gt; &#123; setImmediate(flushCallbacks) &#125;&#125; else &#123; // 最后选择setTimeout. timerFunc = () =&gt; &#123; setTimeout(flushCallbacks, 0)&#125;&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/tags/Vue/"},{"name":"源码","slug":"源码","permalink":"http://wzr1998.github.io/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"Vue 源码学习之：分析 Vue 构造函数初始化流程","slug":"Vue源码学习之-分析Vue构造函数初始化流程","date":"2018-11-07T04:29:15.000Z","updated":"2020-11-26T05:09:49.942Z","comments":true,"path":"posts/1033df38/","link":"","permalink":"http://wzr1998.github.io/posts/1033df38/","excerpt":"","text":"一、new Vue()：只进行初始化 this._init(options) this._init(options) 函数在 initMixin(Vue) 中创建 二、分析 this._init(options) 进行初始化操作 路径：src/core/instance/init.js 12345678initLifecycle(vm)initEvents(vm)initRender(vm)callHook(vm, &#x27;beforeCreate&#x27;)initInjections(vm) // resolve injections before data/propsinitState(vm)initProvide(vm) // resolve provide after data/propscallHook(vm, &#x27;created&#x27;) 1. initLifecycle(vm) 初始化组件实例中常用属性，如 $parent 、$root 、$hildren 、$refs 路径：src/core/instance/lifecycle.js 123456789const options = vm.$optionslet parent = options.parentvm.$parent = parentvm.$root = parent ? parent.$root : vmvm.$children = []vm.$refs = &#123;&#125;vm._watcher = nullvm._inactive = null 2. initEvents(vm) 初始化父组件中定义的需要子组件处理的事件，如 &lt;comp @event=&quot;fn&quot;&gt;&lt;/comp&gt;、comp.$emit('event') 、comp.$on('event', fn) ，其中fn事件处理函数在父组件中创建，event事件由comp组件监听和触发 路径：src/core/instance/events.js 123456789export function initEvents (vm: Component) &#123; vm._events = Object.create(null) vm._hasHookEvent = false // init parent attached events const listeners = vm.$options._parentListeners if (listeners) &#123; updateComponentListeners(vm, listeners) &#125;&#125; 3. initRender(vm) $slots 、 $scopedSlots 初始化，$createElement 函数声明，$attrs 和 $listeners 的响应化 路径：src/core/instance/render.js 1234567891011121314151617vm._vnode = null // the root of the child tree vm._staticTrees = null // v-once cached trees const options = vm.$options const parentVnode = vm.$vnode = options._parentVnode // the placeholder node inparent treeconst renderContext = parentVnode &amp;&amp; parentVnode.contextvm.$slots = resolveSlots(options._renderChildren, renderContext) vm.$scopedSlots = emptyObject// 把createElement函数挂载到当前组件上，编译器需要用到vm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false)// 用户编写渲染函数使用这个render functions.vm.$createElement = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, true) // $attrs &amp; $listeners are exposed for easier HOC creation. // they need to be reactive so that HOCs using them are always updated const parentData = parentVnode &amp;&amp; parentVnode.data defineReactive(vm, &#x27;$attrs&#x27;, parentData &amp;&amp; parentData.attrs || emptyObject, null,true)defineReactive(vm, &#x27;$listeners&#x27;, options._parentListeners || emptyObject, null, true) 4. callHook(vm, ‘beforeCreate’) 调用 beforeCreate 生命周期钩子 5. initInjections(vm) 注入内容的响应化 路径：src/core/instance/inject.js 12345678910// 获取注入内容const result = resolveInject(vm.$options.inject, vm) if (result) &#123; toggleObserving(false) // 注入内容响应化 Object.keys(result).forEach(key =&gt; &#123; defineReactive(vm, key, result[key]) &#125;) toggleObserving(true)&#125; 6. initState(vm) 各种各种数据状态初始化地方，包括数据响应化等 路径：src/core/instance/state.js 123456789101112131415161718export function initState (vm: Component) &#123; vm._watchers = [] const opts = vm.$options //初始化所有属性 if (opts.props) initProps(vm, opts.props) //初始化回掉函数 if (opts.methods) initMethods(vm, opts.methods) //数据响应化 if (opts.data) &#123; initData(vm) &#125; else &#123; observe(vm._data = &#123;&#125;, true /* asRootData */) &#125; if (opts.computed) initComputed(vm, opts.computed) if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125;&#125; 7. initProvide(vm) 为自组件提供数据 路径：src/core/instance/inject.js 12345678export function initProvide (vm: Component) &#123; const provide = vm.$options.provide if (provide) &#123; vm._provided = typeof provide === &#x27;function&#x27; ? provide.call(vm) : provide &#125;&#125; 8. callHook(vm, ‘created’) 调用 created 生命周期钩子","categories":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/tags/Vue/"},{"name":"源码","slug":"源码","permalink":"http://wzr1998.github.io/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"Vue 源码学习之：寻找 Vue 构造函数","slug":"Vue源码学习之-寻找Vue构造函数","date":"2018-11-05T04:29:15.000Z","updated":"2020-11-26T05:09:53.072Z","comments":true,"path":"posts/597ee5b2/","link":"","permalink":"http://wzr1998.github.io/posts/597ee5b2/","excerpt":"","text":"一、查看package.json中script-dev： 1&quot;dev&quot;: &quot;rollup -w -c scripts/config.js --sourcemap --environment TARGET:web-full-dev&quot; 二、查看scripts/config.js中123行web-full-dev (web端全版本开发)： 12345678&#x27;web-full-dev&#x27;: &#123; entry: resolve(&#x27;web/entry-runtime-with-compiler.js&#x27;), dest: resolve(&#x27;dist/vue.js&#x27;), format: &#x27;umd&#x27;, env: &#x27;development&#x27;, alias: &#123; he: &#x27;./entity-decoder&#x27; &#125;, banner&#125; entry 为入口文件，路径中 web 会被替换为 src/platforms/web 三、查看src/platforms/web/entry-runtime-with-compiler.js(入口文件)： 扩展 $mount 方法，若配置项中没有render函数，则获取 template 转化为 render 函数，添加至配置项中，最后执行默认 $mount 函数 123456789101112131415161718192021222324252627import Vue from &#x27;./runtime/index&#x27;// 扩展默认$mount方法:能够编译template或el指定的模板 const mount = Vue.prototype.$mount Vue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean ): Component &#123; // 获取选项 const options = this.$options // 不存在render选项，则将template/el的设置转换为render函数 if (!options.render) &#123; let template = options.template if (template) &#123; // 解析template选项 &#125; else if (el) &#123; // 否则解析el选项 template = getOuterHTML(el) &#125; if (template) &#123; // 编译得到render函数 const &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;..&#125;, this) options.render = render &#125; &#125; // 执行默认$mount函数 return mount.call(this, el, hydrating)&#125; 四、查看src/platforms/web/runtime/index.js： 实现$mount，核心就一个mountComponent，定义一个 __patch__ 方法 123456789import Vue from &#x27;core/index&#x27;Vue.prototype.__patch__ = inBrowser ? patch : noopVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123;el = el &amp;&amp; inBrowser ? query(el) : undefined // 挂载组件return mountComponent(this, el, hydrating)&#125; 五、查看src/core/index.js： 初始化全局API 12import Vue from &#x27;./instance/index&#x27;initGlobalAPI(Vue) 六、查看src/core/instance/index.js： Vue的构造函数终于出现！！！ 1234567891011121314151617181920212223import &#123; initMixin &#125; from &#x27;./init&#x27;import &#123; stateMixin &#125; from &#x27;./state&#x27;import &#123; renderMixin &#125; from &#x27;./render&#x27;import &#123; eventsMixin &#125; from &#x27;./events&#x27;import &#123; lifecycleMixin &#125; from &#x27;./lifecycle&#x27;import &#123; warn &#125; from &#x27;../util/index&#x27;function Vue (options) &#123; if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !(this instanceof Vue) ) &#123; warn(&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;) &#125; this._init(options)&#125;initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)export default Vue initMixin(Vue)：实现Vue初始化 _init 函数 路径：src/core/instance/init.js stateMixin(Vue)：组件状态相关API，如 $set 、$delete 、$watch 的实现 路径：src/core/instance/state.js eventsMixin(Vue)：事件相关API如 $on 、$off 、$emit 、$once 的实现 路径：src/core/instance/events.js lifecycleMixin(Vue)：组件生命周期API如 _update 、$forceUpdate 、$destroy 的实现 其中 _update 是组件更新周期中的关键方法，在组件更新时会调用此方法，执行vnode的diff和patch等操作 路径：src/core/instance/lifecycle.js renderMixin(Vue)：实现组件渲染函数API如 $nextTick 、_render 的实现 其中 _render 是生成虚拟dom的关键函数 路径：src/core/instance/render.js","categories":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/tags/Vue/"},{"name":"源码","slug":"源码","permalink":"http://wzr1998.github.io/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"MVVM 模型及简易 Vue 核心源码实现","slug":"MVVM模型及简易vue源码实现","date":"2018-11-01T04:29:15.000Z","updated":"2020-12-01T12:21:07.307Z","comments":true,"path":"posts/1f6f02d1/","link":"","permalink":"http://wzr1998.github.io/posts/1f6f02d1/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162//遍历模板，处理内部插值表达式，并对@xx/v-xx等进行特殊处理，创建mvvm对象是实例化解析模板class Compile&#123; constructor(el, vm)&#123; this.$vm = vm; this.$el = document.querySelector(el); if(this.$el)&#123; //将$el中元素迁移至fragment中进行处理，不直接修改DOM，提高效率 this.$fragment = this.moveToFragment(this.$el); //编译fragment this.compile(this.$fragment); //将编译结果追加至宿主中 this.$el.appendChild(this.$fragment); &#125; &#125; moveToFragment(el)&#123; const fragment = document.createDocumentFragment(); let child; while((child = el.firstChild))&#123; fragment.appendChild(child); //剪切操作，把el中的子元素逐一按顺序添加到fragment中 &#125; return fragment; &#125; compile(fragment)&#123; [...fragment.childNodes].forEach(node =&gt; &#123; if(node.nodeType === 1)&#123; //元素节点 this.compileElement(node); if(node.childNodes.length&gt;0) this.compile(node); //递归遍历该内部子节点 &#125;else if(node.nodeType === 3 &amp;&amp; /&#123;&#123;(.*)&#125;&#125;/.test(node.textContent.trim()) )&#123;//文本节点，且含有&#123;&#123;data&#125;&#125;插值表达式，其中正则内的.*为任意字符出现0次或多次 //RegExp.$1为当前匹配子串，如&#123;&#123;msg&#125;&#125;中的msg(data中的属性名)，this.$vm[RegExp.$1]获取data中的属性名 node.textContent = this.$vm[RegExp.$1]; //创建watcher对象，传入vm对象和监控属性，回掉中value接收改变后的最新值 new Watcher(this.$vm, RegExp.$1, value=&gt;node.textContent=value); &#125; &#125;) &#125; compileElement(node)&#123; [...node.attributes].forEach(attr =&gt; &#123; if(/^v-/.test(attr.name) &amp;&amp; !(/^v-on:/.test(attr.name)))&#123; //执行指令，不能是&quot;v-on:&quot;开头 const instructType = attr.name.substring(2); const instructValue = attr.value; const instruct = this.instruct(this.$vm, node, instructValue); //this[instruct] &amp;&amp; this[instruct].bind(this.$vm)(node, expression); instruct[instructType] &amp;&amp; instruct[instructType](); &#125;else if(/^v-on:/.test(attr.name) || /^@/.test(attr.name))&#123; //执行绑定事件 const eventName = /^v-on:/.test(attr.name) ? attr.name.substring(5) : attr.name.substring(1); const fn = this.$vm.$options.methods &amp;&amp; this.$vm.$options.methods[attr.value]; //从mvvm对象上$options下的methods获取绑定函数 if(eventName &amp;&amp; fn) node.addEventListener(eventName, fn.bind(this.$vm)); &#125; &#125;) &#125; instruct(vm, node, instructValue)&#123; return &#123; text()&#123; node.textContent = vm[instructValue]; new Watcher(vm, instructValue, value=&gt;node.textContent=value); &#125;, html()&#123; node.innerHTML = vm[instructValue]; new Watcher(vm, instructValue, value=&gt;node.innerHTML=value); &#125;, model()&#123; node.value = vm.$data[instructValue]; node.oninput = e=&gt;&#123; vm.$data[instructValue] = e.target.value; &#125;; new Watcher(vm, instructValue, value=&gt;node.value=value); &#125; &#125; &#125;&#125;//管理若干watcher实例，data中每响应话一个属性九创建一个dep实例，保证data中数据中的key是一对一的关系class Dep&#123; constructor()&#123; this.dep = []; //观察的watcher实例集合 &#125; addWatcher(watcher)&#123; this.dep.push(watcher); &#125; notify()&#123; //通知，发布消息 this.dep.forEach(watcher =&gt; watcher.update()) &#125;&#125;//保存view中的依赖，视图中每遇到一个变量九创建一个watcherclass Watcher&#123; constructor(vm, key, cb)&#123; this.vm = vm; this.key = key; this.cb = cb; Dep.target = this; //静态属性，将当前watcher实例绑定到Dep.target下，为当前观察者 this.vm[key]; //读取属性触发getter，把当前watcher对象添加到dep中 Dep.target = null; &#125; update()&#123; this.cb &amp;&amp; this.cb.call(this.vm, this.vm[this.key]); //data中数据由更新则执行watcher中回掉，传入改变后的最新值 &#125;&#125;class MVVM&#123; constructor(options)&#123; this.$options = options; this.$data = options.data; if(options.computed) this.compileComputed.call(this, options); //处理计算属性 this.observe(this.$data);//响应化 new Compile(options.el, this); if(options.create) options.create.call(this); &#125; observe(data)&#123;//递归便利，使传递进来的对象响应化 if(!data || typeof data !== &#x27;object&#x27;) return; //传递的data值必须为对象 Object.keys(data).forEach(key =&gt; &#123; this.defineReactive(data, key, data[key]); //对key做响应式处理 this.proxyData(key); //代理属性 &#125;) &#125; defineReactive(data, key, value)&#123; this.observe(value); //递归遍历data对象中属性，为所有嵌套对象设置响应式 const dep = new Dep(); Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: () =&gt; &#123; Dep.target &amp;&amp; dep.addWatcher(Dep.target); return value; &#125;, set: newValue =&gt; &#123; if(newValue !== value)&#123; value = newValue; dep.notify(); //若设置新值则另dep执行notify函数，通知所有watcher进行更新 &#125; &#125; &#125;) &#125; proxyData(key)&#123; //代理：通过this.msg能拿到this.$data.msg的数据 Object.defineProperty(this, key, &#123; enumerable: true, configurable: true, get()&#123; return this.$data[key] &#125;, set(newValue)&#123; this.$data[key] = newValue &#125; &#125;) &#125; compileComputed(options)&#123; Object.keys(options.computed).forEach(getMethod=&gt;&#123; Object.defineProperty(this, getMethod, &#123; get: () =&gt; options.computed[getMethod].call(this) &#125;) &#125;) &#125;&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/tags/Vue/"},{"name":"源码","slug":"源码","permalink":"http://wzr1998.github.io/tags/%E6%BA%90%E7%A0%81/"},{"name":"MVVM","slug":"MVVM","permalink":"http://wzr1998.github.io/tags/MVVM/"}]},{"title":"webpack 基础之Code Splitting、Shimming、打包分析","slug":"webpack-基础之Code-Splitting、Shimming、打包分析","date":"2018-10-23T04:29:15.000Z","updated":"2020-12-01T12:36:24.964Z","comments":true,"path":"posts/8ac0ef36/","link":"","permalink":"http://wzr1998.github.io/posts/8ac0ef36/","excerpt":"","text":"一、Code Splitting 方法一：手动设置多入口文件 利用entry多入口文件，把不同功能模块分开打包，主页中分开引用 好处：当某一业务代码文件更改时，其他代码不变，直接读取缓存中文件，无需重新加载 方法二：splitChunk自动分割 webpack.config.js中配置： 12345678910111213141516171819202122232425262728module.exports = &#123; //... optimization: &#123; splitChunks: &#123; //一下为默认配置 chunks: &#x27;async&#x27;, //满足引入方式条件则分块打包，all/initial/async 全部/同步/异步 minSize: 30000, //代码分割文件大小最小值（kb） maxSize: 0, //代码分割文件大于maxSize则拆分成多个maxSize大小的文件(不一定成功)，0不做限制 minChunks: 1, //一个模块至少被其他chunk引用多少次才做代码分割 maxAsyncRequests: 5, //代码分割最大数量 maxInitialRequests: 3, //入口文件最大并行请求数 automaticNameDelimiter: &#x27;~&#x27;, //默认链接符（默认为&quot;块名～内容名&quot;） automaticNameMaxLength: 30, //默认文件名最大字节数 name: true, //true为使文件默认打包名生效 cacheGroups: &#123; //满足chunks条件，则分组打包 vendors: &#123; //组名 test: /[\\\\/]node_modules[\\\\/]/, //文件所在位置条件 priority: -10, //优先级 filename: &#x27;xxx.js&#x27; //打包名 &#125;, default: &#123; minChunks: 2, priority: -20, reuseExistingChunk: true //如果一个模块之前已经被打包过了，在不同位置引入相同模块则直接复用 &#125; &#125; &#125; &#125;&#125; 动态引入组件插件：@babel/plugin-syntax-dynamic-import 地址：https://babeljs.io/docs/en/babel-plugin-syntax-dynamic-import/ 模块懒加载 webpack希望所有与用户交互相关的代码都异步引入，以提高页面首次加载的性能 click.js 用户交互代码 12345export default function()&#123; const div = document.createElement(&#x27;div&#x27;); div.innerText = &#x27;王卓然2333&#x27;; document.body.appendChild(div);&#125; main.js 异步引用 1234document.addEventListener(&#x27;click&#x27;, async ()=&gt;&#123; const &#123;default: clickFn&#125; = await import(/* webpackPrefetch: true */ &#x27;./click&#x27;); clickFn();&#125;); 预取/预加载模块 地址 在引入异步模块时使用： import(/* webpackPrefetch: true */ './click') 或 import(/* webpackPreload: true */ './click') webpackPrefetch：在所有父 chunk 加载结束后开始加载 webpackPreload：在父 chunk 加载时，以并行方式开始加载 二、Shimming 解决webpack打包过程中的兼容性问题 ProvidePlugin 作用： 自动加载模块，而不必到处 import 或 require 。 例如下配置：则其他模块中无需引入jquery即可直接使用 $ 和 jQuery 变量 123456789module.exports = &#123; //... plugin: [ new webpack.ProvidePlugin(&#123; $: &#x27;jquery&#x27;, jQuery: &#x27;jquery&#x27; &#125;); ]&#125; imports-loader 作用： 改变全局变量的值，如改变this指向window 1234567891011module.exports = &#123; //... module: &#123; rules: [ &#123; test: /\\.js$/, use: [&#x27;imports-loader?this=&gt;window&#x27;] &#125; ] &#125;&#125; 三、打包分析 地址：https://github.com/webpack/analyse ​ https://webpack.js.org/guides/code-splitting/#bundle-analysis 执行 webpack --profile --json &gt; stats.json 在根目录生成 state.json 文件，其中保存所有打包过程的描述信息","categories":[{"name":"webpack","slug":"webpack","permalink":"http://wzr1998.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://wzr1998.github.io/tags/webpack/"}]},{"title":"webpack基础之编译ES6+、tree shaking、Develop&Production","slug":"webpack基础之编译ES6-、tree-shaking、Develop-Production","date":"2018-10-20T04:29:15.000Z","updated":"2020-12-01T12:37:25.732Z","comments":true,"path":"posts/93a59062/","link":"","permalink":"http://wzr1998.github.io/posts/93a59062/","excerpt":"","text":"一、编译ES6+代码 参考bable官方文档配置：官方地址 1. 安装： 1cnpm install --save-dev babel-loader @babel/core 1cnpm install @babel/preset-env --save-dev 1cnpm install --save @babel/polyfill 1cnpm install --save-dev @babel/plugin-transform-runtime 1cnpm install --save @babel/runtime 1cnpm install --save @babel/runtime-corejs2 bable-loader：连通bable和webpack @babel/core：bable核心库 @babel/preset-env：包含所有ES6+转化为ES5的翻译规则 @babel/polyfill：包含ES6+新特性的ES5实现原理 2. 配置： 1234567891011121314151617181920212223242526272829303132//webpack.config.jsmodule.exports = &#123; module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, //排除文件夹(正则) loader: &quot;babel-loader&quot; , options: &#123; presets: [ //开发普通业务代码 [&#x27;@babel/preset-env&#x27;, &#123;targets: &#123;chrome: &quot;67&quot;&#125;, useBuiltIns: &quot;usage&quot;&#125;] //设定兼容版本，并配置只有源代码中使用过的ES6+语法才转化 &quot;plugins&quot;: [&quot;@babel/plugin-transform-runtime&quot;] ], //开发库相关代码 plugins: [[&quot;@babel/plugin-transform-runtime&quot;, &#123; absoluteRuntime: false, corejs: 2, helpers: true, regenerator: true, useESModules: false&#125;] ] &#125; &#125; ] &#125;&#125;//index.js//在全局注入ES6+实现原理，会污染全局环境，如果设置useBuiltIns: &quot;usage&quot;则无需引入import &#x27;@babel/polyfill&#x27;; //业务代码最顶部引入@babel/polyfill 可以把babel配置中的所有配置项单独存放在 .babelrc 文件下 二、tree shaking 作用： 移除 JavaScript 上下文中的未引用代码(dead-code)，只引入需要的代码 注意： tree shaking只支持 ES module(import/export) 模块引入(静态引入) 在development环境下，即使tree shaking监测到未引用的代码，也不会删除掉，仅会提示 配置：production环境 123456789//webpack.config.jsmodule.exports = &#123; optimization: &#123; //开发环境 usedExports: true &#125;&#125;//package.json中添加：&quot;sideEffects&quot;: [&#x27;*.css&#x27;, &#x27;@bable/polly-fill &#x27;] //不使用tree shaking的文件，无特殊文件则配置false development环境下则仅需配置 package.json 中的 sideEffects 选项，其他配置项已配好 三、Develop / Production模式区别配置 思想： 分离Develop / Production模式下不同的配置代码，webpack.common.js 中保存公用配置项，通过 webpack-merge 合并配置文件。 package.json： 1234567&#123; &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --config webpack.dev.js&quot;, &quot;build&quot;: &quot;webpack --config webpack.prod.js&quot; &#125;&#125; webpack.common.js: 123456789101112131415161718const path = require(&#x27;path&#x27;);const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);const CleanWebpackPlugin = require(&#x27;clean-webpack-plugin&#x27;);module.exports = &#123; entry: &#x27;./src/index.js&#x27;, module: &#123; rules: [...] &#125;, output: &#123; path: path.resolve(__dirname, &#x27;../dist&#x27;) &#125;, plugins: [ new HtmlWebpackPlugin(&#123;template: &#x27;src/index.html&#x27;&#125;), new CleanWebpackPlugin([&#x27;dist&#x27;], &#123;root: path.resolve(__dirname, &#x27;../&#x27;)&#125;) ]&#125; webpack.dev.js: 123456789101112131415161718192021const webpack = require(&#x27;webpack&#x27;);const merge = require(&#x27;webpack-merge&#x27;);const commonConfig = require(&#x27;./webpack.common.js&#x27;);const devConfig = &#123; mode: &#x27;development&#x27;, devtool: &#x27;cheap-module-eval-source-map&#x27;, devServer: &#123; contentBase: &#x27;./dist&#x27;, open: true, port: 8080, hot: true &#125;, plugins: [new webpack.HotModuleReplacementPlugin()], optimization: &#123; usedExports: true &#125;&#125;module.exports = merge(commonConfig, devConfig); webpack.prod.js: 12345678910const merge = require(&#x27;webpack-merge&#x27;);const commonConfig = require(&#x27;./webpack.common.js&#x27;);const prodConfig = &#123; mode: &#x27;production&#x27;, devtool: &#x27;cheap-module-source-map&#x27;&#125;module.exports = merge(commonConfig, prodConfig);","categories":[{"name":"webpack","slug":"webpack","permalink":"http://wzr1998.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://wzr1998.github.io/tags/webpack/"}]},{"title":"webpack 基础之plugins、devtool、开发工具、HMR","slug":"webpack-基础之plugins、devtool、开发工具、HMR","date":"2018-10-16T04:29:15.000Z","updated":"2020-11-26T04:58:38.410Z","comments":true,"path":"posts/7aec0aa6/","link":"","permalink":"http://wzr1998.github.io/posts/7aec0aa6/","excerpt":"","text":"一、plugins plugin：在打包的某个时间节点(类似生命周期)进行一些相关操纵 1. html-webpack-plugin 作用：打包结束后，自动生成一个html文件，并把打包生成的js文件注入到这个文件中 GitHub 安装： 1cnpm i html-webpack-plugin -D 常用配置： 12345678910plugins: [ //插件 new HtmlWebpackPlugin(&#123; template: &#x27;./src/index.html&#x27;, filename: &#x27;index.html&#x27;, minify: &#123; removeAttributeQuotes: true, //删除标签中引号 collapseWhitespace: true //删除换行 &#125; &#125;)] 2. clean-webpack-plugin 网址：GitHub、npm 作用：在重新打包前，自动删除指定文件夹下所有内容，再进行打包，默认删除webpack输出路径中的所有文件 安装： 1cnpm i clean-webpack-plugin -D 常用配置： 12345//通过解构赋值的方式引入模块const &#123; CleanWebpackPlugin &#125; = require(&#x27;clean-webpack-plugin&#x27;);//webpack.config.js 导出配置中添加：plugins: [ new CleanWebpackPlugin([&#x27;dist&#x27;]) ] 二、devtool—sourceMap 是一个映射文件，知道源文件和打包后文件的映射关系。链接 配置： 123module.exports = &#123; devtool : &#123;sourceMapType:String&#125;&#125; devtool参数说明： source-map：生成一个.map映射文件 inline：在打包文件内部通过base64转化，放在打包文件底部 cheap：映射文件只精确到行，不精确到列，打包速度更快，只针对业务代码，不针对第三方模块 module：不止管业务代码，还管第三方模块代码映射 eval：通过eval执行函数，生成sourceMap映射关系（添加 //# sourceURL=webpack:///./src/index.js?） 配置参考 开发阶段：cheap-module-eval-cource-map 生产阶段：cheap-module-source-map 三、开发工具 1. webpack’s Watch Mode 源代码发生变化时，webpack会监听到变化并重新打包文件，不必进行手动构建。执行代码： 1npx webpack --watch 2. webpack-dev-server 提供了一个简单的 web 服务器，并且能够实时重新加载(live reloading)，代码发生变化时自动重新打包并重启服务器，打包文件存放在内存当中 安装： 1cnpm i webpack-dev-server -D 配置： 1234567module.exports = &#123; devServer: &#123; port: 2333, contentBase: &#x27;/dist&#x27;, open: true //启动后自动打开浏览器 &#125;&#125; 启动： 12npx webpack-dev-derver 四、热模块替换(HMR) 修改CSS文件时，只会更改CSS渲染内容，不会修改js渲染出的内容 123456789101112module.exports = &#123; devServer: &#123; port: 2333, contentBase: &#x27;/dist&#x27;, hot: true, //开启HMR功能 hotOnly: true //HMR功能未生效则不让浏览器自动刷新 &#125;, plugins: [ new webpack.HotModuleReplacementPlugin() ],&#125; js热模块替换： 123456789101112//outer.jsmodule.exports.fn = function()&#123; console.log(2333)&#125;//index.jsif(module.hot)&#123; module.hot.accept(&#x27;./outerJs1&#x27;, ()=&gt;&#123; outerIs1.fn() &#125;)&#125;","categories":[{"name":"webpack","slug":"webpack","permalink":"http://wzr1998.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://wzr1998.github.io/tags/webpack/"}]},{"title":"webpack 基础之打包 CSS 文件","slug":"webpack-基础之打包-CSS-文件","date":"2018-10-13T04:29:15.000Z","updated":"2020-12-01T12:38:29.812Z","comments":true,"path":"posts/6b8c0478/","link":"","permalink":"http://wzr1998.github.io/posts/6b8c0478/","excerpt":"","text":"一、css-loader、style-loader css-loader： css-loader:分析出几个css文件的关系，合并成一个css文件 style-loader： 生成style标签，将css文件挂在到文档head部分 1cnpm i css-loader css-loader -D 二、postcss-loader： 1cnpm i postcss-loader -D Posts.config.js配置文件： 安装：cnpm i autoprefixer -D 利用 Autoprefixer 插件自动补全样式前缀： 123module.exports = &#123; plugins: [/*require(&#x27;autoprefixer&#x27;)*/]&#125;; 三、常用基本配置： 12345678910111213141516&#123; test: /\\.css$/, use: [ /*MiniCssExtractPlugin.loader*/ &#x27;style-loader&#x27;, &#123; loader: &#x27;css-loader&#x27;, options: &#123; importLoaders: 2 //css @import引入文件内向上使用loader的层数, module: true //css模块化 &#125; &#125;, &#x27;sass-loader&#x27;, &#x27;postcss-loader&#x27; ]&#125;, 四、css模块化： 12345678910//webpack.config.js中css-loader中添加配置项：options: &#123;module: true&#125;//img.css:.imgClass&#123;height:300px; &#125;//各模块内：const style = require(&#x27;./img.css&#x27;);const oImg = document.getElementsByTagName(&#x27;img&#x27;)[0];oImg.className.add(style.imgClass) 五、抽离CSS样式：mini-css-extract-plugin 若使用 style-loader 则CSS被打包在js文件内，在style中引入 1. 注意： 不支持HMR，尽量用在生产环境； 若使用 tree shaking 注意在配置 package.json中添加：`“sideEffects”: [ ‘*.css’ ]`` ``mini-css-extract-plugin底层使用SplitChunksPlugin` 插件，可以通过 splitChunks 配置详细参数 根据不同入口路径，区别打包：链接 2. 安装： 1cnpm i mini-css-extract-plugin -D 3. 配置： 12345678910111213141516171819202122232425262728293031//webpack.config.jsconst MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;);module.exports = &#123; //... module: &#123; rules: [ &#123; test : /\\.css$/, use: [MiniCssExtractPlugin.loader, &#x27;css-loader&#x27;] &#125; ] &#125;, pluins: [ new MiniCssExtractPlugin(&#123; filename: &#x27;[name].css&#x27;, //主页面引入css文件名 chunkFilename: &#x27;[name].chunk.css&#x27;, //css模块引入的其他文件(间接引用) &#125;) ], optimization: &#123; splitChunks: &#123; cacheGroups: &#123; styles: &#123; name: &#x27;styles&#x27;, test: /\\.css$/, chunks: &#x27;all&#x27;, enforce: true &#125; &#125; &#125; &#125;&#125; 六、优化分离CSS代码 导出CSS代码压缩：optimize-css-assets-webpack-plugin 1cnpm i optimize-css-assets-webpack-plugin -D webpack.config.js: 12345678const OptimizeCSSAssetsPlugin = require(&quot;optimize-css-assets-webpack-plugin&quot;);module.export = &#123; //... optimization: &#123; minimizer: [new OptimizeCSSAssetsPlugin(&#123;&#125;)] &#125;&#125;","categories":[{"name":"webpack","slug":"webpack","permalink":"http://wzr1998.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://wzr1998.github.io/tags/webpack/"}]},{"title":"webpack 基础之安装、出入口、Loaders、icon","slug":"webpack基础之安装、出入口、Loaders、icon","date":"2018-10-10T04:29:15.000Z","updated":"2020-11-26T04:59:53.960Z","comments":true,"path":"posts/eeac9b75/","link":"","permalink":"http://wzr1998.github.io/posts/eeac9b75/","excerpt":"","text":"官网：https://www.webpackjs.com 一、起步 1. 安装 1cnpm i webpack webpack-cli -D -D：开发依赖，不用与生产环境 2. 执行自定义名称配置文件 1npx webpack --config configName.js 二、entry / output 定义项目打包入口 及 出口 123456789101112module.exports = &#123; entry: &#123; main: &quot;./src/index.js&quot;, bundle: &quot;./src/index.js&quot; &#125;, output: &#123; filename: &#x27;[name].[hash:20].js&#x27;, //入口文件打包生成对应的js文件名 chunkFilename: &#x27;[name].chunk.js&#x27;, //打包生成chunk模块文件名(主文件间接引用)，默认[id].js path: path.resolve(__dirname, &#x27;dist&#x27;), //必须是绝对路径 publicPath: &#x27;www.cdn.com&#x27; //添加cdn外部静态资源服务器域名，打包后文件链接：www.cdn.com/main.5a8e8a1b2b71d24b8b47.js &#125;,&#125; 三、Loaders 1. File-loader 作用：指示webpack将所需对象作为文件发出并返回其公共URL 安装： 1cnpm i file-loader -D 常用配置： 12345678910&#123; test: /\\.(png|jpg|gif)$/, use: &#123; loader: &#x27;file-loader&#x27;, options: &#123; name: &#x27;[name]_[hash:20].[ext]&#x27;, //文件名 outputPath: &#x27;image/&#x27; //打包目录 &#125; &#125;&#125; placeholders: 名称 类型 默认值 描述 [ext] &#123;String&#125; file.extname 资源拓展名 [name] &#123;String&#125; file.basename 资源的基本名称 [path] &#123;String&#125; file.dirname 资源相对 context 的路径 [hash] &#123;String&#125; md5 内容的哈希值，下面的 hashes 配置中有更多信息 [N] &#123;Number&#125; 当前文件名按照查询参数 regExp 匹配后获得到第 N 个匹配结果 [contenthash] &#123;String&#125; gen 2. url-loader 作用：功能类似于 file-loader，但是在文件大小（单位 byte）低于指定的限制时，可以返回一个 DataURL(limit选项设定)。 安装： 1cnpm i file-loader -D 常用配置： 123456789101112&#123; test: /\\.(png|jpg|gif)$/, use: &#123; loader: &#x27;url-loader&#x27;, options: &#123; name: &#x27;[name]_[hash:20].[ext]&#x27;, //文件名 outputPath: &#x27;image/&#x27;, //打包目录 limit: 1024*2, fallback: &#x27;file-loader&#x27; //文件大小大于限定值使用的其他loader(默认file-loader) &#125; &#125;&#125; 四、打包icon图标文件 图标下载网站：Iconfont.cn，下载icon图标后(本质是字体文件)，通过css自定义字体引入，设定元素class即可使用 webpack.config.js中配置： 1234567&#123; test: /\\.(eot|ttf|svg|woff|woff2)$/, use: &#123; loader: &#x27;file-loader&#x27;, options: &#123;name: &#x27;[path][hash:20].[ext]&#x27;&#125; &#125;&#125;","categories":[{"name":"webpack","slug":"webpack","permalink":"http://wzr1998.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://wzr1998.github.io/tags/webpack/"}]},{"title":"Vuex 核心原理实现","slug":"Vuex核心原理实现","date":"2018-10-10T04:29:15.000Z","updated":"2020-11-26T05:08:14.161Z","comments":true,"path":"posts/71192120/","link":"","permalink":"http://wzr1998.github.io/posts/71192120/","excerpt":"","text":"一、设计思路： 实现插件： 使用 Vue.use(Store) 方法添加插件，其内部调用 Store.install 方法， Store.install 方法内调用 Vue.mixin 方法混入，向Vue全局对象下添加 $store 属性；同时注意在使用时通过 new Vuex.Store() 创建实例，所以用 export default &#123;Store, install&#125; 导出，Store 为Vuex class， nistall 为注入方法 创建 Store，实现 state 、getters 、mutation 、actions，以及对应 commit 、disaptch 方法： 在 commit 和 disaptch 方法内部执行 mutation 和 actions 中的方法，调用时按形式传入state或其他对象 实现数据响应式变化，利用Vue响应式原理 二、代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344let Vue;class Store&#123; constructor(options)&#123; this.state = new Vue(&#123; data: options.state &#125;); this.mutations = options.mutations; this.actions = options.actions; //若配置项中存在getters，则在添加store.getters options.getters &amp;&amp; this.handleGetters(options.getters) &#125; commit = (type, arg) =&gt; &#123;//commit函数调用时执行上下文环境可能会变(比如在定时器内调用)，用箭头函数固定当前this指向store对象 //通过commit(&#x27;name&#x27;, arg)执行配置项mutation中形如addCount(state, payload)的函数 //注意mutation中函数的第一个state参数是commit执行时传入的 this.mutations[type](this.state, arg); &#125;; dispatch(type, arg)&#123; this.actions[type](&#123;state: this.state, commit: this.commit&#125;, arg) ////this.commit可能有问题 &#125; handleGetters(getters)&#123; //getters为配置项中的getter，是一个对象 this.getters = &#123;&#125;; Object.keys(getters).forEach(key =&gt; &#123; //获取getter中的每一个属性 Object.defineProperty(this.getters, key, &#123; //为store.getters设置只读属性，key值与配置项相同 get: () =&gt; getters[key](this.state); //配置项getters中每一个属性值都是getter函数，直接返回执行结果 &#125;) &#125;) &#125;&#125;function install(_vue)&#123; Vue = _vue; Vue.mixin(&#123; beforeCreate()&#123; if(this.$options.store)&#123; Vue.prototype.$store = this.$options.store; &#125; &#125; &#125;)&#125;export default &#123;Store, install&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/tags/Vue/"},{"name":"Vuex","slug":"Vuex","permalink":"http://wzr1998.github.io/tags/Vuex/"},{"name":"源码","slug":"源码","permalink":"http://wzr1998.github.io/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"Vuex 基础语法学习","slug":"Vuex基础语法学习","date":"2018-10-05T04:29:15.000Z","updated":"2020-11-26T04:56:49.603Z","comments":true,"path":"posts/25eca50e/","link":"","permalink":"http://wzr1998.github.io/posts/25eca50e/","excerpt":"","text":"官网：https://vuex.vuejs.org/zh/ 此文档为项目随笔摘录片段 一、安装 npm安装： 1npm install vuex vue CLI安装： 1vue add vuex 二、store.js 12345678910111213141516171819202122232425262728293031323334import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex); //挂载vuexexport default new Vuex.Store(&#123; state: &#123; //存放全局数据文件 count : 1 &#125;, getters: &#123; //计算属性，对store中数据进行加工处理 //接收第一个参数为state，第二个参数为其他getters对象 money: (&#123;count&#125;, getters) =&gt; `$&#123;count&#125;元`, moreMoney: (&#123;count&#125;) =&gt; `$&#123;count*2&#125;元` &#125;, mutations: &#123; //更变数据，内部必须是同步函数 //第一个参数为state(注意不能解构赋值)，第二个参数为调用时传入的其他参数 addCount(state, arg)&#123; state.count++; &#125;, addCountPlus(state, arg)&#123; state.count+=2; &#125; &#125;, actions: &#123; //进行业务逻辑或异步操作，注意和promise/async/await配合 addCountAsync(&#123;state, commit&#125;, arg)&#123; return new Promise(resolve =&gt; &#123; setTimeout(()=&gt;&#123; if(state.count&lt;10)&#123; commit(&#x27;addCount&#x27;); resolve(true); &#125;else&#123; resolve(false); &#125; &#125;, 500) &#125;) &#125; &#125;&#125;) 三、使用 template： 12345678&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;doAddCount&quot;&gt;count+1：&lt;/button&gt; &lt;button @click=&quot;doAddCountAsync&quot;&gt;异步增加count：&lt;/button&gt; count：&#123;&#123;$store.state.count&#125;&#125; &lt;br/&gt; 金额：&#123;&#123;$store.getters.money&#125;&#125;，&#123;&#123;moreMoney&#125;&#125; &lt;/div&gt;&lt;/template&gt; Javascript： 1234567891011121314151617export default &#123; name: &#x27;app&#x27;, computed: &#123; moreMoney()&#123; return this.$store.getters.moreMoney; &#125;, &#125;, methods: &#123; doAddCount()&#123; this.$store.commit(&#x27;addCount&#x27;, 23333); //执行mutations中函数 &#125;, async doAddCountAsync()&#123; const atatus = await this.$store.dispatch(&#x27;addCountAsync&#x27;, 666); //执行actions中异步函数 console.log(atatus) &#125; &#125;&#125; 四、使用辅助函数 vuex中内置了四种辅助函数，调用后返回一个对象，为对应store属性或方法的映射，通常与扩展运算符同时使用 12345678910111213141516import &#123;mapState, mapGetters, mapMutations, mapActions&#125; from &#x27;vuex&#x27; export default &#123; name: &#x27;app&#x27;, computed: &#123; ...mapState([&#x27;count&#x27;]), ...mapGetters([&#x27;money&#x27;, &#x27;moreMoney&#x27;]) &#125;, methods: &#123; //将this.addCount(arg)映射为this.$store.commit(&#x27;addCount&#x27;, amount) ...mapMutations([&#x27;addCount&#x27;, &#x27;addCountPlus&#x27;]), ...mapActions([&#x27;addCountAsync&#x27;]), //映射名称不同时，辅助函数中传入对象 //将this.add(arg)映射为this.$store.commit(&#x27;addCount&#x27;, amount) ...mapMutations(&#123;add: &#x27;addCount&#x27;&#125;), &#125;&#125; 五、总结 配置 使用 辅助函数 存放数据 state store.state.xxx mapState([‘xxx’]) 计算属性 getters store.getters.xxx mapGetters([‘xxx’]) 更变数据 mutations store.commit(‘xxx’) mapMutations([‘xxx’]) 异步操作 actions store.dispatch(‘xxx’) mapActions([‘xxx’])","categories":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/tags/Vue/"},{"name":"Vuex","slug":"Vuex","permalink":"http://wzr1998.github.io/tags/Vuex/"}]},{"title":"Vue-router 核心原理实现","slug":"Vue-router-核心原理实现","date":"2018-09-30T04:29:15.000Z","updated":"2020-11-26T05:08:04.843Z","comments":true,"path":"posts/2c2ea706/","link":"","permalink":"http://wzr1998.github.io/posts/2c2ea706/","excerpt":"","text":"一、设计思路 实现插件 使用 Vue.use(Router) 方法添加插件，其内部调用 Render.install 方法， Render.install 方法内调用 Vue.mixin 方法混入，向Vue全局对象下添加 $route 属性 url变化监听(hash模式) 当载入页面和hash发生变化时获取 window.location.hash，利用Vue响应式原理实现重新渲染 路由配置解析（URL和组件的映射关系） 获取配置项中 path 和 template，形成映射 实现两个全局组件 router-link 和 router-view(根据URL动态渲染组件) 使用 Vue.component 方法创建全局组件，注意由于webpack环境下没有编译器，不能使用模板字符串 二、代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import Vue from &#x27;vue&#x27;import page1 from &#x27;./views/page1.vue&#x27;import page2 from &#x27;./views/page2.vue&#x27;class wzrRouter&#123; //hash模式 constructor(options)&#123; this.$options = options; this.routerMap = &#123;&#125;;//初始化routerMap //利用Vue数据响应式，内部托管一个data，data一旦变化则组件重新渲染 this.app = new Vue(&#123; data: &#123;current: &#x27;/&#x27;&#125; &#125;) &#125; init()&#123; this.bindEvent(); //监听URL变化 this.createRouterMap(this.$options);//解析路由，传入选项数据 this.initComponent();//实现两个组件 &#125; bindEvent()&#123;//注意bind this，不然this指向window window.addEventListener(&#x27;load&#x27;, this.onHashChange.bind(this)); window.addEventListener(&#x27;hashchange&#x27;, this.onHashChange.bind(this)); &#125; onHashChange()&#123;//获取hash值(slice把#去掉)，没有hash则设置默认值&#x27;/&#x27; this.app.current = window.location.hash.slice(1) || &#x27;/&#x27;; &#125; createRouterMap(options)&#123; options.routes.map(item =&gt; &#123; this.routerMap[item.path] = item.component; &#125;) &#125; initComponent()&#123; //创建标签：&lt;router-link to=&quot;/page1&quot;&gt;路由&lt;/router-link&gt;，目的创建a标签实现路由跳转 Vue.component(&#x27;router-link&#x27;, &#123; props: &#123;to: String&#125;, render(h)&#123;//运行在webpack打包环境下，没有编译器，不能使用template函数，不能使用字符串模板 //h函数(createElement)：h(tag, data, children) return h(&#x27;a&#x27;, &#123;attrs: &#123;href: `#$&#123;this.to&#125;`&#125;&#125;, [this.$slots.default]) //this.$slots.default内部为router-link标签下的子元素(文本节点) &#125; &#125;); //创建标签：&lt;router-view/&gt;，目的显示当前当前路径下对应的template Vue.component(&#x27;router-view&#x27;, &#123; render: h=&gt;&#123;//使用箭头函数因为不需要使用Vue实例，而需要使用Render(当前箭头函数内this指向render class) const comp = this.routerMap[this.app.current]; return h(comp) &#125; &#125;); &#125;&#125;wzrRouter.install = function(Vue)&#123; //Vue.use()方法添加组件内部调用的是组件的install函数，把vue构造函数传入其中 //Vue.mixin()：混入 Vue.mixin(&#123; beforeCreate()&#123; //在组件创建的生命周期内部一块执行 //this是当前vue实例(根组件) if(this.$options.router)&#123;//仅在根组件执行一次 Vue.prototype.$router = this.$options.router; this.$options.router.init(); &#125; &#125; &#125;)&#125;;Vue.use(wzrRouter);const router = new wzrRouter(&#123; routes: [ &#123;path: &#x27;/page1&#x27;, component: page1&#125;, &#123;path: &#x27;/page2&#x27;, component: page2&#125; ]&#125;);export default router","categories":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/tags/Vue/"},{"name":"Vue-Router","slug":"Vue-Router","permalink":"http://wzr1998.github.io/tags/Vue-Router/"},{"name":"源码","slug":"源码","permalink":"http://wzr1998.github.io/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"Vur-Router 路由守卫","slug":"Vur-router-路由守卫","date":"2018-09-25T04:29:15.000Z","updated":"2020-11-26T04:56:59.900Z","comments":true,"path":"posts/c60adf7a/","link":"","permalink":"http://wzr1998.github.io/posts/c60adf7a/","excerpt":"","text":"一、全局前置守卫 router.beforeEach 所有路由进行跳转之前都会经过这个函数 1234567//router.jsimport Router from &#x27;vue-router&#x27;const router = new Router(&#123; /* ... */ &#125;)router.beforeEach((to, from, next) =&gt; &#123; // ...&#125;)export default router to 和 from 都是路由对象，可根据 meta 属性判断用户状态，或根据 path / fullPath 属性判断用户所在位置 next 为一个函数，resolved管道中的下一个钩子 next() ：直接进行跳转 next('/xxx') 或 next(&#123;path: '/xxx', query: 'xxx'&#125;) ：跳转到一个不同的地址，中断当前导航，进行新的导航 next(false) ：中断当前导航 next(error) ：如果传入的是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。 注意：确保要调用 next 方法，否则钩子就不会被 resolved。 二、路由独享守卫 beforeEnter 12345const router = new VueRouter(&#123; routes: [ &#123;path: &#x27;/foo&#x27;, component: Foo, beforeEnter: (to, from, next) =&gt; &#123;&#125; &#125; ]&#125;) 三、全局解析守卫 router.beforeResolve 2.5.0+ 可以用 router.beforeResolve 注册一个全局守卫。这和 router.beforeEach 类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。 四、全局后置钩子 router.afterEach 这些钩子不会接受 next 函数也不会改变导航本身 用法：router.afterEach((to, from) =&gt; &#123;&#125;) 五、组件内的守卫 12345export default &#123; beforeRouteEnter (to, from, next) &#123;/* 不能使用this */&#125;, beforeRouteUpdate (to, from, next) &#123; &#125;, beforeRouteLeave (to, from, next) &#123; &#125;&#125; beforeRouteEnter(to, from, next){}：在渲染该组件的对应路由被 confirm 前调用，不能使用this，在当前守卫执行前，组件实例还没被创建。在 next 函数中传入回调函数可以访问组件实例： 123beforeRouteEnter (to, from, next) &#123; next(vm =&gt; &#123; /* 通过 `vm` 访问组件实例 */ &#125;)&#125; beforeRouteUpdate(to, from, next){}：在当前路由改变，但是该组件被复用时调用，可以使用this。例：router.js中配置路由为 'foo/:id' 则由 /foo/1 跳转到 /foo/2 时触发该函数。 beforeRouteLeave(to, from, next){}：导航离开该组件的对应路由时调用，可以访问组件实例 this，作用：禁止用户在特定状态(如未保存)离开 12345beforeRouteLeave (to, from , next) &#123; const answer = window.confirm(&#x27;未保存，是否离开？&#x27;); if (answer) next(); else next(false);&#125; 六、完整的导航解析流程 导航被触发。 在失活的组件里调用离开守卫。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。 在路由配置里调用 beforeEnter。 解析异步路由组件。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫 (2.5+)。 导航被确认。 调用全局的 afterEach 钩子。 触发 DOM 更新。 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/tags/Vue/"},{"name":"Vue-Router","slug":"Vue-Router","permalink":"http://wzr1998.github.io/tags/Vue-Router/"}]},{"title":"Vue-Router 视图组件","slug":"Vue-router-视图组件","date":"2018-09-22T04:29:15.000Z","updated":"2020-11-26T04:56:24.697Z","comments":true,"path":"posts/bcef7c06/","link":"","permalink":"http://wzr1998.github.io/posts/bcef7c06/","excerpt":"","text":"一、路由视图 1&lt;router-view/&gt; 注意：若出现嵌套路由，则在父识图组建内也要出现 &lt;router-view/&gt; 作为占位符显示子视图 二、路由跳转 1. 声明式跳转 1&lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt; 2. 编程式跳转 1234this.$router.push(&#x27;/user-admin&#x27;)//传参this.$router.push(&#123; name: &#x27;/user&#x27;, params: &#123; userId: &#x27;123&#x27; &#125;&#125;)this.$router.push(&#123; path: &#x27;/user&#x27;, query: &#123; userId: &#x27;123&#x27; &#125;&#125;) 注意：如果使用 params 传参，则必须使用 name ，不能使用 path， 并被解析为/name/:xxx 三、命名视图 在同一页面显示多个 &lt;router-view/&gt; 是，需要给不同视图窗口命名 1. 视图组件 123&lt;router-view&gt;&lt;/router-view&gt;&lt;router-view name=&quot;left&quot;&gt;&lt;/router-view&gt;&lt;router-view name=&quot;right&quot;&gt;&lt;/router-view&gt; 2. router.js配置 123routes: [ &#123;path: &#x27;/&#x27;, components: &#123;default: Foo, left: leftView, right: rightView &#125; &#125;] 原来的 component 变成 components，内部 default 为未命名组件，key 值为组件 name，value 为导入视图","categories":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/tags/Vue/"},{"name":"Vue-Router","slug":"Vue-Router","permalink":"http://wzr1998.github.io/tags/Vue-Router/"}]},{"title":"Vue-Router 及基础配置","slug":"Vue-router-及基础配置","date":"2018-09-20T04:29:15.000Z","updated":"2020-11-26T04:56:18.093Z","comments":true,"path":"posts/f88a72e9/","link":"","permalink":"http://wzr1998.github.io/posts/f88a72e9/","excerpt":"","text":"一、安装 npm安装：npm install vue-router vue-cli3安装：vue add router 二、router.js 1. router.js配置 123456789101112131415161718192021222324import Vue from &#x27;vue&#x27;import Router from &#x27;vue-router&#x27;import page1 from &#x27;./views/page1.vue&#x27;import page2 from &#x27;./views/page2.vue&#x27;Vue.use(Router);const router = new Router(&#123; mode: &#x27;history&#x27;, //模式：history / hash 两种 base: process.env.BASE_URL, routes: [ &#123;path: &#x27;/redirect&#x27;, redirect: &#x27;/&#x27;&#125;, &#123;path: &#x27;/page1&#x27;, component: page1, props: &#123;aaa: 233&#125;&#125;, &#123;path: &#x27;/page2/:msg&#x27;, name: &#x27;page2&#x27;, component: page2, props: true&#125; ]&#125;);router.beforeEach((to, from, next)=&gt;&#123; //全局路由守卫 //console.log(to); //console.log(from); next();&#125;);export default router 2. 挂载vue Router 12345// main.jsnew Vue(&#123; router, render: h =&gt; h(App)&#125;).$mount(&#x27;#app&#x27;) 3. 嵌套路由 1234567&#123; path: &quot;/home&quot;, component: Home, children: [ &#123; path: &quot;/list&quot;, name: &quot;list&quot;, component: List &#125; ]&#125; 4. 动态路由匹配 (1). 动态路由传参 1&#123;path: &#x27;/page2/:msg&#x27;, name: &#x27;page2&#x27;, component: page2, props: true&#125; 方式：路由内部 /:xxx 视图中通过 this.$route.params.msg接收参数 设置props: true可以在视图组建内部使用 props 接收参数 (2). 匹配任意路由 1&#123;path: &#x27;*&#x27;, name: &#x27;notFound&#x27;, component: notFound &#125; 5. Router重定向 12&#123;path: &#x27;/redirect&#x27;, redirect: &#x27;/&#x27;&#125; //redirect 后为重定向路由地址&#123;path: &#x27;/a&#x27;, redirect: &#123; name: &#x27;foo&#x27; &#125;&#125; //redirect 后为路由组建name 三、路由对象 1. 出现位置 组建内 this.$router 在 $route 观察者回调内 router.match(location) 返回值 路由守卫参数 router.beforeEach( (to, from, next) =&gt; &#123;&#125; ) // `to` 和 `from` 都是路由对象 &lt;!--code￼6--&gt; 2. 路由对象下获取 12$router.meta.id 3. 路由守卫中获取：通常用于校验用户状态(如判断是否登录) 123456789101112131415const router = new VueRouter(&#123; routes&#125;);router.beforeEach((to, from, next) =&gt; &#123; if(to.matched.some(current =&gt; current.meta.needLogin))&#123; //判断路由记录是否需要验证登录 const isLogin = getLoginStatus(); //自己定义的判断登录的方法 //未登录则跳转到登录页，query保存客户是从哪来的，，方便登录成功后回到原页面 if(!isLogin) next(&#123;path: &#x27;/login&#x27;, query: &#123;redirect: to.fullPath&#125; &#125;); //已登录则直接跳转 else next(); &#125; else &#123; //没有需要登录的页面则直接跳转 next(); &#125;&#125;);","categories":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/tags/Vue/"},{"name":"Vue-Router","slug":"Vue-Router","permalink":"http://wzr1998.github.io/tags/Vue-Router/"}]},{"title":"vue 基础之vue-router、vuex、vue-resource","slug":"vue-基础之vue-router、vuex、vue-resource","date":"2018-09-17T04:29:15.000Z","updated":"2020-12-01T12:38:43.273Z","comments":true,"path":"posts/b996d0c1/","link":"","permalink":"http://wzr1998.github.io/posts/b996d0c1/","excerpt":"","text":"一、vue-router 1. 安装： vue-cli2.0：npm install vue-router vue-cli3.0：npm add router 2. router-link 标签跳转 (1). 跳转页面 1&lt;router-link to=&quot;/demo1&quot;&gt;demo1&lt;/router-link&gt; 其中to后写router-index.js中配置的路由，to后跟的就是url域名下实际的路径 (2). 跳转时传递参数 1&lt;router-link :to=&quot;&#123;name:&#x27;demo2&#x27;, params:&#123;userName:123&#125;, query:&#123;id:1&#125; &#125;&quot;&gt;demo2&lt;/router-link&gt; 其中name为路由js中命名的name值，params和query为传递的参数，后边接一个对象 设置params传递参数后，路由文件需对应配置：path: '/demo2/:userName’，其中”:”代表不确定，”:”后边跟传递params中传递的参数名 传递的params与路由中配置的params必须对应 3. 编程式导航跳转 更改 this.$router 对象实现路由调转 普通跳转： this.$router.push({ path: ‘/demo1’}) 传递参数： this.$router.push({ name: ‘demo9’, params: { userId: 123 }, query: { plan: ‘private’ } }) 4. 被跳转页面接收参数 每个模块this.$route下保存自身的路由信息 this.$route.params 和 this.$route.query 下保存原页面传递的参数对象 二、vuex 1. 安装 1npm install vuex --save 2. 使用 @/store/index.js 路径下存储 vuex 数据 vuex 数据存放 1234567891011121314151617181920// vuex 数据存放import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex);export default new Vuex.Store(&#123; state:&#123; //存放共享数据 count:0, num :1 &#125;; mutations:&#123; increment(state, num)&#123; //修改stats数据 state.count++; state.num = num; &#125;&#125;,actions:&#123; inc(&#123;commit&#125;, obj)&#123; commit(&#x27;increment&#x27;, obj); //调用mutations里边的方法 &#125;&#125;) 使用 vuex 公共数据 1234//读取vuex公共数据this.$store.state.count;//修改vuex公共数据this.$store.dispatch(&#x27;inc&#x27;, 10000); 注意： this.$store.dispatch 方法先调用vuex应用中action方法，再调用mutations方法 三、vue-resource 1. 安装 1npm install vue-resource --save 2. 配置 路径 @/main.js： 12import VueResource from &#x27;vue-resource&#x27;Vue.use(VueResource); 3. get 请求 123456this.$http.get(&#x27;/someUrl&#x27;, &#123;params:&#123;foo:&#x27;bar&#x27;&#125;, headers:&#123;&#x27;X-Custom&#x27;:&#x27;...&#x27;&#125;&#125;) .then(response =&gt; &#123; // success callback &#125;, response =&gt; &#123; // error callback &#125;); 4. post 请求 1234567this.$http.post(&#x27;/someUrl&#x27;, &#123;foo: &#x27;bar&#x27;&#125;) .then(response =&gt; &#123; // success callback &#125;, response =&gt; &#123; // error callback &#125;);","categories":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/tags/Vue/"},{"name":"Vue-Router","slug":"Vue-Router","permalink":"http://wzr1998.github.io/tags/Vue-Router/"},{"name":"Vuex","slug":"Vuex","permalink":"http://wzr1998.github.io/tags/Vuex/"}]},{"title":"Vue DOM 操作与过渡效果","slug":"vue-DOM-操作与过渡效果","date":"2018-09-14T04:29:15.000Z","updated":"2020-11-26T04:56:15.316Z","comments":true,"path":"posts/b0cd6acd/","link":"","permalink":"http://wzr1998.github.io/posts/b0cd6acd/","excerpt":"","text":"一、vue中的DOM操作 1. 原则 vue 是虚拟 DOM，只能在 mounted 生命周期函数中进行DOM操作（此时DOM已经生成） 2. ref / this.refs 在 template 中绑定：&lt;h1 ref=&quot;head&quot;&gt;标题一&lt;/h1&gt; 修改样式：mounted生命周期函数中通过 this.refs.head 找到真实DOM，可以进行DOM操作 二、过渡效果 1. transition 模板中通过标签引入： 123&lt;transition name=&quot;fade&quot;&gt; &lt;span v-if=&quot;show&quot;&gt;hello&lt;/span&gt;&lt;/transition&gt; 2. 状态 vue 过度样式中有三种状态，会以样式的方式进行调用；enter-to和leave两个状态opacity默认为1，可以省略 显示(opacity:0→1)：enter → enter-active → enter-to 隐藏(opacity:1→0)：leave → leave-active → leave-to 3. style 中处理样式 123456.fades-enter-active, .fades-leave-active &#123; transition: opacity .5s&#125;.fades-enter, .fades-leave-to &#123; opacity: 0&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/tags/Vue/"}]},{"title":"Vue 事件处理器与自定义组件","slug":"vue-事件处理器与自定义组件","date":"2018-09-12T04:29:15.000Z","updated":"2020-11-26T04:56:27.688Z","comments":true,"path":"posts/1c9e44ab/","link":"","permalink":"http://wzr1998.github.io/posts/1c9e44ab/","excerpt":"","text":"一、事件处理器 1. 绑定方法 v-on:event=“fn” @event=“fn” 12&lt;div v-on:click=&quot;num++&quot;&gt;点击次数：&#123;&#123;num&#125;&#125;&lt;/div&gt;&lt;div @click=&quot;clickFn(&#x27;clertText&#x27;)&quot;&gt;点击弹出警告框&lt;/div&gt; 2. 事件修饰符 (1). 事件相关 .stop：阻止事件冒泡 .prevent：阻止默认事件 .capture：阻止事件捕获 .self：只在对象自身事件触发(内部判断target事件源) .once：事件只出发一次 (2). 按键修饰符 .num：num为键值，当按下该按键时触发 .enter /.tab / .delete / .esc / .space：按下enter / tab / delete / esc / 空格时触发 .up / .down /.left / .right：按下上/下/左/右时触发 3. 注意 v-on:event方法绑定事件内参数为函数名，可以加括号传递参数 事件处理器中绑定的函数要在选项数据methods对象中定义 传递参数时需要使用事件对象，需要在传参时手从传入event参数，即Fn(event, obj) Vue中建议事件处理函数中只有纯粹的事件逻辑，而不去处理事件细节 二、自定义组件 1. 创建自定义组件 创建 childComponent.vue 子组件 12345678910111213&lt;component&gt; &lt;span&gt;我今早吃了&#123;&#123;food&#125;&#125;&lt;/span&gt;&lt;/component&gt;&lt;script&gt;module.export = &#123; data: function()&#123; return: &#123; food: &quot;包子&quot; &#125; &#125;&#125;&lt;/script&gt; 2. 父组件引入子组件 导入：import child from ‘@/components/childComponent.vue’ 注册：components : { child } 使用：&lt;child&gt;&lt;/child&gt; 通过标签方式使用 3. 父子组件通信 (1). 父组件通过 props 向子组件传递数据 父组件传递数据： 1&lt;component attr=&quot;blue&quot;&gt;&lt;/component&gt; 子组件中接收数据： 123456789//写法一：props : &#123; attr : &#123; type : String, default : ‘#000’ &#125;&#125;//写法二：props : &#123; arr : Array &#125; (2). $emit自定义事件 子组件函数中使用：this.$emit('customEvent', arg) ，customEvent为自定义事件的事件名，满足条件直接调用 父组件中：&lt;component @customEvent =&quot;fn&quot;&gt;&lt;/component&gt; ，把父组件中函数传入子组件 4. slot 插槽 父组件调用子组件时，通过slot插槽向子组件插入内容。父组件中默认子组件标签内元素全部加入到第一个slot元素中，可通过父组件中slot属性把元素加入到子组件中对应位置 子组件： 1234&lt;component&gt; &lt;slot&gt;&lt;/slot&gt; &lt;slot name=&quot;four&quot;&gt;&lt;/slot&gt;&lt;/component&gt; 父组件 123456&lt;component1&gt; &lt;p&gt;111&lt;/p&gt; &lt;p&gt;222&lt;/p&gt; &lt;p&gt;333&lt;/p&gt; &lt;p slot=&quot;four&quot;&gt;444&lt;/p&gt;&lt;/component1&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/tags/Vue/"}]},{"title":"Vue 指令、动态绑定、条件渲染、列表渲染","slug":"vue-指令、动态绑定、条件渲染、列表渲染","date":"2018-09-08T04:29:15.000Z","updated":"2020-11-26T04:56:37.000Z","comments":true,"path":"posts/8583cbf9/","link":"","permalink":"http://wzr1998.github.io/posts/8583cbf9/","excerpt":"","text":"一、指令 1. v-html 把该标签绑定的变量数据内容变成其子元素 指令： v-html：把该标签绑定的变量数据内容变成其子元素 1&lt;div v-html=&quot;innerDOM&quot;&gt;&lt;/div&gt; 注意：插入的html代码必须是可靠的，如果代码中发生错误(如引入一张不存在的图片)，会触发onerror事件，用户可能会在事件中其中窃取数据 2. v-bind 动态绑定元素属性 1&lt;div v-bind:title=&quot;title&quot;&gt;&#123;&#123;`title修改为&quot;$&#123;title&#125;&quot;`&#125;&#125;&lt;/div&gt; 注：v-bind:后边的title为参数，被称为预期值，支持单一js表达式和执行函数 3. v-model 表单控件双向数据绑定 v-model的值可以为字符串或数组（复选框使用），可以把选中元素的value值保存在v-model后变量中，根据元素不同类型，vue会选择属性进行绑定 适用范围：文本框、单选框、复选框、选择框等 注意：元素上写了v-model，再写value等属性无效 3. v-on 绑定事件，与@fn相同 1&lt;div v-on:mouseover=&quot;show(&#x27;hello~&#x27;)&quot;&gt;鼠标移入事件&lt;/div&gt; 4. v-clock 改变(通常为隐藏)未编译的Mustache标签(双大括号)样式，直到实例准备完毕， css中使用属性选择器选择：[v-clock] : {display : none; } 5. v-once 只渲染一次，随后数据变化将不会进行动态渲染，视为静态内容，用于提高更新性能 二、动态绑定 通过 v-bind 指令动态绑定一个或多个特性 1. class 绑定 写法：v-bind:class=... ，可缩写为 :class v-bind:class = “{ ‘class1’ : booleanVar1, ‘class2’ : booleanVar2 }” v-bind:class=“classObject” //其中classObject格式与第一种相同 v-bind:class=&quot;[ activeClass, errorClass ]&quot; //只能通过下方数据动态更改，不能选择是否存在 2. style 绑定 写法：v-bind:style... ，可缩写为 :style 通过 style 对象绑定 &lt;div v-bind:style=&quot;&#123;color: activeColor, fontSize: fontSize + 'px' &#125;&quot;/&gt; 可以为多个样式对象构成的数组 &lt;div v-bind:style=&quot;[styleObj1, styleObj2]&quot;/&gt; 提供一个包含多个值的数组，常用于提供多个带前缀的值，例如： &lt;div :style=&quot;&#123; display: ['-webkit-box', '-ms-flexbox', 'flex'] &#125;&quot;&gt;&lt;/div&gt; 二、条件渲染 1. v-if 系列指令 1234&lt;div v-if=“ char===‘A’ ”&gt; A &lt;/div&gt;&lt;div v-else-if=“ char===‘B’ ”&gt; B &lt;/div&gt;&lt;div v-else-if=“ char===‘C’ ”&gt; C &lt;/div&gt;&lt;div v-else”&gt; not A/B/C &lt;/div&gt; 2. v-show 指令 通过布尔值显示或隐藏元素节点 1&lt;div v-show=&quot;showBollean&quot;&gt;v-show属性值为：&#123;&#123;showBollean&#125;&#125;&lt;/div&gt; 3. v-if 和 v-show 的区别 v-if=“false”：将整个元素节点删除（不进行渲染） v-show=“false”：通过行内display : none使元素隐藏，dom元素还在 4. 如何选择 v-if：进入页面时，根据某一值判断某渲染元素或移除元素 v-show：某一元素频繁切换显示隐藏 三、列表渲染 1. 数组 12&lt;li v-for=&quot;item in arr&quot;&gt;&#123;&#123;item.value&#125;&#125;&lt;/li&gt;&lt;li v-for=&quot;(item, index) in arr&quot;&gt;&#123;&#123;index + &#x27;、&#x27; + item.value&#125;&#125;&lt;/li&gt; 2. 对象 vue 底层使用 Object.values 和 Object.keys 实现 12&lt;li v-for=&quot;value in obj&quot;&gt;&#123;&#123;value&#125;&#125;&lt;/li&gt;&lt;li v-for=&quot;(value, key, index) in obj&quot;&gt;&#123;&#123;key + &#x27;：&#x27; + value&#125;&#125;&lt;/li&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/tags/Vue/"}]},{"title":"Vue 选项数据与响应式变化","slug":"vue-选项数据与响应式变化","date":"2018-09-04T04:29:15.000Z","updated":"2020-11-26T04:56:40.300Z","comments":true,"path":"posts/9ee9222c/","link":"","permalink":"http://wzr1998.github.io/posts/9ee9222c/","excerpt":"","text":"一、选项数据 1. data 模板文件暴露对象中data函数为组件全局变量的定义，返回一个对象，内部为模板内部的变量值，变量在模板中用双大括号包起来 为未在data中注册的数据添加可动态响应的属性值 this.obj = Object.assign( {}, this.obj, {value : ‘新添加的属性’} ) 全局Vue静态方法：Vue.set(target, prop, value) 调用Vue实例方法：vm.$set(target, prop, value) 重新赋值 2. computed 计算属性 模板文件暴露对象中computed为一个对象，内部定义函数，同样可以在模版中用双大括号包起来，定义在computed中但不是方法，属性的值是函数的返回值 (1). 作用 把处理数据的逻辑抽离在计算属性中，使得模板更加轻量易读 (2). 注意 计算属性会把计算结果缓存，可在模板中重复使用 计算属性中依赖了data中的数据，data中的数据发生变化，计算属性会重新计算 (3). get/set computed中函数默认为取值函数(get)，想向其中存值则需定义改属性为一个对象，其中分别有get函数和set函数（函数名固定） 3. methods 方法 vue暴露对象中methods为一个对象，内部定义事件函数 在模板节点中行内’@+事件名’（没有on）或v-on:+事件名调用 例：&lt;div @mouseover=&quot;show('hello~')&quot;&gt;&#123;&#123;`$&#123;fn&#125;!!`&#125;&#125;&lt;/div&gt; methods中方法的this指向vue的vm对象（或组件） 方法内部 event.target 指向触发事件的元素 4. filters 过滤器函数 与methods类似同为对象，内部写过滤器方法 二、响应式变化 vue在model层数据变化时，view视图层会同时变化。只有在data中计划好的数据，才能做相应reactive 1. 对象的响应式数据变化 给data中定义的对象动态添加可响应式变化的新属性 this.obj = Object.assign( {}, this.obj, {value : ‘新添加的属性’} ) 全局Vue静态方法：Vue.set(target, prop, value) Vue实例方法：vm.$set(target, prop, value) 重新赋值 删除对象属性：与添加相同，换成delete方法 如：vm.$delete(obj, key) 2. 数组的响应式数据变化 vue中数组方法都是变异方法，在中途进行数据劫持，转化为setter/getter 不能通过vue对象中数组下标改变数组中某项的值（不能利用索引修改数组）；length属性不能动态改变数组结构 修改方法：通过变异数组 this.arr.splice(index, 1, newValue)、push()、pop()、shift()、unshift()、splice()、sort()、reverse() 原理：以上数组方法会改变数组结构，并返回一个新数组 3. 响应式数据绑定原理 把一个普通的JavaScript对象传给Vue实例的data选项，Vue将遍历此对象的所有属性，并使用 Object.neProperty函数把这些属性全部转化为 getter/setter Vue内部会对数据进行劫持操作，进行追踪依赖，在属性被访问和修改是通知变化 Object.defineProperty()： 作用：在一个对象上定义一个新属性，或修改已有的属性 语法：Object.defineProperty(obj, prop, descriptor) 描述对象： configurable：是否可以删除目标属性，默认为false enumerate：此属性是否可以被枚举，默认为false value：该属性对应的值，默认为undefined writable：属性是否可以被重写，默认为false 访问器描述： getter：获得属性值的方法，获得该方法返回的内容 setter：设置属性值的方法，接收一参数，为该属性新设置的值 可以写configurable、enumerate 不能写value、writable 12345678910111213141516function observer(obj)&#123; Object.keys(obj).forEach((item) =&gt; &#123; defineReactive(obj, item, obj[item]) &#125;) &#125;function defineReactive(obj, key, value)&#123; Object.defineProperty(obj, key, &#123; get()&#123; return value; &#125;, set(newValue)&#123; value = newValue; //观察者模式更新模板 &#125; &#125;)&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/tags/Vue/"}]},{"title":"Vue 安装及简单介绍","slug":"Vue-安装及简单介绍","date":"2018-09-01T04:29:15.000Z","updated":"2020-11-26T04:56:06.117Z","comments":true,"path":"posts/91829f59/","link":"","permalink":"http://wzr1998.github.io/posts/91829f59/","excerpt":"","text":"一、安装 1. 安装 cnpm 淘宝镜像 1npm install -g cnpm --registry=https://registry.npm.taobao.org 2. 安装vue 全局安装vue-cli 1sudo cnpm install --global vue-cli 创建一个基于 webpack 模板的新项目 1234vue init webpack my-projectcd my-projectcnpm installnpm run dev 3. 安装vue-cli3.0： 安装vue-cli3.0：npm install -g @vue/cli 创建vue项目：vue create projectName 全局安装运行单独vue文件环境：npm install -g @vue/cli-service-global 全局运行单独vue文件：vue serve xxx.vue/xxx.html 解决只有只读权限问题：sudo chown -R username 文件路径 （消除只读权限，可写） 二、vue 简单介绍 1. vue 生命周期 beforeCreate：组件刚刚被创建 created：组件创建完成 beforeMount：挂载之前 mounted：挂载之后 beforeDestroy：组件销毁前调用 destroyed：组件销毁后调用 2. vue 路由 路由文件：src→router→index.js index.js文件上方引入import模块文件，文件路径中“@”表示src文件夹 index.js问价下方配置路由：path/name/component 3. vue 模块文件： (1). template 模板 123&lt;template&gt; &lt;div&gt; demo &lt;/div&gt;&lt;/template&gt; 注意：template标签内只能有一个div (2). &lt;script&gt; 数据 12345678910&lt;script&gt; export default &#123; name: &#x27;app&#x27;, data()&#123; return&#123; //... &#125; &#125; &#125;&lt;/script&gt; 内部 export default 一个对象，其中有 data 函数和生命周期函数等 (3). CSS 样式 正常写，与 HTML 相同 4. HTML 文件引入 vue.js： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;span&gt;&#123;&#123;text&#125;&#125;&lt;/span&gt; &lt;Button @click=&quot;clickFn&quot;&gt;点击一下～&lt;/Button&gt; &lt;/div&gt;&lt;/body&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: function() &#123; return &#123; text: &#x27;我的第一个页面&#x27; &#125; &#125;, methods:&#123; clickFn()&#123; alert(&quot;突然，弹出一个窗口！&quot;) &#125; &#125; &#125;) &lt;/script&gt;&lt;/html&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/tags/Vue/"}]},{"title":"git 常用指令","slug":"git-常用指令","date":"2018-07-15T04:23:57.000Z","updated":"2020-12-01T12:34:39.560Z","comments":true,"path":"posts/c990b323/","link":"","permalink":"http://wzr1998.github.io/posts/c990b323/","excerpt":"","text":"一、下载、设置信息、查看 git 状态 1. 下载远程仓库代码 1git clone https://github.com/wzr1998/protect.git 2. 设置贡献者信息 config --global user.name / user.email | config --list 12git config --global user.name “wzr”git config --global user.email “2538064593@qq.com” 3. 查看git状态 git status 二、添加 add/commit git 的三个区：工作区 → 暂存区 → 版本区 1. 工作区 → 暂存区 添加单个文件：git add index.html 添加全部有更改的文件：git add . 2. 暂存区 → 版本区 git commit，之后弹出vim格式文本，在上方加入注释信息→按exc退出编辑，:wq保存并推出 快捷上传全部暂存区文件 ：git commit -m “description information” 3. 工作区 → 暂存区 → 版本区 1git commit -a -g &quot;description information&quot; 三、查看 log/reflog 查看提交历史：git log 查看所有操作(包括已删除的)：git reflog 四、对比 diff 工作区 ↔ 暂存区： git diff 暂存区 ↔ 版本区： git diff – cached 工作区 ↔ 版本区： git diff master 五、撤销 reset/checkout 撤销暂存区内容： git reset HEAD index.html 将工作区内容还原成版本区： git checkout – index.html 撤销上次提交内容并重新提交： git commit -m “description information” --amend 六、删除 rm 工作区没有文件时删除暂存区： git rm index.html 同时删除工作区和暂存区文件： git rm -f index.html 只删除暂存区文件： git rm -cached index.html 七、恢复 1.查看日志 1git reflog 2. 恢复 恢复单个文件： git checkout 56aec5304b13d85e5e01e60528(commit_id) index.html 恢复到版本区： git reset --hard 56aec5304b13d85e5e01e60528(commit_id) 恢复到上个版本区： git reset --hard HEAD^ 恢复到前n个版本区： git reset --hard HEAD~n（注：HEAD相当于一个指针，指向当前版本区状态） 恢复已删除的文件： 先用git reflog查看以前的commit_id，然后使用git reset —hard commit_id恢复 八、同步 显示仓库名称： git remote（默认为origin） 显示仓库网址： git remote -v 同步到远程仓库： git push origin master（push后跟远端仓库名字和分支名字） 九、处理冲突 1. 手动合并 同步远程代码： git fetch 查看远程冲突代码： git diff master origin/master 合并远端冲突代码： git merge origin/master 2. 自动合并 1git pull 十、分支 查看分支： git branch 创建分支： git branch new（new为新分支名） 删除分支： git branch -d new（没有合并的分支不能直接删除） 切换分支： git checkout new（new为已有分支） 创建并切换到新分支： git checkout -b new1 其它分支合并到master： git merge new（如果合并时有冲突则会在文件中显示冲突） 查看以合并到master的分支： git branch --merged 查看未合并到master的分支： git branch —no-merged 上传新分支到远端git： git push origin new 十一、标签 添加标签：git tag 0.0.1 标签同步到远程GitHub：git push origin 0.0.1 //0.0.1为以添加的版本号 十二、思维导图 git思维导图","categories":[{"name":"git","slug":"git","permalink":"http://wzr1998.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://wzr1998.github.io/tags/git/"}]},{"title":"mongoDB 简单使用记录","slug":"mongoDB-简单使用记录","date":"2018-07-14T04:21:58.000Z","updated":"2020-11-26T05:13:48.817Z","comments":true,"path":"posts/ab2646c9/","link":"","permalink":"http://wzr1998.github.io/posts/ab2646c9/","excerpt":"","text":"1234567891011121314151617181920const mongodb = require(&#x27;mongodb&#x27;);const MongoClient = require(&#x27;mongodb&#x27;).MongoClient;MongoClient.connect(&quot;mongodb://localhost:27017&quot;, &#123; useNewUrlParser: true &#125;, function(err, client)&#123; assert.equal(null, err); console.log(&quot;Connected successfully to server&quot;); let db = client.db(&#x27;test&#x27;); let collection = db.collection(&#x27;wzrs&#x27;); //插入：collection.insertMany( [ &#123;&#125;, &#123;&#125;, &#123;&#125; ] , callback(err, result)&#123;&#125; ); collection.insertOne(&#123;&quot;name&quot;:&quot;wwzzrr4&quot;&#125;); collection.insertMany([&#123;&quot;name&quot;:&quot;wwzzrr1&quot;&#125;,&#123;&quot;name&quot;:&quot;wwzzrr2&quot;&#125;,&#123;&quot;name&quot;:&quot;wwzzrr3&quot;&#125;]); //查找,过滤：collcetion.find(&#123;filterKey:value&#125;).toArray( callback(err, docs)&#123;&#125; ) (docs是一个存放查找结果的数组) collection.find(&#123;&quot;name&quot;:&quot;wwzzrr2&quot;&#125;).toArray(function(err, docs)&#123; console.log(docs, Object.prototype.toString.call(docs)); &#125;); //更新：collection.updateMany( &#123;filterKey:value&#125;, &#123;$set:&#123;newKey:newValue&#125;&#125;, callback(err, result)&#123;&#125; ); collection.updateMany(&#123;&quot;name&quot; : &quot;wwzzrr1&quot;&#125;, &#123;$set : &#123;&quot;name&quot;:&quot;wwzzrr5&quot;&#125;&#125; ); //删除：collection.deleteMany(&#123;filterKey:value&#125;, callback(err, result)&#123;&#125; ); collection.deleteMany(&#123;&quot;name&quot;:&quot;wwzzrr3&quot;&#125;); client.close();&#125;);","categories":[{"name":"数据库","slug":"数据库","permalink":"http://wzr1998.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://wzr1998.github.io/tags/Node-js/"},{"name":"数据库","slug":"数据库","permalink":"http://wzr1998.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://wzr1998.github.io/tags/MongoDB/"}]},{"title":"Node.js HTTP模块与客户端交互","slug":"Node-js-HTTP模块与客户端交互","date":"2018-07-10T04:21:58.000Z","updated":"2020-11-26T04:22:50.564Z","comments":true,"path":"posts/13b1eb9d/","link":"","permalink":"http://wzr1998.github.io/posts/13b1eb9d/","excerpt":"","text":"1. 引入http模块 1const http = require(&#x27;http&#x27;); 2. 创建web服务器对象 1const server = http.createServer([options] [, requestListener]); requestListener为request事件监听函数，参数为接收请求和相应(request, response) =&gt; {} 3. 监听端口 1server.listen([port[, host[, backlog]]] [, callback]) 启动一个 server 监听，callback是listening事件的处理函数 4. socket.address() 返回操作系统报告的 socket 的地址、地址族和端口 5. http.IncomingMessage类 由 http.Server 或 http.ClientRequest 创建，并作为第一个参数分别递给 request 和 response 事件。它可以用来访问响应状态、消息头、以及数据 message.headers：请求头或响应头的对象，头信息的名称与值的键值对。 头信息的名称为小写 message.httpVersion：在服务器请求中，该属性返回客户端发送的 HTTP 版本。 在客户端响应中，该属性返回连接到的服务器的 HTTP 版本 message.method：返回一个字符串，表示请求的方法。该属性只读。例如：‘GET’、‘DELETE’ message.url：返回请求的URL字符串，使用require(‘url’).parse(request.url)可将url解析成各个部分，使用require(‘url’).parse(request.url, true)可将url解析成各个部分 6. http.ServerResponse 类 response.write(chunk[, encoding] [, callback])：会发送一块响应主体，它可被多次调用，以便提供连续的响应主体片段，写入数据chunk类型为&lt;string&gt;或&lt;Buffer&gt; response.end([data] [, encoding] [, callback])：结束发送响应头和响应主体，即服务器将其视为已完成。每次响应都必须调用response.end()方法，如果指定了data，则相当于调用 response.write(data, encoding)之后再调用response.end(callback) response.writeHead(statusCode[, statusMessage] [, headers])：发送一个响应头给请求。如404。最后一个参数headers是响应头。第二个参数一般不用写， 例： 1res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/plain; charset=utf-8&#x27; &#125;); response.setHeader(name, value)：为一个隐式的响应头设置值。 如果该响应头已存在，则值会被覆盖。 如果要发送多个名称相同的响应头，则使用字符串数组。 7. 接收get请求数据 1234var urlStr = url.parse( req.url );let data = querystring.parse(urlStr.query);let Query = url.parse(req.url, true).query;//url.parse()第二个参数为true时可以直接把query部分解析成对象(内部调用querystring.parse()方法) 8. 接收post请求数据 post 请求数据量大，通过监听 on 事件接收分块数据包，结束是监听 end 事件，将数据包整合并解析 1234567var data = &#x27;&#x27;;req.on(&#x27;data&#x27;, function(chunk) &#123; str += chunk;&#125;)req.on(&#x27;end&#x27;, function() &#123; console.log(querystring.parse(str));&#125;)","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://wzr1998.github.io/categories/Node-js/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"Node.js","slug":"Node-js","permalink":"http://wzr1998.github.io/tags/Node-js/"}]},{"title":"Node.js Buffer and FileSystem","slug":"Node-js-Buffer-and-FileSystem","date":"2018-07-05T04:21:26.000Z","updated":"2020-11-26T04:23:07.653Z","comments":true,"path":"posts/83166f8f/","link":"","permalink":"http://wzr1998.github.io/posts/83166f8f/","excerpt":"","text":"一、Buffer 1. 创建Buffer对象 Buffer.from(array)：通过array创建一个新的Buffer ​ 例：Buffer.from([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]) Buffer.from(buffer)：将传入的buffer数据拷贝到一个新建的Buffer实例。 Buffer.from(string[, encoding])：新建一个包含所给的JavaScript字符串string的Buffer，encoding参数指定string的字符编码。 Buffer.alloc(size[, fill[, encoding]])，参数分别为长度，预填充的值( &lt;string&gt; | &lt;Buffer&gt; | &lt;integer&gt; )，字符编码( 默认: 'utf8’ ) Buffer.allocUnsafe(size)：创建长度为size的buffer对象，内容未初始化，可能包含敏感数据，但性能更好 注：所有Buffer对象创建后长度固定，不能扩增 2. Buffer类方法 Buffer.isEncoding(encoding)：判断是否支持某种编码格式 Buffer.isBuffer(obj)：检测对象是否为Buffer类型 Buffer.compare(buf1, buf2)：比较buf1和buf2，通常用于Buffer实例数组的排序，相当于调用buf1.compare(buf2)，返回-1/0/1 Buffer.byteLength(string[, encoding])：返回一个字符串的实际字节长度，编码默认utf8 3. Buffer对象下的方法 buf.write(string[, offset[, length]] [, encoding])：根据encoding的字符编码写入string到 buffer中的offset位置。 length 参数是写入的字节数。 如果buf没有足够的空间保存整个字符串，则只会写入 string 的一部分，只部分解码的字符不会被写入。 buf.toString([encoding[, start[, end]]])：根据 encoding 指定的字符编码解码 buf 成一个字符串。 start 和 end 可传入用于只解码 buf 的一部分。 buf.toJSON()；返回type=‘Buffer’，data为十进制buffer内容的数组的对象 buf.slice([start[, end]])：返回一个指向相同原始内存的新建的Buffer切片(有改动老的也会改)，但做了偏移且通过 start 和 end 索引进行裁剪 buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])：拷贝新的buffer对象 二、FileSystem 1. 打开 fs.open(path, flags[, mode], (err, fd) =&gt; {} )：异步地打开文件，参数为文件路径、打开方式(读/写/追加)、文件模式 fs.openSync(path, flags[, mode])：fs.open()的同步版本，返回一个表示文件描述符的整数(fd) 2. 监视 fs.watch(filename[, options] [, (eventType, filename) =&gt; {} ])：监视filename的变化，filename可以是一个文件或一个目录(文件夹)，返回的对象是一个fs.FSWatcher fs.watchFile(filename[, options], (current, previous) =&gt; {} )：监视filename的变化，每次访问文件时调用回调函数，回掉中参数为两个fs.Stats对象 3. 读 fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) =&gt; {} ) fd：文件中读取数据 buffer：数据将被写入到的buffer offset：buffer中开始写入的偏移量 length：指定要读取的字节数 position：从文件中开始读取的位置 回掉 fs.readSync(fd, buffer, offset, length, position)：fs.read()的同步版本 fs.readFile(path[, options], (err, data) =&gt; {} )：异步地读取一个文件的全部内容，如果未指定字符编码，则返回原始的buffer，如果options是一个字符串(如utf8)，则它指定了字符编码 fs.readFileSync(path[, options])：fs.readFile()的同步版本 fs.stat(path[, options], (err, fs.stats) =&gt; {} )：读取文件信息，回掉函数中参数返回fs.stats fs.statSync(path[, options])：fs.stat()的同步版本，返回fs.stats 4. 写 fs.write(fd, buffer[, offset[, length[, position]]], (err, bytesWritten, buffer) =&gt; {}) fd：指定的文件 buffer：写入的buffer数据 offset：buffer中写入的起始位置 length：写入的字节数 position：文件写入数据的位置的偏移量(起始位置) 回掉 fs.writeSync(fd, buffer[, offset[, length[, position]]]) fs.write(fd, string[, position[, encoding]], (err, written, string) =&gt; {} ) fs.writeSync(fd, string[, position[, encoding]]) fs.writeFile(file, data[, options], (err) =&gt; {} )：异步地写入数据到文件，如果文件已经存在，则覆盖文件，data可以是字符串或buffer fs.writeFileSync(file, data[, options])：同步的fs.writeFile() fs.appendFile(path, data[, options], (err) =&gt; {} ):将数据写入文件尾部，如果文件不存在则创建文件，data可以是一个字符串或Buffer fs.appendFileSync(path, data[, options])：fs.appendFile()的同步方法 5. 删除 fs.unlink(path, (err) =&gt; {} )：删除文件 fs.unlinkSync(path)：fs.unlink()的同步版本，返回值为undefined 6. 重命名 fs.rename(oldPath, newPath, (err) =&gt; {} )：重命名 fs.renameSync(oldPath, newPath)：fs.rename()的同步版本，返回值为undefined 7. 关闭 fs.close(fd, (err) =&gt; {} )：关闭一个打开的文件 fs.closeSync(fd)：fs.close()的同步版本 8. 文件夹操作 fs.mkdir(path[, mode], (err) =&gt; {} )：创建目录，完成回调只有一个可能的异常参数，mode 默认为0o777。 fs.mkdirSync(path[, mode])：fs.mkdir()的同步版本，返回 undefined fs.rmdir(path, (err) =&gt; {} )：删除文件夹 fs.rmdirSync(path)：fs.rmdir()的同步版本 fs.readdir(path[, options], (err, files) =&gt; {} )：读取一个目录的内容，得到文件列表 fs.readdirSync(path[, options])：fs.readdir()的同步版本，返回文件列表","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://wzr1998.github.io/categories/Node-js/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"Node.js","slug":"Node-js","permalink":"http://wzr1998.github.io/tags/Node-js/"}]},{"title":"Node.js 入门与模块的概念","slug":"Node-js-入门与模块的概念","date":"2018-07-01T04:20:36.000Z","updated":"2020-11-26T04:21:17.018Z","comments":true,"path":"posts/70b84755/","link":"","permalink":"http://wzr1998.github.io/posts/70b84755/","excerpt":"","text":"一、Node.js 和 javascript 的异同 Node.js官网：https://nodejs.org 相同点：JavaScript中的ECMAScript部分和Node.js是一样的，比如数据类型的定义，语法结构，内置对象 不同点：js中顶层对象是window，node中的顶层对象是global (node中没有window的概念) 二、Node.js Module 1. 模块 一个文件就是一个模块，每个模块都有自己的作用域，用var申明的变量不是全局的，而是属于当前模块下，外部不能直接访问 2. 模块加载 require(‘otherModule.js’) ，该方法返回值是被加载模块的module.exports 3. module.explores 可以通过这个对象把一个模块中的局部变量对象提供访问 ​ 在模块作用域中，还有一个内置的模块对象：exports ，( module.exports === exports ) =&gt; true ​ 例：在被加载的模块中使用 let a; module. exports.a = a 4. 路径相关 ’./’表示同文件根目录下的其它文件，无’./’则会加载node中的核心模块，或者是node_modules __filename: 返回当前模块文件解析后的绝对路径，该属性其实并非全局的，而是模块作用域下的 __dirname: 返回当前模块文件所在目录解析后的绝对路径，该属性也不是全局的，而是模块作用域下的 5. 文件查找机制 文件名 -&gt; .js → .json → .node ，查找时前一类型没有找到，则会添加后缀重新查找","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://wzr1998.github.io/categories/Node-js/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"Node.js","slug":"Node-js","permalink":"http://wzr1998.github.io/tags/Node-js/"}]},{"title":"JavaScript 实现排序算法","slug":"JavaScript-实现排序算法","date":"2018-06-22T04:17:47.000Z","updated":"2020-11-26T04:18:39.076Z","comments":true,"path":"posts/53237518/","link":"","permalink":"http://wzr1998.github.io/posts/53237518/","excerpt":"","text":"一、冒泡排序算法 双循环，从小到大，若相邻两数前边一个大于后边则交换位置 时间复杂度：O(n²) 123456789function bubbleSort(arr)&#123; for(let i=0; i&lt;arr.length-1; i++)&#123; for(let j=i; j&lt;arr.length-i-1; j++)&#123; if(arr[j]&gt;arr[j+1])&#123; [arr[j], arr[j+1]] = [arr[j+1], arr[j]] &#125; &#125; &#125;&#125; 二、快速排序算法 先取一个数(中间位置)，将数组其余部分与之比较，若不大于存入左数组，大于则存入右数组，左右数组继续递归 时间复杂度：O(nlog2n) 1234567891011function quickSort(arr)&#123; if(arr.length&lt;=1) return arr; let num = Math.floor(arr.length/2); let x = arr.splice(num,1)[0]; let left = arr.filter(i =&gt; i&lt;=x); let right = arr.filter(i =&gt; i&gt;x); return quickSort(left).concat(x,quickSort(right));&#125; 三、希尔排序算法 1234567891011let arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];for (let fraction=Math.floor(arr.length/2); fraction&gt;0; fraction=Math.floor(fraction/2))&#123; for (let i=fraction; i&lt;arr.length; i++) &#123; for (let j=i-fraction; j&gt;=0 &amp;&amp; arr[j]&gt;arr[fraction+j]; j-=fraction)&#123; let temp = arr[j]; arr[j] = arr[fraction+j]; arr[fraction+j] = temp; &#125; &#125;&#125;console.log(arr); 四、直接插入排序算法 1234567891011121314let arr = [4,7,3,1,5,2,8,9,0,6];let temp, j;for(let i=0; i&lt;arr.length; i++)&#123; if(arr[i] &lt;= arr[i-1])&#123; temp = arr[i]; j = i-1; while(j&gt;=0 &amp;&amp; arr[j]&gt;temp)&#123; arr[j+1] = arr[j]; j--; &#125; arr[j+1] = temp; &#125;&#125;console.log(arr);","categories":[{"name":"算法","slug":"算法","permalink":"http://wzr1998.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"算法","slug":"算法","permalink":"http://wzr1998.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"JavaScript 正则表达式","slug":"JavaScript-正则表达式","date":"2018-06-18T04:03:49.000Z","updated":"2020-12-01T12:19:03.842Z","comments":true,"path":"posts/cd878b94/","link":"","permalink":"http://wzr1998.github.io/posts/cd878b94/","excerpt":"","text":"一、基本概念 1. 正则表达式 让计算机能够读懂人类的规则，用于操作字符串，默认区分大小写、匹配成功就会结束，不会继续匹配 2. JavaScript正则表达式写法 1234var re = /a/;var re = new RegExp(&#x27;a&#x27;); //当正则需要传参的时候，一定要用全称的写法var re = new RegExp(&#x27;\\\\b&#x27;+Class+&#x27;\\\\b&#x27;); //字符串内部非字符前要加一个反斜杠\\ 3. 单个字符、定位符 | ：或 小括号() ：分组操作、匹配子项 字符类[] : 一组相似的元素，中括号的整体代表一个字符 排除^ ：如果^写在[]里面的话，就代表排除的意思 范围 ：[a-z]、[0-9] ^ : 正则的最开始位置，就代表起始的意思 $ : 正则的最后位置 , 就代表结束的意思 /^\\s+|\\s+\\$/g 二、转义字符 点 . ：任意字符（\\. : 真正的点） \\s、\\S : 空格、非空格 \\d、\\D : 数字、非数字 \\w、\\W : 字符 ( 字母 ，数字，下划线_ )、非字符 \\b、\\B : 独立的部分 （ 起始，结束，空格 ）、非独立的部分 \\1、\\2… ：重复的第一(二)个子项 三、标识符 i ：不区分大小写 g：全局匹配 m：多行匹配 四、量词 匹配字符不确定长度 &#123;a,b&#125; : 最少出现a次，最多出现b次 &#123;a,&#125; : 最少出现a次 &#123;a&#125; : 正好出现a次 +: {1,}、至少出现一次 ? : {0,1}、出现0次或者1次 *: {0,}、至少出现0次 五、方法 1. reg.test(str) 正则去匹配字符串，如果匹配成功就返回真，如果匹配失败就返回假 12345console.log(/[a-z]/i.test(&#x27;111a13234&#x27;)); // trueconsole.log(/^(\\d|[1-9]\\d&#123;0,3&#125;)$/.test(&#x27;2222&#x27;)); // trueconst imgArr = [&#x27;aa.jpg&#x27;, &#x27;bb.gif&#x27;, &#x27;cc.png&#x27;, &#x27;dd.pdf&#x27;];console.log(imgArr.map(item =&gt; /\\.(jpg|gif)$/.test(item))); // [true, true, false, false] 2. str.search(reg) 正则去匹配字符串 , 如果匹配成功，就返回匹配成功的位置，如果匹配失败就返回 -1 12const str = &#x27;cSjsdcnjxnsSsnckjfhsvjsn&#x27;;console.log(str.search(/s&#123;3&#125;/i)); // 10 3. str.indexOf(str) 根据字符串查找字符串，如果匹配成功，返回匹配的第一个元素下标，匹配失败返回-1 12const str = &#x27;cSjsdcnjxnsSsnckjfhsvjsn&#x27;;console.log(str.indexOf(&#x27;s&#x27;)); // 3 3. str.match(reg) 正则去匹配字符串，如果匹配成功，就返回匹配成功的数组，如果匹配不成功，就返回null 12const str = &#x27;cSjsdcnjxnsSsnckjfhsvjsn&#x27;;console.log(str.match(/s+/ig)); // [&quot;S&quot;, &quot;s&quot;, &quot;sSs&quot;, &quot;s&quot;, &quot;s&quot;] 4. str.replace(reg/newStr, replacement) 正则/字符串去匹配原字符串，匹配成功的字符去替换成新的字符串 replacement可以为新字符串或返回新字符串的函数，函数的第一个参数$0是匹配成功的字符(母项)，之后的$1, $2依次为第一子项、第二子项 123456789101112131415161718const str2 = &#x27;嘤王卓然嘤嘤王卓然王卓然嘤嘤嘤好帅呀！嘤嘤嘤&#x27;;console.log(str2.replace(/好帅呀/, &#x27;好丑呀&#x27;));// 嘤王卓然嘤嘤王卓然王卓然嘤嘤嘤好丑呀！嘤嘤嘤const str3 = &#x27;100#100王卓然100#王卓然王卓然100&#x27;;const str4 = str3.replace(/(王)(卓)(然)/g, ($0, $1, $2, $3, offset, string ) =&gt; &#123; console.log($0, $1, $2, $3, offset, string); return $3 + $2 + $1&#125;);console.log(str4);// 王卓然 王 卓 然 7 100#100王卓然100#王卓然王卓然100// 王卓然 王 卓 然 14 100#100王卓然100#王卓然王卓然100// 王卓然 王 卓 然 17 100#100王卓然100#王卓然王卓然100// 100#100然卓王100#然卓王然卓王100const str5 = &#x27;wzr shuai&#x27;;console.log(str5.replace(/(\\w+)\\s(\\w+)/g, &quot;$2 $1&quot;));// shuai wzr 六、思维导图 正则表达式","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://wzr1998.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"ES6 Promise A+ 规范源码","slug":"ES6-Promise-A-规范源码","date":"2018-06-14T04:02:43.000Z","updated":"2020-11-26T05:06:55.112Z","comments":true,"path":"posts/9fa5c95b/","link":"","permalink":"http://wzr1998.github.io/posts/9fa5c95b/","excerpt":"","text":"一、Promise 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/** * Promise 实现 遵循promise/A+规范 * Promise/A+规范译文: * https://malcolmyu.github.io/2015/06/12/Promises-A-Plus/#note-4 */// promise 三个状态const PENDING = &quot;pending&quot;;const FULFILLED = &quot;fulfilled&quot;;const REJECTED = &quot;rejected&quot;;function Promise(excutor) &#123; let that = this; // 缓存当前promise实例对象 that.status = PENDING; // 初始状态 that.value = undefined; // fulfilled状态时 返回的信息 that.reason = undefined; // rejected状态时 拒绝的原因 that.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数 that.onRejectedCallbacks = []; // 存储rejected状态对应的onRejected函数 function resolve(value) &#123; // value成功态时接收的终值 if(value instanceof Promise) &#123; return value.then(resolve, reject); &#125; // 为什么resolve 加setTimeout? // 2.2.4规范 onFulfilled 和 onRejected 只允许在 execution context 栈仅包含平台代码时运行. // 注1 这里的平台代码指的是引擎、环境以及 promise 的实施代码。实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。 setTimeout(() =&gt; &#123; // 调用resolve 回调对应onFulfilled函数 if (that.status === PENDING) &#123; // 只能由pedning状态 =&gt; fulfilled状态 (避免调用多次resolve reject) that.status = FULFILLED; that.value = value; that.onFulfilledCallbacks.forEach(cb =&gt; cb(that.value)); &#125; &#125;); &#125; function reject(reason) &#123; // reason失败态时接收的拒因 setTimeout(() =&gt; &#123; // 调用reject 回调对应onRejected函数 if (that.status === PENDING) &#123; // 只能由pedning状态 =&gt; rejected状态 (避免调用多次resolve reject) that.status = REJECTED; that.reason = reason; that.onRejectedCallbacks.forEach(cb =&gt; cb(that.reason)); &#125; &#125;); &#125; // 捕获在excutor执行器中抛出的异常 // new Promise((resolve, reject) =&gt; &#123; // throw new Error(&#x27;error in excutor&#x27;) // &#125;) try &#123; excutor(resolve, reject); &#125; catch (e) &#123; reject(e); &#125;&#125;/** * resolve中的值几种情况： * 1.普通值 * 2.promise对象 * 3.thenable对象/函数 *//** * 对resolve 进行改造增强 针对resolve中不同值情况 进行处理 * @param &#123;promise&#125; promise2 promise1.then方法返回的新的promise对象 * @param &#123;[type]&#125; x promise1中onFulfilled的返回值 * @param &#123;[type]&#125; resolve promise2的resolve方法 * @param &#123;[type]&#125; reject promise2的reject方法 */function resolvePromise(promise2, x, resolve, reject) &#123; if (promise2 === x) &#123; // 如果从onFulfilled中返回的x 就是promise2 就会导致循环引用报错 return reject(new TypeError(&#x27;循环引用&#x27;)); &#125; let called = false; // 避免多次调用 // 如果x是一个promise对象 （该判断和下面 判断是不是thenable对象重复 所以可有可无） if (x instanceof Promise) &#123; // 获得它的终值 继续resolve if (x.status === PENDING) &#123; // 如果为等待态需等待直至 x 被执行或拒绝 并解析y值 x.then(y =&gt; &#123; resolvePromise(promise2, y, resolve, reject); &#125;, reason =&gt; &#123; reject(reason); &#125;); &#125; else &#123; // 如果 x 已经处于执行态/拒绝态(值已经被解析为普通值)，用相同的值执行传递下去 promise x.then(resolve, reject); &#125; // 如果 x 为对象或者函数 &#125; else if (x != null &amp;&amp; ((typeof x === &#x27;object&#x27;) || (typeof x === &#x27;function&#x27;))) &#123; try &#123; // 是否是thenable对象（具有then方法的对象/函数） let then = x.then; if (typeof then === &#x27;function&#x27;) &#123; then.call(x, y =&gt; &#123; if(called) return; called = true; resolvePromise(promise2, y, resolve, reject); &#125;, reason =&gt; &#123; if(called) return; called = true; reject(reason); &#125;) &#125; else &#123; // 说明是一个普通对象/函数 resolve(x); &#125; &#125; catch(e) &#123; if(called) return; called = true; reject(e); &#125; &#125; else &#123; resolve(x); &#125;&#125; 二、Promise.then() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * [注册fulfilled状态/rejected状态对应的回调函数] * @param &#123;function&#125; onFulfilled fulfilled状态时 执行的函数 * @param &#123;function&#125; onRejected rejected状态时 执行的函数 * @return &#123;function&#125; newPromsie 返回一个新的promise对象 */Promise.prototype.then = function(onFulfilled, onRejected) &#123; const that = this; let newPromise; // 处理参数默认值 保证参数后续能够继续执行 onFulfilled = typeof onFulfilled === &quot;function&quot; ? onFulfilled : value =&gt; value; onRejected = typeof onRejected === &quot;function&quot; ? onRejected : reason =&gt; &#123; throw reason; &#125;; // then里面的FULFILLED/REJECTED状态时 为什么要加setTimeout ? // 原因: // 其一 2.2.4规范 要确保 onFulfilled 和 onRejected 方法异步执行(且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行) 所以要在resolve里加上setTimeout // 其二 2.2.6规范 对于一个promise，它的then方法可以调用多次.（当在其他程序中多次调用同一个promise的then时 由于之前状态已经为FULFILLED/REJECTED状态，则会走的下面逻辑),所以要确保为FULFILLED/REJECTED状态后 也要异步执行onFulfilled/onRejected // 其二 2.2.6规范 也是resolve函数里加setTimeout的原因 // 总之都是 让then方法异步执行 也就是确保onFulfilled/onRejected异步执行 // 如下面这种情景 多次调用p1.then // p1.then((value) =&gt; &#123; // 此时p1.status 由pedding状态 =&gt; fulfilled状态 // console.log(value); // resolve // // console.log(p1.status); // fulfilled // p1.then(value =&gt; &#123; // 再次p1.then 这时已经为fulfilled状态 走的是fulfilled状态判断里的逻辑 所以我们也要确保判断里面onFuilled异步执行 // console.log(value); // &#x27;resolve&#x27; // &#125;); // console.log(&#x27;当前执行栈中同步代码&#x27;); // &#125;) // console.log(&#x27;全局执行栈中同步代码&#x27;); // if (that.status === FULFILLED) &#123; // 成功态 return newPromise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; try&#123; let x = onFulfilled(that.value); resolvePromise(newPromise, x, resolve, reject); // 新的promise resolve 上一个onFulfilled的返回值 &#125; catch(e) &#123; reject(e); // 捕获前面onFulfilled中抛出的异常 then(onFulfilled, onRejected); &#125; &#125;); &#125;) &#125; if (that.status === REJECTED) &#123; // 失败态 return newPromise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(that.reason); resolvePromise(newPromise, x, resolve, reject); &#125; catch(e) &#123; reject(e); &#125; &#125;); &#125;); &#125; if (that.status === PENDING) &#123; // 等待态 // 当异步调用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中 return newPromise = new Promise((resolve, reject) =&gt; &#123; that.onFulfilledCallbacks.push((value) =&gt; &#123; try &#123; let x = onFulfilled(value); resolvePromise(newPromise, x, resolve, reject); &#125; catch(e) &#123; reject(e); &#125; &#125;); that.onRejectedCallbacks.push((reason) =&gt; &#123; try &#123; let x = onRejected(reason); resolvePromise(newPromise, x, resolve, reject); &#125; catch(e) &#123; reject(e); &#125; &#125;); &#125;); &#125;&#125;; 三、Promise.all() 12345678910111213141516171819202122232425262728/** * Promise.all Promise进行并行处理 * 参数: promise对象组成的数组作为参数 * 返回值: 返回一个Promise实例 * 当这个数组里的所有promise对象全部变为resolve状态的时候，才会resolve。 */Promise.all = function(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; let done = gen(promises.length, resolve); promises.forEach((promise, index) =&gt; &#123; promise.then((value) =&gt; &#123; done(index, value) &#125;, reject) &#125;) &#125;)&#125;function gen(length, resolve) &#123; let count = 0; let values = []; return function(i, value) &#123; values[i] = value; if (++count === length) &#123; console.log(values); resolve(values); &#125; &#125;&#125; 四、Promise.race() 12345678910111213/** * Promise.race * 参数: 接收 promise对象组成的数组作为参数 * 返回值: 返回一个Promise实例 * 只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理(取决于哪一个更快) */Promise.race = function(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; promises.forEach((promise, index) =&gt; &#123; promise.then(resolve, reject); &#125;); &#125;);&#125; 五、Promise.catch() 1234// 用于promise方法链时 捕获前面onFulfilled/onRejected抛出的异常Promise.prototype.catch = function(onRejected) &#123; return this.then(null, onRejected);&#125; 六、Promise.resolve() 12345Promise.resolve = function (value) &#123; return new Promise(resolve =&gt; &#123; resolve(value); &#125;);&#125; 七、Promise.reject() 12345Promise.reject = function (reason) &#123; return new Promise((resolve, reject) =&gt; &#123; reject(reason); &#125;);&#125; 八、Promise.deferred() 1234567891011121314151617/** * 基于Promise实现Deferred的 * Deferred和Promise的关系 * - Deferred 拥有 Promise * - Deferred 具备对 Promise的状态进行操作的特权方法（resolve reject） * *参考jQuery.Deferred *url: http://api.jquery.com/category/deferred-object/ */Promise.deferred = function() &#123; // 延迟对象 let defer = &#123;&#125;; defer.promise = new Promise((resolve, reject) =&gt; &#123; defer.resolve = resolve; defer.reject = reject; &#125;); return defer;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://wzr1998.github.io/tags/ES6/"},{"name":"源码","slug":"源码","permalink":"http://wzr1998.github.io/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"ES6 Promise 对象","slug":"ES6-Promise-对象","date":"2018-06-10T04:02:04.000Z","updated":"2020-11-26T04:02:25.472Z","comments":true,"path":"posts/aa98085a/","link":"","permalink":"http://wzr1998.github.io/posts/aa98085a/","excerpt":"","text":"一、Promise的含义 简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。Promise 是一个对象，从它可以获取异步操作的消息 三种状态 ：pending（进行中）、fulfilled（已成功）、rejected（已失败） 特点 ：Promise对象的状态不受外界影响、一旦状态改变，就不会再变，任何时候都可以得到这个结果 关于错误 ： promise中的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获 如果promise内部的错误没有被捕获则会把错误暴露出来输出，但不会影响后续代码的执行(Promise 会吃掉错误) 二、创建Promise对象 Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数 注意：promise新建后内部函数会立即执行，状态改变时通过then监听，执行resolve()或reject() 12345678const promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); 二、Promise.prototype.then( value =&gt; {}, err =&gt; {} ) 参数为两个回调函数，分别调用Promise对象中resolve()和reject()，第二个参数可选，回掉函数中可传递参数value和error 返回的是一个新的Promise实例（不是原来那个Promise实例），可采用链式写法，即then方法后面再调用另一个then方法。 链式写法时，then内部可手动返回一个promise，前边的then状态变化，后边then中的函数才会执行。 一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。（错误冒泡） 三、Promise.prototype.catch( err =&gt; {} ) 用于指定发生错误时的回调函数，等同于Promise.prototype.then(null, rejection)，没有错误则跳过catch()方法 catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。 如果promise内部抛出了一个错误，没有调用reject()，则也会被catch( err =&gt; {} )函数接收 四、Promise.prototype.finally() 不管 Promise 对象最后状态如何，都会执行的操作 回调函数中不接受任何参数，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。 五、Promise.all( [p1, p2, p3] ) 用于将多个 Promise 实例，包装成一个新的 Promise 实例 接受一个数组作为参数，p1、p2、p3都是 Promise 实例(或拥有 Iterator 接口) 如果传入一个空数组，则马上被决议成功 两种可能情况： 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值(错误)，会传递给p的回调函数。 六、Promise.race( [p1, p2, p3] ) (竞速)将多个 Promise 实例，包装成一个新的 Promise 实例。返回(then能监听到)最快改变状态的promise对象 注意：如果传入一个空数组，则永远被挂起 七、Promise.resolve() 将现有对象转为 Promise 对象，可能有一下几种情况： 参数是一个 Promise 实例 ：直接返回promise 参数是一个具有then方法的对象(thenable对象) ：将这个对象转为 Promise 对象，然后就立即执行thenable对象(原对象)的then方法。 不具有then方法的对象，或不是对象 ：返回一个新的 Promise 对象，状态为resolved。 不带有任何参数 ：返回一个resolved状态的 Promise 对象。 八、Promise.reject() 返回一个新的 Promise 实例，该实例的状态为rejected 注意：Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。 九、把同步函数变为异步 123function createAsyncTask(syncFn) &#123; return Promise.resolve(syncFn).then(syncFn =&gt; syncFn());&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://wzr1998.github.io/tags/ES6/"}]},{"title":"ES6 class 继承","slug":"ES6-class-继承","date":"2018-06-07T04:01:00.000Z","updated":"2020-11-26T04:01:55.242Z","comments":true,"path":"posts/78633d3d/","link":"","permalink":"http://wzr1998.github.io/posts/78633d3d/","excerpt":"","text":"一、 继承方法 123456789class VipPerson extends Person&#123; constructor(name, age, sex, level)&#123; super(name, age, sex); this.level = level; //私有属性 &#125; showLevel()&#123; console.log(`VIP用户$&#123;this.name&#125;等级为：$&#123;this.level&#125;`); &#125;&#125; 注意： 在子类的构造函数(constructor)里调用super，它在这里表示父类的构造函数，用来新建父类的this对象。 子类必须在constructor方法中调用super方法，否则子类就得不到this对象。新建实例时会报错。 在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。 二、super 关键字 super这个关键字，既可以当作函数使用，也可以当作对象使用 1. 子类 super() 使用extends继承时子类构造函数中调用super()，其代表父类的构造函数，返回的是子类的实例，即super内部的this指向子类，因此super()相当于Parent.prototype.constructor.call(this) 2. super作为对象 super作为对象时，在普通方法中，指向父类的原型对象(Parent.prototype)；在静态方法中，指向父类 super指向父类的原型对象，访问不到constructor构造函数中对象实例上的方法和属性 在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例。本质：super.fn.call(this) 如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。 如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。 三、类的 prototype 属性和__proto__属性 12345678910// 1.每一个对象都有__proto__属性，指向对应的构造函数的prototype属性// 2.子类的__proto__属性，表示构造函数的继承，总是指向父类Child.__proto__ === Super// 3.子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性Child. prototype.__proto__ === Super. prototype// 4.子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。Child.__proto__.__proto__ === Super.__proto__","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://wzr1998.github.io/tags/ES6/"}]},{"title":"ES6 class 的基本语法","slug":"ES6-class-的基本语法","date":"2018-06-04T04:00:09.000Z","updated":"2020-11-26T04:00:47.683Z","comments":true,"path":"posts/173083ed/","link":"","permalink":"http://wzr1998.github.io/posts/173083ed/","excerpt":"","text":"一、简介 通过class关键字，定义一个类。本质是 ES5 的语法糖，例： 12345678910class Person &#123; constructor(name, age, sex)&#123; this.name = name; this.age = age; this.sex = sex; &#125; showPerson()&#123; console.log(`姓名 : $&#123;this.name&#125;, 年龄 : $&#123;this.age&#125;, 性别 : $&#123;this.sex&#125;`); &#125;&#125; 特性： 类的数据类型是函数，其prototype对象的constructor属性，直接指向“类”的本身 类的内部所有定义的方法，都是不可枚举的 在类的实例上面调用方法，其实就是调用原型上的方法。 类的属性名(方法名)，可以采用表达式。 类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。 class同let、const一样，不存在变量提升 二、constructor 方法 类的构造函数 constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。 constructor方法默认返回实例对象（即this） 三、this指向相关 class的方法带有this不要单独拿出来使用，其this始终指向class实例对象，单独使用很可能会报错 四、Class 的取值函数与存值函数 1234567891011121314class MyClass &#123; constructor() &#123; // ... &#125; get prop() &#123; return &#x27;getter&#x27;; &#125; set prop(value) &#123; console.log(&#x27;setter: &#x27;+value); &#125;&#125;let obj = new MyClass();obj.prop = 123; // setter: 123console.log(obj.prop) // &#x27;getter&#x27; 五、class的静态方法与静态属性 静态：类下的属性，实例对象得不到 静态方法：在class的方法前加static就表示该方法不会被实例继承，父类的静态方法，可以被子类继承。 静态属性：在类的外部通过 Class.propName 直接添加 123456789class Foo &#123; static print() &#123; console.log(&#x27;static function&#x27;); &#125;&#125;Foo.staticAttr = &quot;静态属性&quot;Foo.print() // static functionconsole.log(Foo.staticAttr) // 静态属性 六、new.target 属性 用在构造函数之中，返回new命令作用于的那个构造函数。注意： 如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。 子类继承父类时，new.target会返回子类。 在函数外部，使用new.target会报错，只能使用在构造函数当中 12345678class Rectangle &#123; constructor(length, width) &#123; console.log(new.target === Rectangle); this.length = length; this.width = width; &#125;&#125;var obj = new Rectangle(3, 4); // 输出 true","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://wzr1998.github.io/tags/ES6/"}]},{"title":"ES6 Module 模块化","slug":"ES6-Module-模块化","date":"2018-06-02T03:59:36.000Z","updated":"2020-11-26T03:59:55.246Z","comments":true,"path":"posts/408caa71/","link":"","permalink":"http://wzr1998.github.io/posts/408caa71/","excerpt":"","text":"一、export 命令 把本模块中的变量暴露到外部，输出类型为变量、函数、类 注：export要提供对外的接口，不能直接输出变量(不能var之后直接输出变量) 输出形式 形式一： 123export var firstName = &#x27;Michael&#x27;;export var lastName = &#x27;Jackson&#x27;;export var year = 1958; 形式二(最好)： 1234var firstName = &#x27;Michael&#x27;;var lastName = &#x27;Jackson&#x27;;var year = 1958;export &#123;firstName, lastName, year&#125;; 形式三： 12345//可使用as关键字重命名输出关键字var firstName = &#x27;Michael&#x27;;var lastName = &#x27;Jackson&#x27;;var year = 1958;export &#123;firstName as name1, lastName as name2, year&#125;; 二、 import 命令 引入其他模块中对外暴露的变量，注意： import大括号里的变量名必须与被导入模块对外接口的名称相同。 import有变量提升效果 import中引入的变量是只读的，尽量不要修改 引入形式 12import &#123;firstName, lastName, year&#125; from &#x27;./export.js&#x27;;import &#123;firstName as name1, lastName as name2, year&#125; from &#x27;./export.js&#x27;; 三、 import整体加载 形式：import * as user from ‘./export.js’; 使用：user.firstName / user.lastName / user.year 四、export default命令 注意： export default命令后不能跟变量声明语句(var) 一个模块只能有一个默认输出，因此export default命令只能使用一次 export default命令其实只是输出一个叫做default的变量 输出： 1234567891011// 输出函数export default function () &#123; console.log(&#x27;foo&#x27;);&#125;//输出变量var a = 1;export default a;//输出变量export default 1; 输入： 12345// 只引入匿名变量不加大括号mport name from &#x27;./export.js&#x27;;// 匿名变量和有名变量引入：mport default, &#123;firstName, lastName, year&#125; from &#x27;./export.js&#x27;; 五、export 与 import 的复合写法 123export &#123; foo, bar &#125; from &#x27;my_module&#x27;;export &#123; foo as myFoo &#125; from &#x27;my_module&#x27;; // 接口改名export * from &#x27;my_module&#x27;; // 整体输出","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://wzr1998.github.io/tags/ES6/"}]},{"title":"ES6 Symbol 数据结构","slug":"ES6-Symbol-数据结构","date":"2018-05-29T03:58:51.000Z","updated":"2020-11-26T03:59:26.116Z","comments":true,"path":"posts/ea0722e1/","link":"","permalink":"http://wzr1998.github.io/posts/ea0722e1/","excerpt":"","text":"一、概念 Symbol是一种原始的数据类型，表示独一无二的值。 二、创建symbol对象 12let s = Symbol(&#x27;wzr&#x27;);//Symbol可以接受一个字符串作为参数，表示对 Symbol 实例的描述 Symbol函数前不能使用new命令，否则会报错。 Symbol()生成的 是一个原始类型的值，不是对象。不能添加属性。(类似字符串) Symbol 值不能与其他类型的值进行运算，会报错。 Symbol 值可以显式转为字符串。 ：String(s) \\\\ s.toString(). =&gt; ‘Symbol(wzr)’ 三、Symbol作为对象属性或方法名 Symbol 值作为对象的属性名或方法时，设置和读取不能用点运算符。 12345678910const sym = Symbol(&#x27;wzr&#x27;);const fn = Symbol(&#x27;fn1&#x27;);const obj = &#123; [sym] : &#x27;wzr2333&#x27;, [fn]()&#123; console.log(sym.toString()); &#125;&#125;;console.log(obj[sym]); //wzr2333obj[fn](); //Symbol(wzr) 四、Symbol属性名的遍历 注意：Symbol 作为属性名，不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。 利用Object.getOwnPropertySymbols(obj) 方法返回所有Symbol 属性名构成的数组 利用Reflect.ownKeys(obj)方法返回所有类型的键名构成的数组，包括字符串键名和 Symbol 键名。 五、Symbol 方法 1. Symbol.for(‘string’) 在全局环境登记一个Symbol，如果原来没有，创建新的Symbol；如果原来已有，返回原来Symbol 作用 ：希望重新使用同一个 Symbol 值，如果用Symbol.for(‘wzr’)创建100个Symbol，则100个都是相同的。 2. Symbol.keyFor(symbol) 返回一个已用Symbol.for(‘string’)登记的 Symbol 类型值的string","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://wzr1998.github.io/tags/ES6/"}]},{"title":"ES6 set / map 数据结构","slug":"ES6-set-map-数据结构","date":"2018-05-27T03:58:12.000Z","updated":"2020-11-26T03:58:31.653Z","comments":true,"path":"posts/b3f4641c/","link":"","permalink":"http://wzr1998.github.io/posts/b3f4641c/","excerpt":"","text":"一、Set数据结构 1. 概念 ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。注意： set内部是利用全等(===)判断的，不会进行数据类型转换 Set内判断+0和-0、NaN和NaN都是相等的 set结构只有值value没有key set结构中两个空对象不相等 2. 创建 使用new Set()，参数中传入数组或类数组(有 iterable 接口的结构) 12const set = new Set([1, 2, 3, 4, 4]);console.log(set) //Set &#123;1, 2, 3, 4&#125; 3. set.size属性 返回Set实例的成员总数 4. set实例对象的操作方法 setObj.add(value)：添加某个值，返回 Set 结构本身。 setObj.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 setObj.has(value)：返回一个布尔值，表示该值是否为Set的成员。 setObj.clear()：清除所有成员，没有返回值。 5. set实例对象的遍历方法 setObj.keys()：返回键名的遍历器，其实就是键值 setObj.values()：返回键值的遍历器 setObj.entries()：返回键值对的遍历器 setObj.forEach()：使用回调函数遍历每个成员，没有返回值 6. 应用：数组去重 12let unique = [...new Set(arr)];let unique = Array.from(new Set(array)); 二、Map数据结构 1. 概念 ES6 提供了 Map 数据结构。它类似于对象，但键值可为任意类型。（包括对象） 注意 ：key为对象时，只有对同一个对象的引用，Map 结构才将其视为同一个键。(判断地址) 2. 创建 使用new Set()，参数中传入数组，成员是键值对构成的数组。 12const map = new Map([ [&#x27;name&#x27;, &#x27;张三&#x27;], [&#x27;title&#x27;, &#x27;Author&#x27;] ]);console.log(map) // Map &#123;&quot;name&quot; =&gt; &quot;张三&quot;, &quot;title&quot; =&gt; &quot;Author&quot;&#125; 3. map.size 返回 Map 结构的成员总数。 4. map实例对象的操作方法 map.set(key value) ：设置键名key对应的键值为value，然后返回整个 Map 结构。 map.get(key) ：读取key对应的键值，如果找不到key，返回undefined。 map.has(value)：返回一个布尔值，表示某个键是否在当前 Map 对象之中。 map.delete(value)：删除某个键，返回true。如果删除失败，返回false。 map.clear()：清除所有成员，没有返回值。 5. map实例对象的遍历方法 Map 的遍历顺序就是插入顺序。 map.keys()：返回键名的遍历器。 map.values()：返回键值的遍历器 map.entries()：返回键值对的遍历器 map.forEach()：遍历 Map 的所有成员。 6. Map 结构转为数组 12345const map = new Map([ [1, &#x27;one&#x27;], [2, &#x27;two&#x27;], [3, &#x27;three&#x27;], ]); [ ...map.keys() ] // [1, 2, 3] [ ...map.values() ] // [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;] [ ...map.entries() ] // [[1,&#x27;one&#x27;], [2, &#x27;two&#x27;], [3, &#x27;three&#x27;]] [ ...map ] // [[1,&#x27;one&#x27;], [2, &#x27;two&#x27;], [3, &#x27;three&#x27;]]","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://wzr1998.github.io/tags/ES6/"}]},{"title":"ES6 对象的拓展","slug":"ES6-对象的拓展","date":"2018-05-25T03:57:35.000Z","updated":"2020-12-01T12:42:22.738Z","comments":true,"path":"posts/28e436b5/","link":"","permalink":"http://wzr1998.github.io/posts/28e436b5/","excerpt":"","text":"一、属性的简洁表示法 ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值 对象下的方法也具有name属性 123// obj1 与 obj2 完全相同const obj1 = &#123; name, age, sex, sayName()&#123;&#125; &#125;const obj2 = &#123; name : name, age : age, sex : sex, sayName : function sayName()&#123;&#125; &#125; 二、属性名表达式 ES6 允许字面量定义对象时，使用表达式作为对象的属性名，把表达式放在方括号内 注意 ：属性名表达式和属性的简洁表示法不能同时使用 12const obj = &#123; [&#x27;id_&#x27; + user.id] : user.id &#125;const objErr = &#123; [&#x27;id_&#x27; + user.id] &#125; //SyntaxError: Unexpected token &#x27;&#125;&#x27;. Expected &#x27;:&#x27; after property name. 三、对象的扩展运算符 用法与数组相同，可用于解构赋值(浅拷贝)和合并对象(浅拷贝) 四、对象下的新方法 1. Object.is() 比较两值是否相等，与 === 运算符类似，但 +0/-0 不等、NaN相等 12Object.is(+0, -0) // falseObject.is(NaN, NaN) // true 2. Object.assign() 用于对象的合并，第一个参数是目标对象，后面的参数都是源对象 123const wzr = &#123; name : &#x27;wzr&#x27; &#125;;Object.assign( wzr, &#123; age : 18 &#125;, &#123; sex : &#x27;man&#x27; &#125;)console.log(wzr) //&#123; name : &#x27;wzr&#x27;, age : 18, sex &#x27;man&#x27;&#125; 注意： 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性 对象合并是浅拷贝 数组的处理 ：把数组下标当作属性名，属性值为数组中内容，传入多个数组则覆盖 参数只有null或undefined会报错，null或undefined不在首个参数就不会报错 应用： 为对象添加属性或方法；合并对象；克隆对象；为对象属性设置默认值 123456// 不能克隆继承的值，需使用：Object.assign(Object.create( Object.getPrototypeOf(originObj) ), originObj);// 为对象属性设置默认值// 注意：对象最好都是简单类型，不然旧属性容易被覆盖Object.assign(&#123;&#125;, DEFAULTS, options); 3. Object.keys() / Object.values() / Object.entries() 传入一个对象，返回一个数组(一般配合for-of遍历使用)，分别返回对象自身可遍历的属性名、属性值和(属性名and属性值)构成的数组 注意：注： 这三个方法会过滤掉Symbol的属性 12345678let obj = &#123; one: 1, two: 2 &#125;;for (let [k, v] of Object.entries(obj)) &#123; console.log( `$&#123;JSON.stringify(k)&#125;: $&#123;JSON.stringify(v)&#125;` //遍历对象属性 );&#125;// &quot;one&quot;: 1// &quot;two&quot;: 2 4. Object.getOwnPropertyDescriptors() 返回某个对象属性的描述对象 123let obj = &#123; foo: 123 &#125;;Object.getOwnPropertyDescriptor(obj, &#x27;foo&#x27;)// &#123;value: 123, writable: true, enumerable: true, configurable: true&#125; 五、对象描述相关方法 Object.getOwnPropertyDescriptors(obj) ：返回某个对象全部属性的描述对象（二维对象） Object.getOwnPropertyDescriptor(obj, attr) ：返回某个对象某属性的描述对象（一维对象） Object.defineProperties()：老生常谈 六、原型相关属性、方法 __proto__属性 ：显示对象的原型，但不推荐使用 Object.setPrototypeOf(object, prototype)：设置对象object原型为prototype Object.getPrototypeOf(obj)：获取对象obj的原型，等同于obj.prototype 123function Rectangle() &#123; &#125;const rec = new Rectangle();console.log( Object.getPrototypeOf(rec) === Rectangle.prototype ) // true 七、对象属性的遍历 1. 遍历方法 for…in Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。 Object.getOwnPropertyNames(obj)：返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。 Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名。 Reflect.ownKeys(obj)：返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。 2. 遍历顺序 先后顺序按照一下三步走： 遍历所有数值键，按照数值升序排列 遍历所有字符串键，按照加入时间升序排列 遍历所有 Symbol 键，按照加入时间升序排列。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://wzr1998.github.io/tags/ES6/"}]},{"title":"ES6 数组的拓展","slug":"ES6-数组的拓展","date":"2018-05-22T03:56:52.000Z","updated":"2020-11-26T03:57:21.735Z","comments":true,"path":"posts/fea2c76a/","link":"","permalink":"http://wzr1998.github.io/posts/fea2c76a/","excerpt":"","text":"1. 结合扩展运算符 可用于实参传递和形参接收，可代替函数的apply方法。应用： 复制数组 123456const arr1 = [1, 2, 3, 4, 5];const arr2;// 三种方法复制数组arr2 = arr1.concat();arr2 = […arr1];[…arr2] = arr1; 合并数组、拆分字符串、实现Interator接口对象、配合Set、Map数据结构 2. Array.from(arrayLike, fn) 把类数组对象或可遍历对象转化为真正的数组（部署了 Iterator 接口的数据结构） 常见用途 ：操作DOM元素列表、操作arguments对象 arrayLike类数组对象：对象的属性名为数字，(0, 1, 2, …)，且含有length属性 fn：作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 如 ：Array.from(arrayLike, x =&gt; x * x); 3. Array.of() 把传入的参数转换成为一个数组返回，弥补new Array()的不足 12new Array(5) // [ , , , , ]new Array(5, 6) // [5, 6] 4. arr.fill() 使用给定值，填充一个数组，二、三个参数分别为截取填充的起始、终止位置 12console.log( [0,0,0,0,0,0].fill(3, 1, 4) )// [0, 3, 3, 3, 0, 0] 5. arr.includes() 判断数组中是否有某一项，返回布尔值，第二个参数是起始位置 [1, 2, NaN].includes(NaN) // true 6. arr.entries() / arr.keys() / arr.values() 遍历数组，返回一个Iterator对象，遍历内容同Object 7. arr.find( (value, index, arr) =&gt; {} ) / arr.findIndex( (value, index, arr) =&gt; {} )","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://wzr1998.github.io/tags/ES6/"}]},{"title":"ES6 函数的拓展","slug":"ES6-函数的拓展","date":"2018-05-20T03:50:55.000Z","updated":"2020-12-01T12:49:02.911Z","comments":true,"path":"posts/178ff50/","link":"","permalink":"http://wzr1998.github.io/posts/178ff50/","excerpt":"","text":"一、参数默认值与rest参数 1. 参数默认值 ES6 中函数参数中可直接设置默认值。(本质是临时在参数部分用let声明变量) 参数默认值可以与解构赋值一起使用 使用变量设置默认值时参数默认值是惰性求值的 使用参数默认值时注意传入参数的参数位置 参数设置默认值时，参数部分会形成一个单独的作用域，初始化结束后，这个作用域就会消失(参数部分是单独的作用于) 通常情况下函数参数默认值都在参数结尾，不会在中间（中间的参数不能省略） 2. rest参数(…arg) 用于获取函数的多余参数，返回一个数组，必须放在形参列表末尾 二、函数的length / name 属性 fn.length：表示函数预期传入的参数个数，是指第一个具有默认值之前的参数个数(最少参数) fn.name：返回该函数的函数名，如果将一个有名函数赋值给一个变量，返回这个有名函数原本的名字 三、箭头函数 箭头函数中没有arguments、super、new.target，多余参数用rest参数(…arg)获取 箭头函数里面根本自己的this，而是引用外层环境中的this 箭头函数的this是静态的，始终指向定义时的对象，而原函数形式的this是动态改变的，指向调用函数的对象 箭头函数执行部分 this指向问题： 箭头函数中的this继承的是父执行环境上下文里面的this，简单对象(非函数)是没有执行上下文的，不用在函数外部保存_this 四、注意： 在严格模式下，fn.caller和fn.arguments两个变量禁止使用 ES2017允许函数参数列表的最后一个参数有逗号，规则与数组和对象保持一致","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://wzr1998.github.io/tags/ES6/"}]},{"title":"ES6 字符串与正则的扩展","slug":"ES6-字符串与正则的扩展","date":"2018-05-18T03:53:18.000Z","updated":"2020-11-26T03:53:36.676Z","comments":true,"path":"posts/f5444ae7/","link":"","permalink":"http://wzr1998.github.io/posts/f5444ae7/","excerpt":"","text":"一、字符串拓展 1. 模板字符串 用反引号 `` 表示，内部可嵌入JS变量，用 $&#123;&#125;引入，引入对象不是字符串则会调用toString方法，可换行、可嵌套、可调用函数 2. 新方法 (1). padStart() / padEnd() 补全字符串长度，参数 分别为补全后位数和补全字符串，第二个参数不写默认用空格补全；该方法返回一个新的字符串，原字符串不变 用途：padStart的常见用途是为数值补全指定位数，如 ‘123456’.padStart(10, ‘0’) 则会补全为&quot;0000123456&quot; 12&#x27;x&#x27;.padStart(5, &#x27;ab&#x27;) // &#x27;ababx&#x27;&#x27;x&#x27;.padEnd(5, &#x27;ab&#x27;) // &#x27;xabab&#x27; (2). repeat(n) 方法返回一个新字符串，表示将原字符串重复n次，写整数，不支持小数,参数为0时返回空字符串 (3). includes() / startsWith() / endsWith() 传入字符串参数，查找是否在其中/开头/结尾 可加入第二个参数，includes() / startsWith()表示查找起始位置，endsWith()表示前n个字符串 3. for-of遍历字符串 123456let wzr = &#x27;wzr2333&#x27;;let newWzr = &#x27;&#x27;;for(let word of wzr)&#123; newWzr += word + &#x27;!&#x27;;&#125;console.log(newWzr); //w!z!r!2!3!3!3! 4. unicode相关 (1). unicode表示法 传统ES5使用’\\uxxxx’表示一个字符，只限于码点在\\u0000~\\uFFFF之间的字符; ES6中只要将码点放入大括号，就能正确解读该字符，如 \\u{1F680} (2). codePointAt() 返回字符串十进制的Unicode编码值 str.codePointAt().toString(16)即可返回16进制的unicode编码值 (3). String.fromCodePoint() 根据unicode编码值返回一个字符 5. 拓展 (1). 字符串查找 字符串查找时判断if( str.indexOf(‘233’) != -1 )可写为if( ~str.indexOf(‘233’) )，其中～表示按位取反，数值上：~x = -(x+1) (2). 把字符串转为数组 四种方法： 1234var oStr = Array.prototype.slice.call(str);var oStr = str.split(&#x27;&#x27;);const oStr = [...str];const [...oStr] = str; 二、正则的拓展 1. RegExp构造函数 第四种写法为ES6新增，第一个参数为正则对象，若存在第二个修饰符参数，则会把原对象修饰符屏蔽 1234const regexp1 = /^a/g;const regexp2 = new RegExp(&#x27;^a&#x27;, &#x27;g&#x27;);const regexp3 = new RegExp(/a/g);const regexp5 = new RegExp(/a/i, &#x27;g&#x27;); 其余部分见阮一峰老师：[正则的扩展](","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://wzr1998.github.io/tags/ES6/"}]},{"title":"ES6 数字的拓展","slug":"ES6-数字的拓展","date":"2018-05-16T03:52:40.000Z","updated":"2020-11-26T03:55:01.748Z","comments":true,"path":"posts/fea2c76a/","link":"","permalink":"http://wzr1998.github.io/posts/fea2c76a/","excerpt":"","text":"一、二进制和八进制数值表示法 分别用前缀0b(0B)和0o(0O)表示。(octonary, binary) 如：0b11111 =&gt; 31 / 0o16 =&gt; 14 二、Number 方法 Number.isFinite() ：判断是不是有限的，即不是Infinity Number.isInteger() ：判断是不是整数['ɪntɪdʒə]，若不是数值则返回false；精度要求过高时不能使用 Number.isSafeInteger() ：判断是否为安全整数 Number上添加的方法：原来是全局方法 Number.isNaN() Number.parseInt() Number.parseFloat() 三、Math上添加的方法 (1). Math.trunc() 除去一个数的小数部分，保留整数 (2). Math.sign() 判断数字正负，返回+1， -1， 0， -0， NaN (3). Math.cbrt() 计算数字立方根 四、Number上的常数 Number.MAX_SAFE_INTEGER：最大安全数，Math.pow(2,53)-1 Number.MIN_SAFE_INTEGER：最小安全数，-Math.pow(2,53)+1 Number.EPSILON：最小误差范围，Math.pow(2, -52) 五、指数运算符 用 ** 两个乘号表示指数运算，与Math.pow()类似 注 ：指数运算符**是右结合，如：2 ** 10 ** 0 计算结果得2","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://wzr1998.github.io/tags/ES6/"}]},{"title":"ES6 结构赋值","slug":"ES6-结构赋值","date":"2018-05-14T03:52:07.000Z","updated":"2020-11-26T03:52:29.184Z","comments":true,"path":"posts/ec43401a/","link":"","permalink":"http://wzr1998.github.io/posts/ec43401a/","excerpt":"","text":"一、数组的解构赋值 模式匹配 12let [a, b, c, d] = [1, 2, 3, 4];const [ , , [ , , [ , , g]]] = [&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;c&#x27;, &#x27;d&#x27;, [&#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;]]]; 扩展运算符：可用于数组的解构和重构 12345const arr1 = [1, 2, 3], arr2 = [&#x27;a&#x27;, ‘b’], arr3 = [‘b’, 1];const arr4 = [...arr1, ...arr2, ...arr3];const arr = [1, 2, 3, 4, 5, 6];const [a, b, ...c] = arr; 设置默认值 12const [a, b = 2, c, d = &#x27;aaa&#x27;] = [1, null, undefined];console.log(a, b, c, d) // 1 null undefined &#x27;aaa&#x27; 用于交换变量 123let a=1, b=2;[a. b] = [b, a];console.log(a, b) //2, 1 二、对象的解构赋值 模式匹配 12345678//对象中没有匹配顺序的问题，变量必须与属性同名，才能取到正确的值const &#123;name, age&#125; = &#123;name : &#x27;wzr&#x27;; age : 18&#125;;const &#123;name : name , age : age&#125; = &#123;name : &#x27;wzr&#x27;, age : 18&#125;;//注：此时name是模式，name1是变量const &#123;name : name1&#125; = &#123;name : &#x27;wzr&#x27;, age : 18&#125;; console.log(name1) //wzrconsole.log(name) // ReferenceError: name is not defined 稍微复杂的解构条件：对象里可以嵌套对象或数组，数据结构一致则可匹配成功 结合扩展运算符 1234567const wzr = &#123;name : ‘wzr’, age : 18, sex : &#x27;男&#x27;&#125;const xiaoMing = &#123;name : ‘xiaoming’, age : 20, sex : &#x27;女&#x27;&#125;;const &#123;name, …other&#125; = wzr;const Class = &#123;…wzr, …xiaoMing&#125;console.log(name) // wzrconsole.log(other) // &#123; age: 18, sex: &#x27;男&#x27; &#125;console.log(Class) // &#123; name: &#x27;xiaoming&#x27;, age: 20, sex: &#x27;女&#x27; &#125; 对已经申明了的变量进行对象的解构赋值 123//解构赋值语句外加一个括号let x;(&#123;x&#125; = &#123;x: 1&#125;); 对象的解构赋值也可以设置默认值 12const &#123;a : aaa, b, c : ccc=1&#125; = &#123;a : 1, b : &#x27;wzr&#x27;&#125;; console.log(aaa, b, ccc); //1 &#x27;wzr&#x27; 1 三、字符串的解构赋值 字符串解构赋值时被转换成了类数组对象： 类数组对象下有length属性 12345const [a, b, c, d, e] = &#x27;hello&#x27;;console.log(a, b, c, d, e) //h e l l oconst &#123;length&#125; = &#x27;hello&#x27;;console.log(length) // 5 四、数值和布尔值的解构赋值 解构赋值时，如果等号右边是数值和布尔值，则会先临时转为包装对象。 可在其下获得toString或valueOf方法 五、函数参数的解构赋值 12345function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 函数参数的解构也可以使用默认值： 12345678function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0]","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://wzr1998.github.io/tags/ES6/"}]},{"title":"ES6 let 与 const","slug":"ES6-let-与-const","date":"2018-05-12T03:55:43.000Z","updated":"2020-11-26T03:56:01.794Z","comments":true,"path":"posts/9619492a/","link":"","permalink":"http://wzr1998.github.io/posts/9619492a/","excerpt":"","text":"一、let / const 特性 块级作用域，只在当前作用域内有效 声明过后不能再重新声明 不存在变量提升 有暂存死区的问题：父级作用域有同名变量，块级作用域中声明前无法读取 本质 ：只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性，也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。 let 声明变量 const 声明常量，声明后不能被更改 声明引用类型变量时，保证引用的地址不变，不能保证引用的值不变(可以修改引用类型)（temporal dead zone，简称 TDZ） 二、固定常量的方法 1. Object.freeze(obj) 防止常量为引用类型的时候能被修改(ES6新方法) 2. ES6 以前要进行封装 通过 Object.defineProperty() 函数实现，设置各属性 writable 为 false 1234567891011121314Object.prototype.defineProperty(Object, &#x27;freezeObj’, &#123; value : function(obj) &#123; for (var attr in obj) &#123; if (obj.hasOwnProperty(attr)) &#123; Object.defineProperty(obj, attr, &#123; writable: false &#125;); &#125; &#125; Object.seal(obj); &#125;&#125;);Object.freezeObj(obj);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://wzr1998.github.io/tags/ES6/"}]},{"title":"jQuery AJAX与数据串联化","slug":"jQuery-AJAX与数据串联化","date":"2018-05-08T03:48:49.000Z","updated":"2020-11-26T03:49:23.449Z","comments":true,"path":"posts/8a968c2/","link":"","permalink":"http://wzr1998.github.io/posts/8a968c2/","excerpt":"","text":"一、数据串联化 serialize() ：将表单元素的值转换成ajax提交信息格式的字符串字符串 serializeArray() ：将提交的表单元素的值编译成拥有name和value对象组成的数组。(数组套json) 二、jQuery AJAX 1. $.ajax() 发送 AJAX 请求，参数只有一个 json 对象，key 值如下： async( true / false )，请求是同步或异步，默认异步 type( GET / POST ) ：请求类型，默认GET url ：传输数据地址 dataType ：获取的数据类型( xml / html / script / json / jsonp / text ) data ：传递的参数 success / error ：请求成功(失败)后执行函数 2. $.get() / $.post() / $.getJSON() 抽象出的ajax方法，格式为如下： 123$.get(url, &#123;data&#125;, function(data)&#123; … &#125;);$.post(url, &#123;data&#125;, function(data)&#123; … &#125;);$.getJSON(url, &#123;data&#125;, function(data)&#123; … &#125;);","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://wzr1998.github.io/categories/jQuery/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://wzr1998.github.io/tags/jQuery/"}]},{"title":"jQuery 运动与动画效果","slug":"jQuery-运动与动画效果","date":"2018-05-01T03:48:10.000Z","updated":"2020-11-26T03:48:34.308Z","comments":true,"path":"posts/fd77f8ce/","link":"","permalink":"http://wzr1998.github.io/posts/fd77f8ce/","excerpt":"","text":"一、jQuery 运动 $(el).animate( properties [, duration ] [, easing ] [, complete ] ) properties : 一个CSS属性和值的对象,动画将根据这组对象移动。 duration : 时间(运动快慢的) 默认 : 400 easing : 运动形式 只有两种运动形式 ( 默认 : swing(慢快慢) linear(匀速) ) complete : 回调函数 $(el).stop() ：默认阻止当前运动，第一个参数为true组织后续所有运动，第二个参数为true立刻停 $(el).finish() ：立即停止所有运动到所有指定的目标点 $(el).delay() ：运动延迟，参数为时间，加载多个链式运动之间 二、jQuery简单动画效果 $(el).hover() ：鼠标移入移开，接收两个函数作为参数，一个移入，一个移开 $(el).show() / $(el).hide() ：显示/隐藏，可接参数(时间)，默认宽高透明度收缩至左上角隐藏 3. $(el).fadeIn() / $(el).fadeOut() ：淡入淡出，可接参数控制时间，默认400毫秒 $(el).fadeTo(time, opcity) ：改变透明度到某一值，参数分别是时间和透明度的值 $(el).slideDown() / $(el).slideUp() ：向下展开 / 向上卷曲，可接参数控制时间，默认400毫秒","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://wzr1998.github.io/categories/jQuery/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://wzr1998.github.io/tags/jQuery/"}]},{"title":"jQuery 事件操作","slug":"jQuery-事件操作","date":"2018-04-28T03:47:24.000Z","updated":"2020-11-26T03:49:23.445Z","comments":true,"path":"posts/3572fca8/","link":"","permalink":"http://wzr1998.github.io/posts/3572fca8/","excerpt":"","text":"一、jQuery 事件的写法 1. $(el).on() 123456$(&#x27;div&#x27;).on(&#x27;click&#x27;, function()&#123; alert(123); &#125;);$(&#x27;div&#x27;).on(&#x27;click mouseover&#x27;, function()&#123; alert(123); &#125;);$(&#x27;div&#x27;).on(&#123; &#x27;click&#x27; : function()&#123; alert(123); &#125;, &#x27;mouseover&#x27; : function()&#123; alert(456);&#125;&#125;); 2. $(el).one() 写法同on()，但只执行一次 3. $(el).off() 删除事件，不写参数删除所有事件，写参数删除指定事件 二、事件相关 1. 事件委托 $(el).delegate()：事件委托 $(el).undelegate()：阻止事件委托 1$(&#x27;ul&#x27;).delegate(&#x27;li&#x27;,&#x27;click&#x27;,function()&#123; ... &#125;); 2. 主动触发 $(el).trigger() ：主动触发，参数为事件名，也可以为自定义事件 3. 事件细节 ev.data：接收传递事件的数据 ev.target：事件源 ev.type：事件类型 123$(&#x27;#div1&#x27;).on(&#x27;click&#x27;, &#123;name:&#x27;hello&#x27;&#125;, function(ev)&#123; alert(ev.data.name); //ev.data代表传入的的数据整体&#125;); 三、event事件对象 event对象 : 函数中传入的第一个参数就是，不需要做兼容 event.target 触发事件的DOM元素，事件源 event.delegateTarget 绑定了当前正在调用jQuery 事件处理器的元素。 event.currentTarget 在事件冒泡过程中的当前DOM元素，这个属性总是等于函数的this。 event.type ：事件类型 event.which : 键值，类似于keyCode，但包含鼠标等更多键值 event.metaKey 表示事件触发时哪个Meta键被按下。 ⌘/⊞ event.pageX / event.pageY ：相对文档的鼠标坐标 (clientX是相对于可视区) event.data 当前正在执行的处理程序绑定时，一个可选的数据对象传递给一个事件方法。 接收传递事件的数据 event.timeStamp 这个属性返回事件触发时距离1970年1月1日的毫秒数。 event.result 事件被触发的一个事件处理程序的最后返回值，除非值是 undefined。 event.preventDefault() ：阻止默认事件 event.stopPropagation() ：阻止冒泡的操作 event.stopImmediatePropagation() 阻止剩余的事件处理函数执行并且防止事件冒泡到DOM树上。 event.isDefaultPrevented() 根据事件对象中是否调用过 event.preventDefault() 方法,来返回一个布尔值。 event.isImmediatePropagationStopped() 根据事件对象中是否调用过 event.stopImmediatePropagation() 方法,来返回一个布尔值。 event.isPropagationStopped() 根据事件对象中是否调用过 event.stopPropagation() 方法,来返回一个布尔值。 return false ：阻止默认事件 + 阻止冒泡的操作","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://wzr1998.github.io/categories/jQuery/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://wzr1998.github.io/tags/jQuery/"}]},{"title":"jQuery 获取元素宽高&距离、DOM操作","slug":"jQuery-获取元素宽高-距离、DOM操作","date":"2018-04-25T03:46:43.000Z","updated":"2020-11-26T03:47:13.659Z","comments":true,"path":"posts/85e00bf0/","link":"","permalink":"http://wzr1998.github.io/posts/85e00bf0/","excerpt":"","text":"一、jQuery 获取元素宽高 jq中，所有获取元素宽高的方法都能获取到隐藏元素(display:none)的值(原生不可以) $('div').width()：width $('div').innerWidth()：width + padding $('div').outerWidth()：width + padding + border $('div').outerWidth(true)：width + padding + border + margin 二、jQuery 获取距离 $(el).offset() ：获取到文档的距离(不管父级有没有定位)，从 $('#el').offset().left 和 $('#el').offset().top 中获取 $(el).position() ：获取到有定位的父级的距离，从 $('#el').position().left 和 $('#el').position().top 中获取 滚动距离：$(window).scrollTop()为窗口滚动距离 三、jQuery 中 DOM 操作 1. 插入元素 $(el).insertBefore() / $(el).before() ：在指定节点前边添加元素 $(el).insertAfter() / $(el).after() ：在指定节点后边添加元素 $(el).appendTo() / $(el).append() ：把元素添加在指定节点内部末尾 $(el).prependTo() / $(el).prepend() ：把元素添加在指定节点内部头部 注意：前边是动词，后边是名词，后续的链式操作针对的元素不同 12$(newNode).insertBefore(&quot;div&quot;).css(&#x27;background&#x27;,&#x27;red&#x27;);//针对newNode$(&quot;div&quot;).before(newNode).css(&#x27;background&#x27;,&#x27;red&#x27;);//针对div，效果相同 2. 查找父节点 $(el).parents() : 获取当前元素的所有祖先节点，参数就是筛选功能，例 ：$(’#div2’).parents(’.box’) $(el).closest() : 获取最近的指定的祖先节点(包括当前元素自身)，必须要写筛选的参数，只能找到一个元素 3. 查找兄弟节点 $(el).siblings() : 找所有的兄弟节点，参数也是筛选功能 $(el).nextAll() / $(el).prevAll(): 下/上面所有的兄弟节点，参数也是筛选功能 4. 查找范围节点 slice()：根据指定的下标范围，过滤匹配的元素集合，并生成一个新的 jQuery 对象 如：$('li').slice(1,4) 则选中下标为123的元素，不包含截止元素 $(el).parentsUntil()：逐层查找父级节点，参数为截止节点(不包括参数) $(el).nextUntil()：逐一查找上一个节点，参数为截止节点(不包括参数) $(el).prevUntil()：逐一查找下一个节点，参数为截止节点(不包括参数) 5. 克隆节点 $(el).clone() : 克隆节点，接收一个参数为true时，可以复制之前的操作行为 6. 删除节点 $(el).remove() ：删除节点，不会保留节点下的操作行为 $(el).detach(): 删除节点，但会保留删除这个元素的操作行为 7. 节点包装 $(el).wrap() : 包装，在元素外围添加父级，例 ：$('span'). wrap('&lt;div&gt;'); $(el).wrapAll() : 整体包装，当整体中有其他元素时，改元素会被剪切到整体包装的外部 $(el).wrapInner() : 内部包装 $(el).unwrap() : 删除包装 ( 删除父级 : 不包括body ) 8. 创建节点 通过$('&lt;div&gt;') / $('&lt;div&gt;div&lt;/div&gt;')直接生成节点 9. 添加到集合 $(el).add()：添加某元素到匹配的元素集合。","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://wzr1998.github.io/categories/jQuery/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://wzr1998.github.io/tags/jQuery/"}]},{"title":"jQuery 的引入和入门：选择元素、$ & $() 下常用方法","slug":"jQuery-的引入和入门：选择元素、-下常用方法","date":"2018-04-22T03:44:33.000Z","updated":"2020-11-26T03:45:38.539Z","comments":true,"path":"posts/405c0a7d/","link":"","permalink":"http://wzr1998.github.io/posts/405c0a7d/","excerpt":"","text":"一、开始！ 1. jQuery 的引入 jQuery官网、jQuery中文网、BootCDN 引入： 12&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.5.1/jquery.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt; 2. 加载问题 $(function(){ })：等DOM加载完就可以执行了 , 性能要好 $(document).ready(function(){ }) ：作用同window.onload 二、jQuery 写法 1. 方法函数化 获取元素，绑定事件等所有行为都要加括号 2. 链式操作 123456$(&#x27;#div1&#x27;) .html(&#x27;hello&#x27;) .css(&#x27;background&#x27;,&#x27;red&#x27;) .click(()=&gt;&#123; alert(&#x27;#div1&#x27;); &#125;); 3. 取值赋值合体 同一个方法，根据参数区分取值和赋值 $('#div1').html() / $('#div1').html('hello') $('#div1').css('width') /$('#div1').css('width','200px') 注意 ：当一组元素的时候，取值是一组中的第一个，赋值是一组中的所有元素 4. jQuery与 JavaScript 关系 可以共存，不能混用 三、jQuery 选择元素 1. 模拟css选择器 $(’#div1’) $(‘div’) $(’.box’) $(’.ul1 li’) $(’[title=hello]’) 2. 独有表达式选择 (1). 按索引选择 注意有冒号 $(‘li:eq(i)’) ：第i个元素，i从0开始 $('li:even’) ：奇数行 $(‘li:odd’) ：偶数行 (2). 筛选 $(el).filter()：筛选 $(el).not() ：不选某一元素 (针对元素自身) ​ 例 ：$('div').filter('.box').css('background','red'); (3). 包含、查找 $(el).has() ：包含 (针对元素内部) $(el).find() ：内部寻找(可以通过模拟css选择器实现) (4). 选择兄弟节点 $(el).next()：上一个兄弟节点(不是所有) $(el).prev() ：下一个兄弟节点(不是所有) 四、$(el) 下常用方法 $(el).attr() : 设置属性 例 ：$('div').attr('class','box'); $(el).html() ：获取元素中内容(同innerHTML) $(el).val() ：获取/修改元素value值 $(el).text() ：获取一组元素中所有纯文本(不带标签)，把所有文字串联后返回(特例，获取所有)；设置时默认时纯文本(不会转成标签) $(el).index() ：索引，返回当前元素在所有兄弟节点中的位置 $(el).addClass() / removeClass() ：添加 / 删除class $(el).size() ：获取一组元素的长度(类似length)，注意 $('#ui1 li').length 为jq下的属性 $(el).each() ：jq中的循环 123$(&#x27;#ul1 li&#x27;).each(function( i, element)&#123; $(element).html(i);&#125;); $(el).get() ：把jq元素转成原生js，转成一个元素时必须要有参数(索引)，不加参数默认为一组元素。 12$(&#x27;#div1&#x27;).get(0).innerHTML如 ：$(&#x27;li&#x27;)[0].style.background = &#x27;red&#x27;; 五、$ 下的常用方法 $.type() : 判断数据类型，但能判断的类型更精确 $.trim() ：去掉字符串前后空格 $.inArray(item, arr) : 类似于 indexOf，找不到返回-1 $.proxy(function, newThis, [args…]) : 改变this指向，返回一个函数， $.noConflict() : 从全局放弃 $ 变量名，防止冲突。 如 var wzr = $.noConflict() 则后续 wzr() 等同于 $() $.parseJSON() ：把严格模式的字符串转化成json对象 $.makeArray() ：把类似数组对象(节点列表)转化成真正的js数组。 六、拓展插件 $.extend() : 扩展工具方法下的插件形式 $.fn.extend() : 扩展到jq对象下的插件形式，内部的this指向使用该方法的jq对象 用法 ：参数为一个json，key值为函数名，value为函数主体，可以包含多个函数 1234$.extend(&#123; alert1:function()&#123; alert(1); &#125;, alert2:function()&#123; alert(2); &#125;&#125;);","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://wzr1998.github.io/categories/jQuery/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://wzr1998.github.io/tags/jQuery/"}]},{"title":"CSS3 animation动画","slug":"CSS3-animation动画","date":"2018-04-18T03:42:54.000Z","updated":"2020-11-26T03:43:32.400Z","comments":true,"path":"posts/74368ad1/","link":"","permalink":"http://wzr1998.github.io/posts/74368ad1/","excerpt":"","text":"CSS animations 使得可以将从一个CSS样式配置转换到另一个CSS样式配置。动画包括两个部分:描述动画的样式规则和用于指定动画开始、结束以及中间点样式的关键帧。 链接 一、CSS3 动画优点 相较于传统的脚本实现动画技术，使用CSS动画有三个主要优点： 能够非常容易地创建简单动画，你甚至不需要了解JavaScript就能创建动画。 动画运行效果良好，甚至在低性能的系统上。渲染引擎会使用跳帧或者其他技术以保证动画表现尽可能的流畅。而使用JavaScript实现的动画通常表现不佳（除非经过很好的设计）。 让浏览器控制动画序列，允许浏览器优化性能和效果，如降低位于隐藏选项卡中的动画更新频率。 二、animation 语法：animation: name duration timing-function delay iteration-count direction fill-mode play-state; 链接 注：name必须的，若出现两个时间，则第一个是duration，第二个是delay animation 子属性 animation-name ：animation-name: keyframeName | none; 动画名称 animation-duration ：animation-duration: time; 持续时间 animation-timing-function ：linear | ease | ease-in | ease-out | ease-in-out | cubic-bezier(n, n, n, n); 运动方式，默认ease animation-delay ：time 延迟时间，事件为秒或毫秒，默认为0 animation-iteration-count ：infinite | ; 定义循环次数，默认为0，infinite为无限循环 animation-direction ：normal | reverse | alternate | alternate-reverse | initial | inherit; 定义是否反向运动 reverse ：反方向运动 alternate ：先正后反，交替运行 alternate-reverse ：先反后正，交替运行 animation-fill-mode : none | forwards | backwards | both; 属性规定动画在播放之前或之后，要应用到元素的样式 none ：默认值，不设置对象动画之外的状态 forwards / backwards / both ：设置对象状态为 [结束 / 开始 / 两者] 时的状态 animation-play-state: paused | running; 指定动画时候正在运行或已暂停，可在伪类或js中添加控制 二、@keyframes 1. 语法 123@keyframes animationName&#123; keyframes-selector&#123; css-styles; &#125;&#125; animationName必须写，定义animation的名称 keyframes-selector为动画持续时间的百分比，form为0%，to为100%，如果初始和结尾不写则默认为元素CSS原有样式 css-styles为一个或多个合法的CSS样式 兼容性问题：@-webkit-keyframes，浏览器内核前缀写在@表示符后边 2. 示例 123456@keyframes circle &#123; form&#123; transform: rotateX(0deg); &#125; 25% &#123; transform: rotateX(45deg); &#125; 75% &#123; transform: rotateX(315deg); &#125; to &#123; transform: rotateX(360deg); &#125;&#125; 三、will-change 作用：提前告知浏览器元素做什么动画，让浏览器提前准备合适的优化设置，把渲染工作发送给GPU(图形处理器) 链接 语法：will-change ：auto | scroll-position | contents | &lt;custom-ident&gt; | &lt;animatable-feature&gt; auto ：表示没有特定意图 scroll-position ：表示将要改变元素的滚动位置 contents ：表示将要改变的元素内容 &lt;custom-ident&gt; ：明确指定将要改变的属性与给定的名称，如 animation / transition / transform 等 &lt;animatable-feature&gt; ：可用动画的一些特定值，比如 left / top / margin 等 注意： 不要滥用：可以写在有动画时的伪类当中(如:hover)，伪类结束则会自动移除will-change 提前声明：CSS运动代码写在will-change之前 及时移除：停止时及时用js等进行移除(设置will-change值为auto)","categories":[{"name":"CSS","slug":"CSS","permalink":"http://wzr1998.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://wzr1998.github.io/tags/CSS/"},{"name":"CSS3","slug":"CSS3","permalink":"http://wzr1998.github.io/tags/CSS3/"}]},{"title":"CSS3 transform 变换","slug":"CSS3-transform-变换","date":"2018-04-15T03:42:19.000Z","updated":"2020-11-26T03:42:40.415Z","comments":true,"path":"posts/39f4e187/","link":"","permalink":"http://wzr1998.github.io/posts/39f4e187/","excerpt":"","text":"CSStransform属性允许旋转，缩放，倾斜或平移给定元素。这是通过修改CSS视觉格式化模型的坐标空间来实现的。 链接 transform-function 一、transform 属性 作用：让元素在一个坐标系统中变形，这个属性包含一溪流变形函数，可以移动、旋转和缩放元素 语法：transform : none | &lt;transform-function&gt; [&lt;transform-function&gt;]...; 执行顺序：后写的先执行，先写的后执行，后执行的变换可能影响先执行的变换 二、transform-origin 坐标系统(变换基点) transform-origin CSS属性可更改一个元素变形的原点，转换起点是应用转换的点。例如，rotate()函数的转换原点是旋转中心。（这个属性的应用原理是先用这个属性的赋值转换该元素，进行变形，然后再用这个属性的值把元素转换回去） 链接 语法：参数为一个值、两个值、三个值均可 一个值：必须是&lt;length&gt;，&lt;percentage&gt; 或 left, center, right, top, bottom关键字中的一个。 两个值：分别定义 x、y 轴偏移量，参数形式与一个值时相同 三个值：前两个值和只有两个值时的用法相同，第三个值必须是 &lt;length&gt;，代表Z轴偏移量。 三、2D变换 旋转：rotate() / ['rotet]/ 参数为指旋转角度&lt;angle&gt;，角度增大顺时针旋转(正值顺时针，负值逆时针) 移动：translate() / translateX() / translateY() 参数为移动距离&lt;translation-value&gt;，单位为px | %，translate()只写一个参数默认X轴偏移 缩放：scale() / scaleX() / scaleY() /[skeɪl]/ 参数为缩放比例(无单位) &lt;number&gt;，默认从中心缩放，scale()只写一个参数默认等比缩放 扭曲：skew() / skewX() / skewY() /[skjuː]/倾斜变换 参数为斜切角度&lt;angle&gt;，有效值为-90deg～90deg，skew()只写一个参数默认为X轴扭曲 skewX()方向：正值逆时针，负值顺时针 skewY()方向：正值顺时针，负值逆时针 矩阵：matrix(a, c, b, d, tx, ty) /['meɪtrɪks]/ 四、3D变换 旋转：rotate3d(x, y, z, angle) / rotateX() / rotateY() / rotateZ() rotate3d()中前三个参数可以表示该方向的旋转程度，参数都不允许省略 移动：translate3d(x, y, z) / translateZ() 改变对象离观察者远近//translateZ()通常用于遮照 translate3d()中三个参数都不能省略 缩放：scale3d() / scaleZ() scale3d()中三个参数都不能省略 矩阵：matrix3d(sx, n, n, n, n, sy, n, n, n, n, sz, n, n, n, n, 1) 五、其他属性 transform-style : falt | preserve-3d：规定如何在 3D 空间中呈现被嵌套的元素 perspective : number(px)：景深，指定观察者与[z=0]平面的距离，使具有三维位置变换的元素产生透视效果 perspective-origin : x-axis y-axis：指定透视点的位置(方位词或%) backface-visibility ： visible | hidden：指定元素背面面对用户时是否可见","categories":[{"name":"CSS","slug":"CSS","permalink":"http://wzr1998.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://wzr1998.github.io/tags/CSS/"},{"name":"CSS3","slug":"CSS3","permalink":"http://wzr1998.github.io/tags/CSS3/"}]},{"title":"CSS3 gradient渐变","slug":"CSS3-gradient渐变","date":"2018-04-12T03:41:41.000Z","updated":"2020-11-26T03:42:08.711Z","comments":true,"path":"posts/3568693a/","link":"","permalink":"http://wzr1998.github.io/posts/3568693a/","excerpt":"","text":"CSS 渐变 image 类型的一种特殊类型 gradient 表示，由两种或多种颜色之间的渐进过渡组成。可以选择线性渐变、径向渐变、重复渐变。 链接 一、linear-gradient 线性渐变 语法：background: linear-gradient(direction, color1 [stop] [,color1 [stop]...]); 链接 1. direction 渐变角度 从上到下 ：默认，可以省略 指定方向：不同内核标准不同 水平/垂直方向：指定一个开始或结束方向 1234567语法：background:-webkit-linear-gradient( begin-direction, color1 [stop]...);background: -moz-linear-gradient( end-direction, color1 [stop]...);background: -o-linear-gradient( end-direction, color1 [stop]...);background: linear-gradient(to end-direction, color1 [stop]...);例：linear-gradient(to right, red , blue); 对角线方向：指定一个开始或结束时水平、垂直两个方向 1234567语法：background:-webkit-linear-gradient(begin-level begin-vertical, color1 [stop]...);background: -moz-linear-gradient( end-level end-vertical, color1 [stop]...);background: -o-linear-gradient( end-level end-vertical, color1 [stop]...);background: linear-gradient( to end-level end-vertica, color1 [stop]...);例：linear-gradient(to right bottom, red, yellow, blue); 使用角度： 0deg 代表渐变方向为从下到上, 90deg 代表渐变方向为从左到右，诸如此类正角度都属于顺时针方向。 而负角度意味着逆时针方向。 123**语法**：linear-gradient(angle, color1 [stop]...);例：linear-gradient(135deg, red, yellow, blue); 2. 设置颜色结点 例：linear-gradient(90deg, red 10%, yellow 20%, green 50%, blue 70%); 二、radial-gradient 径向渐变 径向渐变(Radial gradients)由其中心点、边缘形状轮廓及位置、色值结束点（color stops）定义而成。 径向渐变的中心点至边缘形状以及其延伸的部分，由连续缩放的若干同心轮廓组成，这个轮廓由设定的边缘形状决定。 链接 1. 语法 1radial-gradient([center], [shape size], color position[, color position]...); center ：圆心位置，分别为X、Y方向位置，单位为px或% shape ：形状，值为circle / ellipse 圆形 / 椭圆(默认) size ：描述边缘轮廓的具体位置，值为closest-side / farthest-side / closest-corner / farthest-corner，最近边 / 最远边 / 最近角 / 最远角 注意：形状和尺寸是用一个参数，用空格隔开，中间不能有逗号 2. 示例 1div: &#123;background: radial-gradient(20% 70%, ellipse farthest-corner, red 30%, blue 60%);&#125; 则该渐变区域内中心30%部分为红色，30%-60%部分为渐变色，60%-100%部分为蓝色 三、重复渐变 1. 重复线性渐变 语法：repeating-linear-gradient(direction, color1 stop [,color1 stop...]); 例：repeating-linear-gradient(90deg, red 0%, blue 10%, red 20%); 2. 重复径向渐变 语法：repeating-radial-gradient([center], [shape size], color position[, color position]...); 例：repeating-radial-gradient(red 0%, blue 10%, red 20%);","categories":[{"name":"CSS","slug":"CSS","permalink":"http://wzr1998.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://wzr1998.github.io/tags/CSS/"},{"name":"CSS3","slug":"CSS3","permalink":"http://wzr1998.github.io/tags/CSS3/"}]},{"title":"CSS3 transition 过渡","slug":"CSS3-transition过度","date":"2018-04-11T03:38:54.000Z","updated":"2020-11-26T03:41:24.020Z","comments":true,"path":"posts/8d2f8c4e/","link":"","permalink":"http://wzr1998.github.io/posts/8d2f8c4e/","excerpt":"","text":"CSS Transitions 是一个 CSS 模块，定义了如何创建一个平滑地变换 CSS 属性值的方法。它不仅允许创建变换方法，同时也允许通过定时函数来控制变换方法。 链接 transition 符合属性，语法：transition: property duration timing-function delay, [property duration timing-function delay]... 链接 1. 详细属性 transition-property ：none | all | property 过渡属性，默认为all transition-duration ： &lt;time&gt; 过渡时间，事件为秒或毫秒，默认为0 transition-timing-function ：linear | ease | ease-in | ease-out | ease-in-out | cubic-bezier(n, n, n, n); 运动方式，默认ease transition-delay ：&lt;time&gt; 延迟时间，事件为秒或毫秒，默认为0 2. transitionend事件 transition过渡完毕后触发","categories":[{"name":"CSS","slug":"CSS","permalink":"http://wzr1998.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://wzr1998.github.io/tags/CSS/"},{"name":"CSS3","slug":"CSS3","permalink":"http://wzr1998.github.io/tags/CSS3/"}]},{"title":"CSS3 分栏布局、Flex布局","slug":"CSS3-分栏布局、Flex布局","date":"2018-04-09T03:38:10.000Z","updated":"2020-11-26T03:46:03.062Z","comments":true,"path":"posts/299087b5/","link":"","permalink":"http://wzr1998.github.io/posts/299087b5/","excerpt":"","text":"一、 CSS Multi-column Layout Module 增加简单的多列布局， 使用 CSS columns， column-count， column-fill， column-gap， column-rule， column-rule-color， column-rule-style， column-rule-width， column-span， column-width， break-after， break-before， 和 break-inside。 column-width：栏目宽度 column-count：栏目列数 column-gap：栏目距离 column-rule：栏目间隔线(写法同border) 二、弹性盒模型：flex布局 CSS 弹性盒子布局是 CSS 的模块之一，定义了一种针对用户界面设计而优化的 CSS 盒子模型。在弹性布局模型中，弹性容器的子元素可以在任何方向上排布，也可以“弹性伸缩”其尺寸，既可以增加尺寸以填满未使用的空间，也可以收缩尺寸以避免父元素溢出。子元素的水平对齐和垂直对齐都能很方便的进行操控。通过嵌套这些框（水平框在垂直框内，或垂直框在水平框内）可以在两个维度上构建布局。 参考网站：MDN、阮一峰 1. 容器的属性 flex-direction：决定主轴的方向（即项目的排列方向）。 flex-direction: row | row-reverse | column | column-reverse; justify-content：定义项目在主轴上的对齐方式。 justify-content: flex-start | flex-end | center | space-between | space-around; align-items：定义项目在交叉轴上如何对齐。 align-items: flex-start | flex-end | center | baseline | stretch; flex-wrap：如果一条轴线排不下，如何换行。 flex-wrap: nowrap | wrap | wrap-reverse; align-content：定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 align-content: flex-start | flex-end | center | space-between | space-around | stretch; flex-flow：是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; 2. 项目的属性 order：定义项目的排列顺序。数值越小，排列越靠前，默认为0。 order: &lt;integer&gt;; flex-grow：定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 flex-grow: &lt;number&gt;; flex-shrink：定义项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 flex-shrink: &lt;number&gt;; flex-basis：定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 flex-basis: &lt;length&gt; | auto; flex：是flex-grow, flex-shrink 和flex-basis的简写，默认值为0 1 auto。后两个属性可选。 flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ] align-self：允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 align-self: auto | flex-start | flex-end | center | baseline | stretch;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://wzr1998.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://wzr1998.github.io/tags/CSS/"},{"name":"CSS3","slug":"CSS3","permalink":"http://wzr1998.github.io/tags/CSS3/"}]},{"title":"CSS3 文本相关属性","slug":"CSS3-文本相关","date":"2018-04-06T03:36:42.000Z","updated":"2020-11-26T03:37:49.559Z","comments":true,"path":"posts/30b0bf15/","link":"","permalink":"http://wzr1998.github.io/posts/30b0bf15/","excerpt":"","text":"一、CSS Fonts Module Level 3 1. CSS3 新拓展 修正 CSS2.1 字体匹配算法，以便接近于真实的实现。 增加： 通过 CSS @font-face @ 规则来支持可下载字体。 借助 CSS font-kerning 属性来控制 contextual inter-glyph spacing(上下文 inter-glyph 间距)。 借助 CSS font-language-override 属性来选择语言指定的字形。 借助 CSS font-feature-settings 属性来选择带有 OpenType 特性的字形。 借助 CSS font-size-adjust 属性来控制当使用 fallback fonts(备用字体) 时的宽高比。 选择替代字体，使用 CSS font-stretch，font-variant-alternates，font-variant-caps，font-variant-east-asian，font-variant-ligatures，font-variant-numeric，和 font-variant-position 属性。还扩展了相关的 CSS font-variant 速记属性，并引入了 @font-features-values @ 规则。 当这些字体在 CSS font-synthesis 属性中找不到时自动生成斜体或粗体的控制。 2. 自定义字体 语法：链接 ，注意不能跨域 1234567891011@font-face &#123; [ font-family: &lt;family-name&gt;; ] || [ src: &lt;src&gt;; ] || [ unicode-range: &lt;unicode-range&gt;; ] || [ font-variant: &lt;font-variant&gt;; ] || [ font-feature-settings: &lt;font-feature-settings&gt;; ] || [ font-variation-settings: &lt;font-variation-settings&gt;; ] || [ font-stretch: &lt;font-stretch&gt;; ] || [ font-weight: &lt;font-weight&gt;; ] || [ font-style: &lt;font-style&gt;; ]&#125; 例： 12345678910@font-face &#123; font-family: &#x27;wzr&#x27;; src: url(&#x27;wzr.eot&#x27;); src: url(&#x27;wzr.eot?#iefix&#x27;) format(&#x27;embedded-opentype&#x27;), url(&#x27;wzr.woff&#x27;) format(&#x27;woff&#x27;), url(&#x27;wzr.ttf&#x27;) format(&#x27;truetype&#x27;), url(&#x27;wzr.svg#wzr&#x27;) format(&#x27;svg&#x27;); font-weight: normal; font-style: normal;&#125; 二、CSS Text Decoration Module Level 3 拓展CSS text-decoration 属性作为 CSS text-decoration-line， text-decoration-color， 和 text-decoration-style 属性的简写形式。并增加了 text-decoration-skip， 和 text-underline-position 属性。 1. 文字阴影 text-shadow 语法：text-shadow：x y blur color, [x y blur color]...； 链接 参数分别为：横向偏移、纵向偏移、模糊距离、阴影颜色，后边可以跟好几个阴影叠加 2. 文字描边 ：-webkit-text-stroke 语法：-webkit-text-stroke: &lt;length&gt; &lt;color&gt; 链接 注：仅 webkit 内核实现 三、CSS Writing Modes Module Level 3 CSS unicode-bidi属性，和 direction 属性，决定如何处理文档中的双书写方向文本（bidirectional text）。比如，如果一块内容同时包含有从左到右书写和从右到左书写的文本，那么用户代理（the user-agent）会使用复杂的 Unicode 算法来决定如何显示文本。unicode-bidi 属性会覆盖此算法，允许开发人员控制文本嵌入（text embedding）。 链接 1. 文本水平溢出方向(文本书写方向)：direction 语法：direction : ltr | rtl 链接 设置文本、表列水平溢出的方向。 rtl 表示从右到左 (类似希伯来语或阿拉伯语)， ltr 表示从左到右 (类似英语等大部分语言). 2. 文本方向：unicode-bidi 语法：unicode-bidi : normal | embed | bidi-override | isolate | isolate-override | plaintext 链接 3. 文本溢出处理 text-overflow 语法：text-overflow: clip | ellipsis | &lt;string&gt; clip(默认)：在内容区域的极限处截断文本，因此在字符的中间可能会发生截断 ellipsis：溢出处用省略号来表示被截断的文本 &lt;string&gt;：用来表示被截断的文本，有兼容性问题 4. 单行文字超出显示省略号 1#longText: &#123;white-space : nowrap; overflow:hidden; text-overflow:ellipsis;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://wzr1998.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://wzr1998.github.io/tags/CSS/"},{"name":"CSS3","slug":"CSS3","permalink":"http://wzr1998.github.io/tags/CSS3/"}]},{"title":"CSS3 颜色、背景、边框","slug":"CSS3-颜色、背景、边框","date":"2018-04-03T03:35:55.000Z","updated":"2020-11-26T03:36:23.415Z","comments":true,"path":"posts/7cd3fe5a/","link":"","permalink":"http://wzr1998.github.io/posts/7cd3fe5a/","excerpt":"","text":"一、CSS Color Module Level 3 rgba()：红、绿、蓝、透明度 rgba()：红、绿、蓝、透明度 hsl()：色调、饱和度、亮度 hsla()：色调、饱和度、亮度、透明度 opcity：透明度(0-1)，子元素默认继承，当前元素和内容一起透明 链接 二、CSS Borders Module Level 3 (1). 边框圆角 border-radius border-radius：复合属性，最多有四个值，分别为左上角顺时针至左下角，可以用 ’/’ 控制水平垂直不同圆角半径，前边是x轴半径，后边是y轴半径，圆角方向不变。链接 例： 1border-radius ：30px 50px/80px 100px (2). 边框图片 border-image 语法：border-image : url slice width outset repeat; 链接 其中： slice属性指定图像的边界向内偏移，值为% | fill width：指定边界宽度，值为% | auto outset：指定图像向外扩张距离，值为数字，表示边框宽度的倍数 repeat：值为stretch、repeat、round、initial、inherit，为拉伸、重复、铺满、默认(stretch)、继承 (3). 盒阴影 box-shadow 语法：box-shadow : h-shadow v-shadow [blur] [spread] color [insert] 具体为：水平偏移、垂直偏移、模糊半径、扩展范围、颜色、是否为内阴影 三、CSS Backgrounds Module Level 3 (1). 多重背景图片 语法：background: url(‘img1.jpg’), url(‘img2.jpg’)... 设置图像位置： 123456div&#123; background: url(&quot;1.jpg&quot;) 0 0 no-repeat, url(&quot;2.jpg&quot;) 500px 10px no-repeat, url(&quot;3.jpg&quot;) 300px 300px no-repeat;&#125; 注 ：元素引用多个背景图片，前面图片会依次覆盖后边图片 (2). 背景摆放位置 background-origin background-origin 规定了指定背景图片background-image 属性的原点位置的背景相对区域. 语法：background-origin : border-box | padding-box | content-box 链接 属性值分别为：背景图片的摆放以border/padding/content区域为参考 (3). 背景绘制区域 background-clip 语法：background-clip : border-box | padding-box | content-box | [text] 链接 语法：background-size : length | percentage | cover | contain 链接 length ：数值(px)，设置宽高 percentage ：百分比，设置宽高 cover ：将背景图像等比缩放以填满整个容器contain ：将背景图像等比缩放至某一边紧贴容器边缘为止 contain ：将背景图像等比缩放至某一边紧贴容器边缘为止 (5). background属性复合写法 语法：background: color position size repeat origin clip attachment image; 链接 注：建议分开写，便于后期维护 12345678div&#123; background: #666666 url(‘img1.jpg’) no-repeat center center; background-size: 50%; background-origin: content-box; background-clip: content-box; background-attachment: fixed;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://wzr1998.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://wzr1998.github.io/tags/CSS/"},{"name":"CSS3","slug":"CSS3","permalink":"http://wzr1998.github.io/tags/CSS3/"}]},{"title":"CSS3 新增选择器","slug":"CSS3新增选择器","date":"2018-04-01T03:34:14.000Z","updated":"2020-11-26T03:36:09.154Z","comments":true,"path":"posts/807ac073/","link":"","permalink":"http://wzr1998.github.io/posts/807ac073/","excerpt":"","text":"一、属性选择器 E[attr]：只使用属性名，但没有确定任何属性值 E[ attr = &quot;value&quot; ]：指定属性名，并指定了该属性的属性值 E[ attr ~= &quot;value&quot; ]：指定属性名，并且具有属性值，此属性值是一个词列表，并且以空格隔开，其中词列表中包含了一个 E[ attr ^= &quot;value&quot; ]：指定了属性名，并且有属性值，属性值是以value开头的 E[ attr $= &quot;value&quot; ]：指定了属性名，并且有属性值，而且属性值是以value结束的 E[ attr *= &quot;value&quot; ]：指定了属性名，并且有属性值，而且属值中包含了value E[ attr |= &quot;value&quot; ]：指定了属性名，并且属性值是value或者以“value-”开头的值（如data-name） 二、CSS3 结构性伪类选择器 E:nth-child(n) ：表示E父元素中的第n个字节点 p:nth-child(odd){background:red} /*匹配奇数行*/ p:nth-child(even){background:red} /*匹配偶数行*/ p:nth-child(2n){background:red}} /*匹配偶数行*/ E:nth-last-child(n) ：表示E父元素中的第n个字节点，从后向前计算 E:first-child ：表示E元素中的第一个子节点 E:last-child ：表示E元素中的最后一个子节点 E:only-child ：表示E元素中只有一个子节点。注意：子节点不包含文本节点 E:nth-of-type(n) ：表示E父元素中的第n个字节点，且类型为E E:nth-last-of-type(n) ：表示E父元素中的第n个字节点，且类型为E,从后向前计算 E:first-of-type ：表示E父元素中的第一个子节点且节点类型是E的 E:last-of-type ：表示E父元素中的最后一个子节点且节点类型是E的 E:only-of-type ：表示E的父元素中只有一个子节点，且这个唯一的子节点的类型必须是E。注意：子节点不包含文本节点 E:empty ：表示E元素中没有子节点。注意：子节点包含文本节点 注：同一父级内有不同子元素，要选中其中一个字元素，可用parent *:nth-child()实现 三、CSS3 功能性伪类选择器 E:target ：表示当前的URL片段的元素类型，这个元素必须是E E:disabled ：表示不可点击的表单控件 E:enabled ：表示可点击的表单控件 E:checked ：表示已选中的checkbox或radio E:not(selector) ：表示E元素不被匹配 E~F ：表示E元素毗邻的F元素 四、CSS3 伪元素 E::first-line 表示E元素中的第一行(只能用于块级元素) E::first-letter 表示E元素中的第一个字符(只能用于块级元素) E::selection表示E元素在用户选中文字时，用于设置选中文本后的前景色和背景色 E::before 生成内容在E元素前(配合content使用) E::after 生成内容在E元素后(配合content使用)","categories":[{"name":"CSS","slug":"CSS","permalink":"http://wzr1998.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://wzr1998.github.io/tags/CSS/"},{"name":"CSS3","slug":"CSS3","permalink":"http://wzr1998.github.io/tags/CSS3/"}]},{"title":"HTML 响应式瀑布流布局","slug":"响应式瀑布流布局","date":"2018-03-23T18:59:09.000Z","updated":"2020-11-26T03:37:03.599Z","comments":true,"path":"posts/36b8de9d/","link":"","permalink":"http://wzr1998.github.io/posts/36b8de9d/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;响应式瀑布流&lt;/title&gt; &lt;style&gt; div&#123;height:200px; width:200px; background:#f00; position:absolute; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; for( let i=0; i&lt;500; i++) document.body.appendChild(document.createElement(&#x27;div&#x27;)); let aDiv = document.getElementsByTagName(&#x27;div&#x27;); let arr = []; for(let i=0; i&lt;aDiv.length; i++)&#123; aDiv[i].style.height = Math.floor( Math.random()*200 ) + 200 + &#x27;px&#x27;; &#125; position(); window.onresize = position; function position()&#123; let column = Math.floor(document.documentElement.clientWidth/210); let index = 0; arr = []; for(let i=0; i&lt;aDiv.length; i++)&#123; if(i&lt;column)&#123; aDiv[i].style.left = 10 + i%column*210 + &#x27;px&#x27;; aDiv[i].style.top = 10 + &#x27;px&#x27;; arr.push(aDiv[i].offsetHeight+10); if( arr[index] &gt; arr[i]) index = i; &#125;else&#123; aDiv[i].style.left = 10 + index*210 + &#x27;px&#x27;; aDiv[i].style.top = arr[index] + 10 + &#x27;px&#x27;; arr[index] += aDiv[i].offsetHeight + 10; if( arr[index] &gt; arr[i%column]) index = i%column; &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML","slug":"HTML","permalink":"http://wzr1998.github.io/categories/HTML/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"http://wzr1998.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://wzr1998.github.io/tags/CSS/"},{"name":"布局","slug":"布局","permalink":"http://wzr1998.github.io/tags/%E5%B8%83%E5%B1%80/"}]},{"title":"JavaScript Web Worker实现多线程","slug":"JavaScript-Web-Worker实现多线程","date":"2018-03-22T03:31:29.000Z","updated":"2020-11-26T03:33:08.041Z","comments":true,"path":"posts/49d1db77/","link":"","permalink":"http://wzr1998.github.io/posts/49d1db77/","excerpt":"","text":"HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程进行数据处理，子线程完全受主线程控制，且不得操作DOM，其中有worker文件内部self对象指向自身，子线程不影响主线程执行，子线程执行完毕后发送数据返回给主线程 一、主线程引入worker 使用 new Worker('worker.js') 引入外部worker文件，开启一个子线程，使用 worker.postMessage(data) 向子线程发送数据，通过监听 message 事件接收子线程发送数据 123456//index.js文件const worker = new Worker(&#x27;worker.js&#x27;);worker.postMessage(111); //向主线程发送数据worker.addEventListener(&#x27;message&#x27;, event=&gt;&#123; console.log(event.data); //接收到worker的数据&#125;) 二、Web Worker 可通过 importScripts() 引入其他模块文件，内部self对象指向自身，监听 message 事件获取主线程发送的数据，内部使用 self.postMessage() 向主线程发送数据 允许使用 所有的ECMA原生对象，Object、Array、Date等 XMLHttpRequest、fetch setTimeout、setInterval 1234567//worker.js文件importScripts(&#x27;worker2.js&#x27;);self.addEventListener(&#x27;message&#x27;, function(event)&#123; console.log(event.data); //接收到主线程的数据 //一系列复杂运算 self.postMessage(result); //向主线程发送数据&#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"HTML5","slug":"HTML5","permalink":"http://wzr1998.github.io/tags/HTML5/"}]},{"title":"HTML5 AJAX2.0","slug":"HTML5-AJAX2-0","date":"2018-03-20T03:29:57.000Z","updated":"2020-11-26T03:33:55.269Z","comments":true,"path":"posts/fea93837/","link":"","permalink":"http://wzr1998.github.io/posts/fea93837/","excerpt":"","text":"一、跨域 在标准浏览器下，XMLHttpRequest 对象已经是升级版本，支持了更多的特性，支持跨域，但如果想实现跨域请求，还需要后端的相关配合才可以 服务端端设置：Access-Control-Allow-Origin: http://xxx.com ，设置可获取数据的域名，&quot;*&quot;为任何来源 兼容IE：使用 XDomainRequest 对象 123456const oXDomainRequest = new XDomainRequest();oXDomainRequest.onload = function() &#123; alert(this.responseText);&#125;oXDomainRequest.open(&#x27;get&#x27;, &#x27;http://www.xxx.com/ajax.php&#x27;, true);oXDomainRequest.send(); 二、进度事件 (1). 进度事件 loadstart：接收到相应数据的第一个字节时触发 progress：在接收相应期间持续触发 error：请求错误触发 abort：调用 abort() 方法终止链接时触发 load：接收到完整相应数据时触发(请求成功)，不推荐使用 readystatechange 事件 loadend：通信完成或触发 error / abort / load 时触发 (2). 监测上传/下载进度 上传：监听 xhr 对象下 progress 事件 下载：监听 xhr.upload 对象下 progress 事件 1234567xhr.addEventListener(&quot;progress&quot;, progressFn)xhr.upload.addEventListener(&quot;progress&quot;, progressFn)function progressFn(event) &#123; if (event.lengthComputable) &#123; //true为总大小已知 var percentComplete = event.loaded / event.total * 100; &#125;&#125; 注意： 需要在请求调用 open() 之前添加事件监听。否则 progress 事件将不会被触发。 三、文件上传/FormData接口 (1). 获取表单中文件数据 FileInput.files 中保存选择文件列表(类数组)，FileInput.value 为文件名 (2). FormData 使用 FormData() 接口API可以通过AJAX上传文件，注意设置请求头 12345678910const formObj = document.querySelector(&#x27;#form&#x27;);var xhr = new XMLHttpRequest();xhr.onload = function() &#123; alert(this.responseText);&#125;xhr.open(&#x27;post&#x27;, &#x27;post_file.php&#x27;, true);xhr.setRequestHeader(&#x27;X-Request-With&#x27;, &#x27;XMLHttpRequest&#x27;);const formData = new FormData(formObj);formData.append(&#x27;file&#x27;, formObj.file.files[0]);xhr.send(oFormData);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"HTML5","slug":"HTML5","permalink":"http://wzr1998.github.io/tags/HTML5/"}]},{"title":"HTML5 音视频 API","slug":"HTML5-音视频-API","date":"2018-03-17T03:28:57.000Z","updated":"2020-11-26T03:29:27.461Z","comments":true,"path":"posts/7f162871/","link":"","permalink":"http://wzr1998.github.io/posts/7f162871/","excerpt":"","text":"一、嵌入媒体 (1). 容器： 视频：&lt;audio&gt;&lt;/audio&gt; 链接 音频：&lt;vidio&gt;&lt;/vidio&gt; 链接 指定多种视频来源：&lt;source&gt;&lt;/source&gt; 链接 字幕：&lt;track&gt;&lt;/track&gt; 链接 (2). 示例： 123456&lt;video controls poster=&quot;/images/sample.gif&quot;&gt; &lt;source src=&quot;sample.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;source src=&quot;sample.ogv&quot; type=&quot;video/ogv&quot;&gt; &lt;track kind=&quot;captions&quot; src=&quot;sampleCaptions.vtt&quot; srclang=&quot;en&quot;&gt; &lt;p&gt;抱歉，您的浏览器不支持内嵌视频&lt;/p&gt;&lt;/video&gt; 二、媒体相关属性 (1). 通用属性 controls： 显示或隐藏用户控制界面 autoplay：媒体是否自动播放 loop：体是否循环播放 currentTime：开始到播放现在所用的时间 duration：媒体总时间(只读) volume： 0.0-1.0的音量相对值 muted： 是否静音 autobuffer： 开始的时候是否缓冲加载，autoplay的时候，忽略此属性 paused： 媒体是否暂停(只读) ended：媒体是否播放完毕(只读) error：媒体发生错误的时候，返回错误代码 (只读) currentSrc：以字符串的形式返回媒体地址(只读) (2). video特有属性 poster：视频播放前的预览图片 width、height：设置视频的尺寸 videoWidth、 videoHeight：视频的实际尺寸(只读) 三、媒体相关方法 play()：媒体播放 pause()：媒体暂停 load()：重新加载媒体 四、媒体相关事件 参考链接 ended：当目前的播放列表已结束时 error：当在音频/视频加载期间发生错误时 pause：当音频/视频已暂停时 play：当音频/视频已开始或不再暂停时 playing：当音频/视频在已因缓冲而暂停或停止后已就绪时 seeking：当用户开始移动/跳跃到音频/视频中的新位置时 seeked：当用户已移动/跳跃到音频/视频中的新位置时 timeupdate：当目前的播放位置已更改时 volumechange：当音量已更改时","categories":[{"name":"HTML","slug":"HTML","permalink":"http://wzr1998.github.io/categories/HTML/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"HTML5","slug":"HTML5","permalink":"http://wzr1998.github.io/tags/HTML5/"},{"name":"HTML","slug":"HTML","permalink":"http://wzr1998.github.io/tags/HTML/"}]},{"title":"HTML5 地理信息","slug":"HTML5-地理信息","date":"2018-03-15T03:28:08.000Z","updated":"2020-11-26T03:28:30.002Z","comments":true,"path":"posts/f33ed568/","link":"","permalink":"http://wzr1998.github.io/posts/f33ed568/","excerpt":"","text":"一、HTML5 地理信息 地理信息对象：navigator.geolocation 1. 获取位置方法 123456//获取一次navigator.geolocation.getCurrentPosition( successCallback, errorCallback, options )//多次获取：当位置信息有改变时重新触发，返回监听器ID值navigator.geolocation.watchPosition( successCallback, errorCallback, options )//关闭监听器navigator.geolocation.clearWatch(positionWatcher) 2. 回调参数 (1). successCallback：position=&gt;{ } 接收一个position参数，其中 position.coords 下保存详细位置信息： 经度 : position.coords.longitude 纬度 : position.coords.latitude 准确度 : position.coords.accuracy 海拔 : position.coords.altitude 海拔准确度 : position.coords.altitudeAcuracy 行进方向 : position.coords.heading 地面速度 : position.coords.speed 时间戳 : new Date(position.timestamp) (2). errorCallback：err=&gt;{ } 接收一个err参数，其中：err.code 返回失败时对应的标号 0 : 不包括其他错误编号中的错误 1 : 用户拒绝浏览器获取位置信息 2 : 尝试获取用户信息，但失败了 3 : 设置了timeout值，获取位置超时了 (3). options：Object enableHighAcuracy : 更精确的查找，默认false timeout : 获取位置允许最长时间，默认infinity maximumAge : 位置可以缓存的最大时间，默认0 frequency 更新的频率（watchPosition方法中使用） HTML5 本地存储 1. Storage接口 可以使用 window.sessionStorage 或 window.localStorage 获取一个 Storage 对象，其具有相同的方法 链接 接口方法 保存数据：Storage.setItem(key, value) 读取数据：Storage.getItem(key) 删除单个数据：Storage.removeItem(key) 删除所有数据：Storage.clear() 得到某个索引的key：Storage.key(index) 2. window.localStorage 获取当前源的本地存储空间的 Storage 对象，存储的数据将保存在浏览器会话中长期保留，同源下不同文档共享同一 localStorage 同源：同协议、同主机名、同端口 连接 3. window.sessionStorage 存储在 sessionStorage 里面的数据在页面会话结束时会被清除。页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话。在新标签或窗口打开一个页面时会在顶级浏览上下文中初始化一个新的会话 不同页面或标签页间无法共享sessionStorage的信息。这里需要注意的是，页面及标签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的。 链接 4. storage事件 window.storage：当前页面使用的storage被其他页面修改时会触发StorageEvent事件。 事件在同一个域下的不同页面之间触发，例如在当前页面注册了storge的监听处理，只有在跟A同域名下的其他页面操作storage对象，当前页面才会被触发storage事件 链接：WindowEventHandlers.onstorage 、storage 、storeEvent StorageEvent下属性： event.key : 修改或删除的key值，如果调用clear()， key为null event.newValue : 新设置的值，如果调用removeStorage()，key为null event.oldValue : 调用改变前的value值 event.storageArea : 当前的storage对象 event.url : 触发该脚本变化的文档的url","categories":[{"name":"HTML","slug":"HTML","permalink":"http://wzr1998.github.io/categories/HTML/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"HTML5","slug":"HTML5","permalink":"http://wzr1998.github.io/tags/HTML5/"},{"name":"HTML","slug":"HTML","permalink":"http://wzr1998.github.io/tags/HTML/"}]},{"title":"HTML5 拖拽 API","slug":"HTML5-拖拽-API","date":"2018-03-12T03:27:09.000Z","updated":"2020-12-01T12:49:15.933Z","comments":true,"path":"posts/c1c3cb60/","link":"","permalink":"http://wzr1998.github.io/posts/c1c3cb60/","excerpt":"","text":"一、设置拖拽元素 在html元素中加draggable=“true”,元素就可以拖拽了 兼容性问题：火狐中拖拽对象必须携带数据，设置 event.dataTransfer.setData(&quot;infoName&quot;,&quot;value&quot;) 实现，参数必须为字符串，可通过 event.dataTransfer.getData(&quot;infoName&quot;) 获取信息 二、拖拽事件 (1). 拖拽对象： dragstart：拖拽前触发 drag：拖拽开始与结束之间连续触发(一直触发) dragend：拖拽结束触发 (2). 目标对象： dragenter：进入目标对象触发，类似mouseover事件 dragover：进入目标对象中连续触发 dragleave：离开目标元素触发，类似mouseout事件 drop：在目标对象上释放鼠标触发，记得阻止默认事件 注意： 要想触发ondrop事件，就必须在ondragover当中阻止默认事件 (3). 事件执行顺序 drop不触发：dragstart &gt; drag &gt; dragenter &gt; dragover &gt; dragleave &gt; dragend drop触发：(dragover的时候阻止默认事件)：dragstart &gt; drag &gt; dragenter &gt; dragover &gt; drop &gt; dragend 三、DragEvent 拖拽对象 拖拽事件下 event.dataTransfer 下保存拖拽对象下的数据 event.dataTransfer.effectAllowed：设置拖动被允许时的光标样式(copy/move/link/copyLink/copyMove/linkMove/all/none/uninitialized) event.dataTransfer.setDragImage(Img, offsetX, offsetY)：自定义拖动时的显示图片，偏移量参数必须写 event.dataTransfer.files：获取外部拖拽文件，类型为 filesList，每一项内部保存文件详细信息，可用 FileReader 接口处理","categories":[{"name":"HTML","slug":"HTML","permalink":"http://wzr1998.github.io/categories/HTML/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"HTML5","slug":"HTML5","permalink":"http://wzr1998.github.io/tags/HTML5/"},{"name":"HTML","slug":"HTML","permalink":"http://wzr1998.github.io/tags/HTML/"}]},{"title":"HTML5 新增 JavaScript API","slug":"HTML5-新增-API","date":"2018-03-10T03:25:31.000Z","updated":"2020-11-26T03:32:35.755Z","comments":true,"path":"posts/347f1e20/","link":"","permalink":"http://wzr1998.github.io/posts/347f1e20/","excerpt":"","text":"一、新增js选择器 document.querySelector(“selector”)：根据CSS选择器语法选择单一DOM元素 document.querySelectorAll(“selector”)：根据CSS选择器语法选择DOM元素列表 document.getElementsByClassName(“className”)：根据元素class选择DOM元素列表 obj.classList：获取元素class列表，返回类数组，提供如下方法： add()：添加 remove()：删除 toggle()：切换 二、JSON JSON.parse() : 把严格模式的json形式字符串转成json JSON.stringify() : 把json转化成字符串 拷贝对象：b = JSON.parse( JSON.stringify(a) ); 三、自定义属性 html中设置：元素自定义属性用data-*建立 js中获取：node.dataset 对象下保存所有元素自定义属性内容(DOMStringMap类型)，通过 node.dataset.* 获取，中间有多个连字符则用驼峰式命名获取 四、js延迟加载 (1). defer属性 作用：立即加载js文件，但延迟到 DOMContentLoaded 事件前顺序触发 1&lt;script src=&quot;1.js&quot; defer&gt;&lt;/script&gt; DOMContentLoaded 事件：初始html文档完全加载和解析完毕之后触发，而无需等待样式表、图像和子框架的完成加载 (2). async属性 作用：指示浏览器在允许的情况下异步执行该脚本，不让页面等待脚本下载和执行，从而异步加载页面其他内容 1&lt;script src=&quot;2.js&quot; async&gt;&lt;/script&gt; (3). 动态创建script代码 12345window.addEventListener(&quot;load&quot;, function() &#123; script = document.createElement(&quot;script&quot;); script.src = &quot;1.js&quot;; document.body.appendChild(element); &#125;, false) 五、历史管理 (1). 如何触发历史管理 浏览器手动前后页跳转 hash 改变 pushState 事件 (2). history 对象 属性： history.length：浏览器历史信息总个数 历史记录跳转： history.back()：移动到上一个访问页面，等同于浏览器的后退键 history.forward()：移动到下一个访问页面，等同于浏览器的后退键 history.go(i)：接受一个整数作为参数，移动到该整数指定的页面，比如go(1)相当于forward()，go(-1)相当于back()。 历史信息管理： history.pushState(stateObj, title, URL)：添加和修改历史记录条目。参数为数据、标题、地址(可选)，地址必须是相同域名，不能跨域。数据大小不能超过640k history.replaceState(stateObj, title, URL)：修改当前历史记录信息，参数与 history.pushState() 相同 注意：以上两个方法仅改变历史信息，并不会触发hashchange事件 history.state：保存当前激活 history 下储存数据的拷贝，注意数据仅通过 pushState() 或 replaceState() 方法添加 (3). window 事件 window.onhashchange()：当 URL中 hash 改变时触发 window.onpopstate()：激活状态的历史记录条目发生变化时触发，如浏览器前进后退按钮或调用 history.back()、history.forward()、history.go() 方法，history.pushState()或 history.replaceState()不会触发，事件处理函数中 event.state 为当前激活 history 下的 state 数据 六、FileReader 接口 (1). 属性 FileReader.readyState：文件读取状态：EMPTY / LOADING / DONE (2). 方法 FileReader.readAsBinaryString(file)：将文件读取为二进制编码 FileReader.readAsText( file, [encoding] )：将文件读取为文本 FileReader.readAsDataURL(file)：将文件读取为data: URL 形式 FileReader.readAsArrayBuffer()：将文件读取为 ArrayBuffer 形式 FileReader.abort()：中断读取操作 (3). 事件 事件处理函数内 event.target.result 保存文件读取结果 loadstart：开始 progress：正在读取 load：成功读取 error：出错 abort：中断 loadend：读取完成，无论成功失败 七、window.postMessage (1). 向另一窗口发送数据 1otherWindow.postMessage(message, targetOrigin, [transfer]); otherWndow：其他window对象的引用，可为 iframe.contentWindow 或使用 window.open() 返回的窗口对象 message：传送的数据 targetOrigin：允许接受信息的域名(要加协议)，&quot;*&quot;为不限制 transfer：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 (2). 另一窗口接收数据 1window.addEventListener(&quot;message&quot;, event=&gt;&#123;&#125;, false); event.data：从其他窗口传递的数据 enevt.origin：发送方的域名，Chrome下使用 event.originalEvent.origin 获取 event.source：对发送消息窗口的引用，可以做两个窗口间的双向通信","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"HTML5","slug":"HTML5","permalink":"http://wzr1998.github.io/tags/HTML5/"}]},{"title":"HTML5 新增表单控件","slug":"HTML5-新增表单控件","date":"2018-03-08T03:24:44.000Z","updated":"2020-11-26T03:25:12.844Z","comments":true,"path":"posts/95974cd4/","link":"","permalink":"http://wzr1998.github.io/posts/95974cd4/","excerpt":"","text":"一、 datalist 表单选项列表，内部包含 option，用来定义input中可能的值，用input元素的list属性来绑定datalist的id，Internet Explorer和Safari不兼容。例： 123456&lt;input type=&quot;text&quot; list=&quot;valList&quot; /&gt;&lt;datalist id=&quot;valList&quot;&gt; &lt;option value=&quot;javascript&quot;&gt;javascript&lt;/option&gt; &lt;option value=&quot;html&quot;&gt;html&lt;/option&gt; &lt;option value=&quot;css&quot;&gt;css&lt;/option&gt;&lt;/datalist&gt; 二、input标签下type新增属性值： 用于验证：email，url， 表单提交时若不满足条件会给出提示 时间相关：datetime：显示完整时间， datetime-local显示完整时间，不含时区， time：显示时间，不含时区， date：显示日期， week：显示周， month：显示月 number：带有上下两个按钮的数值选择器 range：数值选择器，step：步长，value：当前 1&lt;input type=&quot;range&quot; step=&quot;2&quot; min=&quot;0&quot; max=&quot;10&quot; value=&quot;2&quot; /&gt; tel：电话号码，移动端会调用数字键盘 search：用于搜索，输入内容后会出现一个叉 color：颜色拾取器 三、input新增属性： placeholder=“” ：提示信息 autocomplete=“off/on”：是否提示曾经输入的内容 formaction=“”：在type值为submit里定义提交地址 autofocus：自动获取焦点 required：此项必填，不能为空 pattern=regexp：加入正则验证 formnovalidate属性 : 关闭验证 四、验证反馈 1. oninvalid事件 当元素无效时触发，同时注意阻止默认验证：ev.preventDefault() 2 .setCustomValidity(“提示词”)` 自定义验证，不满足条件时触发，没有错误时需要清空，否则无法提交 3. 表单对象下 this.validity 对象 储存校验信息，this.validity.valid 属性为校验结果，若八种验证都通过返回true，一种验证失败返回false valueMissing : 输入值为空时返回true typeMismatch : 控件值与预期类型不匹配时返回true patternMismatch : 输入值不满足pattern正则时返回true customError 不符合自定义验证不符合时返回true tooLong : 超过maxLength最大限制时返回true rangeUnderflow : 验证的range最小值，不符合时返回true rangeOverflow：验证的range最大值，不符合时返回true stepMismatch: 验证range 的当前值 是否符合min、max及step的规则，不符合时返回true","categories":[{"name":"HTML","slug":"HTML","permalink":"http://wzr1998.github.io/categories/HTML/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://wzr1998.github.io/tags/HTML5/"},{"name":"HTML","slug":"HTML","permalink":"http://wzr1998.github.io/tags/HTML/"}]},{"title":"HTML5 语义化标签","slug":"HTML5-语义化标签","date":"2018-03-05T18:53:55.000Z","updated":"2020-11-26T03:24:24.945Z","comments":true,"path":"posts/547a420e/","link":"","permalink":"http://wzr1998.github.io/posts/547a420e/","excerpt":"","text":"一、兼容性问题 E8及以下不兼容，在js中用document.createElement()创建出HTML5标签后浏览器则能识别HTML5标签 解决方案：引入插件 html5shiv.js 二、HTML 语义化标签优点 易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。 有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。 方便其他设备解析，如盲人阅读器根据语义渲染网页 有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐 ](https://cdn.bootcss.com/html5shiv/r29/html5.min.js) 三、HTML5 新增语义化标签 &lt;header&gt;&lt;/header&gt;：页眉(头部) &lt;footer&gt;&lt;/footer&gt;：页脚(底部) &lt;nav&gt;&lt;/nav&gt;：导航（包含链接的的一个列表） &lt;hgroup&gt;&lt;/hgroup&gt;：页面上的一个标题组合(内部嵌套标题) &lt;section&gt;&lt;section&gt;： 页面上的版块(用来划分区域) &lt;article&gt;&lt;/article&gt;：主体(用来在页面中表示一套结构完整且独立的内容部分)，论坛帖子、报纸文章、博客条目、用户评论 &lt;aside&gt;&lt;/aside&gt;：和主体相关的附属信息，内容应该与附近的内容相关(可以包含与当前页面或主要内容相关的引用、侧边栏、广告、nav元素组，以及其他类似的有别与主要内容的部分) &lt;figure&gt;&lt;img src=“…”/&gt;&lt;figcaption&gt;标题。说明&lt;/figcaption&gt;&lt;/figure&gt;：用于对元素进行组合。一般用于图片或视频 &lt;figcaption&gt; 标签定义 figure元素的标题(caption)，在&lt;figure&gt; 块里是第一个或最后一个 1234&lt;figure&gt; &lt;img src=&quot;...&quot;/&gt; &lt;figcaption&gt;标题/说明&lt;/figcaption&gt;&lt;/figure&gt; &lt;time&gt;&lt;/time&gt;：用来表现时间或日期(下有datetime属性) &lt;address&gt;&lt;/address&gt;：标签定义文档作者或拥有者的联系信息。 &lt;mark&gt;&lt;/mark&gt;：标记(默认黄色背景) &lt;progress max=&quot;200&quot; value=&quot;100&quot;&gt;&lt;/progress&gt;：进度条，max为最大数字，value代表当前，内部可以添加数字向下兼容 &lt;details&gt;&lt;/details&gt;：用于描述文档或文档某个部分的细节，加open属性则展示内部信息 &lt;summary&gt;&lt;/summary&gt;：用于描述&quot;details&quot;元素有关文档或文档片段的详细信息，是details元素的标题 1234&lt;details open&gt; &lt;summary&gt;一个details元素的一个内容的摘要，标题或图例&lt;/summary&gt; &lt;p&gt;内部信息文本内部信息文本内部信息文本内部信息文本内部信息文本内部信息文本内部信息文本内部信息文本内部信息文本内部信息文本&lt;/p&gt;&lt;/details&gt;","categories":[{"name":"HTML","slug":"HTML","permalink":"http://wzr1998.github.io/categories/HTML/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://wzr1998.github.io/tags/HTML5/"},{"name":"HTML","slug":"HTML","permalink":"http://wzr1998.github.io/tags/HTML/"}]},{"title":"前端 DOM 优化","slug":"前端-DOM-优化","date":"2017-12-26T03:22:07.000Z","updated":"2020-11-26T03:22:55.190Z","comments":true,"path":"posts/3f5d5ca5/","link":"","permalink":"http://wzr1998.github.io/posts/3f5d5ca5/","excerpt":"","text":"一、概念&amp;原则 在浏览器中，DOM与ECMA在两个不同的文件夹，独立实现 大量操作尽量在JS内部完成，不要进行多次DOM与JS的交互 二、优化方法 chrome(webkit内核) : dom方法要比innerHTML 性能要好，IE，Firefox相反 节点克隆( cloneNode(true) )比创建节点效率高( createElement ) 尽量使用局部变量，如在for循环中，判断条件obj.length可以先存起来，避免每次都要计算(数据量大时) 尽量使用只获取元素节点的方法 childNodes/firstChild → 元素节点、文本节点 children/firstElementChild → 元素节点 选择器API利用querySelector、querySelectorAll，IE8以下不支持 ​ 如var aLi = document.querySelectorAll(’#ul1 li’); 利用JS事件委托 三、DOM与浏览器(优化重排、重构) 尽量在appendChild前改变节点样式，避免在添加之后改变 利用cssText添加样式，合并多行style改变样式操作 缓存布局信息，如在运动时定时器中获取的offsetLeft可以先存成局部变量，从而不用每次获取 管理文档碎片，利用document.createDocumentFragment() (类似购物车，临时存储，统一添加)","categories":[{"name":"HTML","slug":"HTML","permalink":"http://wzr1998.github.io/categories/HTML/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"http://wzr1998.github.io/tags/HTML/"}]},{"title":"JavaScript 操作 iFrame","slug":"JavaScript-操作-iFrame","date":"2017-12-22T03:20:52.000Z","updated":"2020-11-26T03:21:45.963Z","comments":true,"path":"posts/81cbd715/","link":"","permalink":"http://wzr1998.github.io/posts/81cbd715/","excerpt":"","text":"一、父级页面操作iframe IframeObj.contentWindow.document.getElementById(‘div1’).style.color = ‘red’; 所有浏览器都支持(chrome/Safari要在服务器环境下)，contentWindow指向iframewindow IframeObj.contentDocument.getElementById(‘div1’).style.background = ‘red’; ie6 ie7不支持，contentDocument指向iframe文档 二、iframe操作原页面(父层) window.parent.document.getElementById(‘div1’).style.color = 'red’; window.parent指向父层(chrome/Safari要在服务器环境下) window.top.document.getElementById(‘div1’).style.color = 'red’; window.top指向最顶层(最外层)(多层嵌套时) 三、iframe onload事件 iframe 在加载结束后触发 onload 事件 123oIframe.onload = function()&#123; console.log(&quot;load over&quot;);&#125;; ie 下的iframe的onload事件只能用绑定的形式（attachEvent） 123oIframe.attachEvent(&#x27;onload&#x27;,function()&#123; // IE alert(123);&#125;); 四、应用 1. 防钓鱼网站(被iframe嵌套) 在自己的网站中(可能是被iframe的) 123if(window!=window.top)&#123; window.top.location.href = window.location.href;&#125; 2. 动态改变iframe大小 12345function changeHeight()&#123; setTimeout(function()&#123; oIframe.height = oIframe.contentWindow.document.body.offsetHeight; &#125;,100);&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"http://wzr1998.github.io/tags/HTML/"}]},{"title":"浏览器 console 常用方法","slug":"浏览器-console-常用方法","date":"2017-12-20T03:19:43.000Z","updated":"2020-11-26T03:49:49.038Z","comments":true,"path":"posts/87bd6d27/","link":"","permalink":"http://wzr1998.github.io/posts/87bd6d27/","excerpt":"","text":"一、输出 123456console.log(&quot;常规输出&quot;);console.warn(&#x27;这里是警告&#x27;);console.error(&#x27;这里是错误&#x27;);console.dir(obj); //输出当前对象所有信息console.dirxml(oDiv); //显示当前HTML元素代码结构 二、分组 123456789101112console.group(&#x27;第一组&#x27;);for(let i=0; i&lt;5; i++)&#123; console.log(i);&#125;console.groupEnd();console.group(&#x27;第二组&#x27;);for(let i=0; i&lt;5; i++)&#123; console.log(i*2);&#125;console.groupEnd(); 三、调试 12console.assert(a);//断言，如果是真不输出，如果是假输出Assertion failed(断言失败)console.trace();//向web控制台输出一个堆栈跟踪. 四、计时 12345console.time(&#x27;计时器&#x27;);for(var i=0;i&lt;1000000;i++)&#123; &#125;console.timeEnd(&#x27;计时器&#x27;);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"}]},{"title":"JavaScript 事件委托","slug":"JavaScript事件委托","date":"2017-12-16T03:18:36.000Z","updated":"2020-11-26T03:19:10.987Z","comments":true,"path":"posts/14907160/","link":"","permalink":"http://wzr1998.github.io/posts/14907160/","excerpt":"","text":"一、事件委托(事件代理) 事件委托(事件代理)：利用冒泡的原理，把事件加到父级上，触发执行效果 二、好处 1.提高性能 2.新添加的元素，还会有之前的事件 三、event 1. event对象 事件源，不管在那个事件中，当前操作的那个元素就是事件源 2. 获取 event对象 IE : window.event.srcElement 标准下 ：event.target 3. 筛选 event.nodeName : 找到当前元素的标签名（都是大写的） event.nodeName.toLowerCase()：将当前事件元素名转换为小写 1234567oUl.onmouseover = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == &#x27;li&#x27;)&#123; target.style.background = &#x27;red&#x27;; &#125;&#125;;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"}]},{"title":"JavaScript 闭包","slug":"JavaScript-闭包","date":"2017-12-13T03:17:48.000Z","updated":"2020-11-26T03:18:20.539Z","comments":true,"path":"posts/3b4db1da/","link":"","permalink":"http://wzr1998.github.io/posts/3b4db1da/","excerpt":"","text":"一、概念 函数嵌套函数，内部函数可以引用外部函数的参数和变量，参数和变量不会被垃圾回收机制所收回 父函数中返回的子函数可以获取父函数中的变量，父函数中的变量长期保留 使用场景 函数作为返回值 函数作为参数传递 123456789function createAddFn(num)&#123; return function(i)&#123; console.log(num += i) &#125;&#125;addFn = createAddFn(5)addFn(1) //6addFn(2) //7addFn(3) //8 二、用途 希望一个变量长期驻扎在内存当中 避免全局变量的污染 私有成员的存在 封装变量，收敛权限(只能在返回函数中修改私有变量)，防止变量暴露在全局 例：在循环中直接找到对应元素的索引 1234567for(var i=0;i&lt;aLi.length;i++)&#123; (function(i)&#123; aLi[i].onclick = function()&#123; console.log(i); &#125;; &#125;)(i);&#125; 1234567for(var i=0;i&lt;aLi.length;i++)&#123; aLi[i].onclick = (function(i)&#123; return function()&#123; console.log(i); &#125; &#125;)(i);&#125; 三、注意 ：IE下内存泄漏问题 1. 触发条件 在同一个作用域内（全局域或者函数域内），如果出现js对象引用dom对象，该dom对象又引用同一个作用域内的js对象时，将发生泄漏。（循环引用） 2. 解决办法 1234567891011121314151617window.onload = function()&#123; var oDiv = document.getElementById(&#x27;div1&#x27;); oDiv.onclick = function()&#123; console.log(oDiv.id); &#125;; window.onunload = function()&#123; //在用户退出页面时发生。 oDiv.onclick = null; &#125;;&#125;;window.onload = function()&#123; var oDiv = document.getElementById(&#x27;div1&#x27;); var id = oDiv.id; oDiv.onclick = function()&#123; console.log(id); &#125;; oDiv = null;&#125;;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"}]},{"title":"JavaScript继承","slug":"JavaScript继承","date":"2017-12-10T03:17:10.000Z","updated":"2020-11-26T03:36:52.197Z","comments":true,"path":"posts/98b90f19/","link":"","permalink":"http://wzr1998.github.io/posts/98b90f19/","excerpt":"","text":"一、原型链继承 将父类的实例作为子类的原型：Cat.prototype = new Animal(); 二、构造继承 使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型） 123function Cat(name)&#123; Animal.call(this);&#125; 三、实例继承 为父类实例添加新特性，作为子类实例返回 123456function Cat(name)&#123; var animal = new Animal(); for(var p in animal)&#123; Cat.prototype[p] = animal[p]; &#125;&#125; 四、组合继承 通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用 123456function Cat(name)&#123; Animal.call(this); this.name = name || &#x27;Tom&#x27;;&#125;Cat.prototype = new Animal();Cat.prototype.constructor = Cat; 五、寄生组合继承(最好) 通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点 1234567function Cat(name)&#123; Animal.call(this);&#125;var Super = function()&#123;&#125;;Super.prototype = Animal.prototype;Cat.prototype = new Super();Cat.prototype.constructor = Cat;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"}]},{"title":"JavaScript 原型&原型链","slug":"JavaScript-原型-原型链","date":"2017-12-04T03:15:57.000Z","updated":"2020-12-06T14:47:35.573Z","comments":true,"path":"posts/2e37ae21/","link":"","permalink":"http://wzr1998.github.io/posts/2e37ae21/","excerpt":"","text":"一、构造函数 1. JavaScript 构造函数 JavaScript 中没有类的概念，通过构造函数来创实例对象 构造函数函数名首字母大写 构造函数末尾默认return this 2. 构造函数扩展 var a = &#123;&#125; 其实是 var a = new Object() 的语法糖 var b = [] 其实是 var a = new Array() 的语法糖 function Foo()&#123;&#125; 其实是var Foo = new Function(…) 的语法糖 3. instanceof 运算符 判断一个函数是否是一个变量的构造函数；判断引用类型属于哪个构造函数的方法（判断对象和构造函数是否在一条原型链上），结合原型链理解 二、原型 1. 隐式原型：obj.__proto__ __proto__ 是实例对象的属性，指向该对象构造函数的显式原型 注意： 函数对象的 __proto__ 指向 Function.prototype Object.prototype 指向 null (原型链的尽头) 2. 显式原型：Fn.prototype 通过 new 关键字调用构造函数创建实例对象时，实例对象 __proto__ 属性自动指向 Fn.prototype ，若之后Fn.prototype 指向对象发生更改则不影响原实例对象 __proto__ 指向 1234567function Fn()&#123;&#125;Fn.prototype.n = 1var obj1 = new Fn()Fn.prototype = &#123;n:2, m:3&#125;var obj2 = new Fn()console.log(obj1.n, obj1.m) //1 undefinedconsole.log(obj2.n, obj2.m) //2 3 结合原型链： 12345function F()&#123;&#125;;Object.prototype.a = 1;Function.prototype.b = 2;f = new F();console.log(f.a, f.b, F.a, F.b) //1 undefined 1 2 3. for-in循环变量自身属性 高级浏览器已经在for-in循环中屏蔽了来自对象原型的属性，但最好加上判断保证程序的健壮性 12345for(let attr in obj)&#123; if(obj.hasOwnProperty(attr))&#123; console.log(attr) &#125;&#125; 三、原型链 1. 原型规则 所有的引用类型对象（数组、对象、函数）都具有对象的特性，可自由扩展属性 所有的引用类型对象（数组、对象、函数）都具有__proto__属性(隐式原型)，属性值是一个普通对象 所有的函数都具有prototype属性(显式原型)，属性值也是一个普通对象 所有的引用类型对象（数组、对象、函数），__proto__属性值指向它构造函数的&quot;prototype&quot;属性值 当试图得到一个对象的某个属性时，如果这个对象没有这个属性，那么会在它的__proto__属性（即它构造函数的prototype属性）中寻找 2. 原型链 四、面试题 1. 如何判断一个变量是数组类型 12arr instanceof ArrayObject.prototype.toString.call(arr) === &#x27;[object Array]&#x27; //最好 2. new调用构造函数的过程 构造函数内部创建一个空对象 构造函数中this指向这个对象 执行构造函数，对this赋值 构造函数return this","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"}]},{"title":"JavaScript 深拷贝与浅拷贝","slug":"JavaScript-深拷贝与浅拷贝","date":"2017-12-02T03:14:37.000Z","updated":"2020-11-26T03:15:15.335Z","comments":true,"path":"posts/96afb931/","link":"","permalink":"http://wzr1998.github.io/posts/96afb931/","excerpt":"","text":"一、浅拷贝 遍历原对象，为拷贝对象添加相同属性与属性值 12345678function shallowCopy(src) &#123; var dst = &#123;&#125;; for (var prop in src) &#123; if (src.hasOwnProperty(prop)) dst[prop] = src[prop]; &#125; return dst;&#125; 若原对象中存在某一属性值为引用类型，则拷贝对象会影响原对象( key 指向相同引用对象) 二、深拷贝 注意：可能一个对象下嵌套了另一个对象，有多层嵌套 作用：解决对象的引用时值和地址同时引用的问题(只需要引用值) 1. JSON实现 1var result = JSON.parse(JSON.stringify(obj)) 2. 递归实现 方法一： 12345678910function deepCopy(obj)&#123; if(typeof obj != &#x27;object&#x27;)&#123; return obj; &#125; var newObj = &#123;&#125;; for(var attr in obj)&#123; newObj[attr] = deepCopy(obj[attr]); &#125; return newObj;&#125; 方法二： 123456789101112function deepCopy(p, c) &#123; var c = c || &#123;&#125;; for (var i in p) &#123; if (typeof p[i] === &#x27;object&#x27;) &#123; c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;; deepCopy(p[i], c[i]); &#125; else &#123; c[i] = p[i]; &#125; &#125; return c;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"}]},{"title":"JavaScript DOM、BOM、本地存储","slug":"JavaScript-DOM、BOM、本地存储","date":"2017-11-30T03:12:51.000Z","updated":"2020-11-26T03:13:43.248Z","comments":true,"path":"posts/fe6cd438/","link":"","permalink":"http://wzr1998.github.io/posts/fe6cd438/","excerpt":"","text":"一、DOM 1. DOM本质 浏览器拿到html文件(字符串文本)，结构化成的浏览器能识别并且JS可操作的一个树型结构模型 2. 获取DOM节点 12345document.getElementById();document.getElementsByTagName();document.getElementsByClassName();document.querySelector();document.querySelectorAll(); 3. DOM 结点的 property 和 Attribute property：指JS对象的属性，如p.style.width、p.nodeName Attribute：指html文档标签中的属性，如p.getAttribute(‘width’) 4. DOM结构操作 创建结点：document.createElement(Tag) 添加结点：Node.appendChild(newNode) / Node.insertBefore(newNode, refNode) 替换节点：Node.replaceChild(newChild,oldChild) 获取父节点：Node.parentNode() 获取子节点：Node.childNodes() / Node.firstChild() / Node.lastChild() 获取兄弟节点：Node.previousSibling() / Node.nextSibling 删除节点：Node.removeChild(oldChild): 克隆节点：cloneNode([deep])，当deep为true时深度克隆(默认)，表示在复制当前节点及全部后代节点，false则仅复制当前节点。 二、BOM 常用操作 1. navigator navigator.userAgent：获取用户浏览器信息 navigator.userAgent.indexOf(‘Chrome’)：如何检测浏览器类型 2. screen screen.width screen.height 3. location 常用于拆解 url 各部分信息 location.href：整个url location.protocol：协议http / https location.host：域名 location.pathname：路径 location.search：url中’?'后的内容（包括’#’） location.hash：url中’#'后的内容（包括’#’） 4. history history.back()：后退 history.forward()：前进 history.go()：转到 history.length：历史个数 三、本地存储 1. cookie 1. 作用 用于客户端和服务端通信，也有本地存储功能 2. 使用 通过 document.cookie 获取和修改，格式 name1=value1;name2=value2 ，使用时需封装 cookie 封装： 1234567891011121314151617181920212223function setCookie(name,value,t)&#123; var oDate = new Date(); if(!t)&#123; t=0; &#125; oDate.setDate(oDate.getDate()+t); document.cookie = name+&quot;=&quot;+value+&quot;;expires=&quot;+oDate;&#125;function getCookie(name)&#123; var str = document.cookie; var arr = str.split(&quot;; &quot;); for(var i = 0; i &lt; arr.length; i++)&#123; var newArr = arr[i].split(&quot;=&quot;); if(newArr[0]==name)&#123; return newArr[1]; &#125; &#125;&#125;function removeCookie(name)&#123; setCookie(name,1,-1);&#125; 3. 特点 所有http请求都带着(包括ajax)，会影响获取资源的效率 API太简单，需要封装才能用 各浏览器之间对cookie的不同限制： IE6.0 IE7.0/8.0/9.0+ Opera FF Safari Chrome cookie个数 每个域为20个 每个域为50个 每个域为30个 每个域为50个 没有个数限制 每个域为53个 cookie大小 4095个字节 4095个字节 4096个字节 4097个字节 4097个字节 4097个字节 2. localStorage / sessionStorage 作用：专为存储设计，最大容量5M API简单易用：localStorage.setItem(key, value) / localStorage.getItem(key) 注意：iOS无痕模式下，localStorage.getitem()会报错，建议使用try-catch封装","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"}]},{"title":"JavaScript 函数声明&函数表达式、作用域、异步&单线程","slug":"JavaScript-函数声明-函数表达式、作用域、异步-单线程","date":"2017-11-26T03:06:24.000Z","updated":"2020-11-26T03:07:24.421Z","comments":true,"path":"posts/1760f419/","link":"","permalink":"http://wzr1998.github.io/posts/1760f419/","excerpt":"","text":"一、JavaScript执行上下文 范围：一段&lt;script&gt;&lt;/script&gt;（全局）或者一段函数代码块 全局：var变量声明、函数声明会被提升 函数：var变量声明、函数声明、this、arguments会被提升 二、函数声明和表达式 1. 函数声明 1function fn1()&#123;&#125; 2. 函数表达式 12var fn = function fn1()&#123;&#125; //命名函数表达式var fn = function()&#123;&#125; //匿名函数表达式 注意： 12345var fn = function fn2333()&#123; console.log(typeof fn2333); //内部是可以找到的&#125;fn(); //functionfn2333(); // ReferenceError: Can&#x27;t find variable: fn2333，外部找不到 3. 函数声明与函数表达式区别： 函数表达式可以直接后面加括号执行，而函数声明是不可以的 函数声明会把整个代码块提升；函数声明上方可以直接调用 函数表达式会把函数名变量提升为undefeated；不能调用 三、作用域&amp;作用域链 this：要在执行时才能确认值，定义是无法确认 作用域：JS无块级作用域，只有全局作用域和函数作用域 作用域链：子作用域找不到变量到父作用域找，本作用域中没有的变量叫做自由变量 注意：函数作用域是在定义的时候确定的，不是在执行的时候确定 四、异步&amp;单线程 什么是异步：异步不影响后续代码的执行，不会阻塞 什么时候需要异步：在所有可能发生等待的情况 使用异步的场景： 定时任务：setInterval、setTimeout 网络请求：AJAX请求、动态&lt;img&gt;加载（ img.onload = function(){} ） 时间绑定：不知道该事件什么时候发生 setTimeout原理： 把setTimeout中函数放入暂存队列中 主线程中函数全部执行结束之后从缓存队列中取出第一个函数执行 注：setTimeout只能保证在指定的时间过后将任务(需要执行的函数)插入队列等候，并不保证这个任务在什么时候执行 五、面试题 1. 说一下对变量提升的理解 变量定义和函数声明会提升 2. 说明this的几种不同的使用场景 作为构造函数执行 =&gt;this指向新对象 作为对象属性执行 =&gt;this指向该对象 作为普通函数执行 =&gt;this指向调用它的函数 call、apply、bind调用 =&gt;this指向传入的新this 3. 如何理解作用域 自由变量 作用域链，即自由变量的查找 闭包的两个使用场景","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"}]},{"title":"JabaScript日期对象、Math.random、数组API","slug":"JabaScript日期对象、Math-random、数组API","date":"2017-11-23T03:06:24.000Z","updated":"2020-11-26T03:12:32.021Z","comments":true,"path":"posts/76a7e2de/","link":"","permalink":"http://wzr1998.github.io/posts/76a7e2de/","excerpt":"","text":"一、JavaScript日期对象 123456789Date.now() // 获取当前时间毫秒数var dt = new Date()dt.getTime() // 获取毫秒数(时间戳)dt.getFullYear() // 年dt.getMonth() // 月(0 - 11)dt.getDate() // 日(0 - 31)dt.getHours() //11 小时(0 - 23) dt.getMinutes() // 分钟(0 - 59)dt.getSeconds() // 秒(0 - 59) 二、Math.random() 获取 0 至 1 间随机浮点数，常用于清除缓存，长度不固定 三、JavaScript 数组API 12345678let arr = [3,4,1,5,2];arr.forEach((item, index, arr) =&gt; &#123;&#125;); //遍历所有元素arr.every((item, index, arr) =&gt; &#123;return (item&gt;0)&#125;); //判断所有元素是否满足条件，返回布尔值arr.some((item, index, arr) =&gt; &#123;return (item &lt;2)&#125;); //判断所有元素是否满足条件，有一个满足条件则返回truearr.sort((a, b) =&gt; a-b); //从小到大arr.sort((a, b) =&gt; b-a); //从大到小arr.map((item, index, arr) =&gt; item * arr[index]); //映射出一个新数组arr.filter((item, index, arr) =&gt; arr[index] &gt; 3); //根据条件过滤，返回一个满足条件元素构成的新数组","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"}]},{"title":"JavaScript变量类型和计算","slug":"JavaScript变量类型和计算","date":"2017-11-20T03:07:49.000Z","updated":"2020-11-26T03:11:48.479Z","comments":true,"path":"posts/de566112/","link":"","permalink":"http://wzr1998.github.io/posts/de566112/","excerpt":"","text":"一、JavaScript 基本数据类型 值类型：number、string、boolean、undefined 特点：每个变量都能存储各自的地址，不会相互影响 引用类型：Object、Array、Function 特点：可以无限的拓展属性；变量是一个指针，指向一个对象（好几个变量共用一个内存） typeof运算符：共有六种结果：number、string、boolean、undefined、object、function 注：typeof只能区分四种值类型的详细类型，引用类型只能区分object和function 如何判断变量 true / false：console.log( !!obj ) 假值：0、NaN、&quot;&quot;、null、undefined、false 二、变量计算-强制类型转换 1. 字符串拼接 数字+数字=数字 100+10=110 数字+字符串=字符串 100+’10’=10010 2. == 运算符： 先转换成相同数据类型再进行比较 100 == ‘100’ //true 0 == “” //true (都是false) null == undefined //true (都是false) 3. if 语句 if中的判断中的变量会进行强制类型转换，把变量转换为true或false 4. 逻辑运算符 &amp;&amp;、 ||、 ! 会进行强制类型转换，把变量转换为true或false 三、面试题 1. typeof 有什么结果 4+2=6种 2. 什么时候使用==；什么时候使用===（jquery源码中写法） 判断变量或属性是否存在时用 == obj.attr == null 相当于 obj.attr === null || obj.attr === undefined 的简写形式 3. JS中的内置函数 Object、Array、Boolean、Number、String、Function、Date、RegExp、Error 4. 如何理解JSON JSON是一个JS的内置对象，也是一种数据格式 JSON自带两个API：JSON.stringify() 、JSON.parse()","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"}]}],"categories":[{"name":"nlp","slug":"nlp","permalink":"http://wzr1998.github.io/categories/nlp/"},{"name":"算法","slug":"算法","permalink":"http://wzr1998.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"Python","slug":"Python","permalink":"http://wzr1998.github.io/categories/Python/"},{"name":"面试题","slug":"面试题","permalink":"http://wzr1998.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/categories/Vue/"},{"name":"webpack","slug":"webpack","permalink":"http://wzr1998.github.io/categories/webpack/"},{"name":"git","slug":"git","permalink":"http://wzr1998.github.io/categories/git/"},{"name":"数据库","slug":"数据库","permalink":"http://wzr1998.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Node.js","slug":"Node-js","permalink":"http://wzr1998.github.io/categories/Node-js/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/categories/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://wzr1998.github.io/categories/jQuery/"},{"name":"CSS","slug":"CSS","permalink":"http://wzr1998.github.io/categories/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://wzr1998.github.io/categories/HTML/"}],"tags":[{"name":"nlp","slug":"nlp","permalink":"http://wzr1998.github.io/tags/nlp/"},{"name":"算法","slug":"算法","permalink":"http://wzr1998.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Python","slug":"Python","permalink":"http://wzr1998.github.io/tags/Python/"},{"name":"nlp分词","slug":"nlp分词","permalink":"http://wzr1998.github.io/tags/nlp%E5%88%86%E8%AF%8D/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://wzr1998.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"面试题","slug":"面试题","permalink":"http://wzr1998.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"Vue","slug":"Vue","permalink":"http://wzr1998.github.io/tags/Vue/"},{"name":"源码","slug":"源码","permalink":"http://wzr1998.github.io/tags/%E6%BA%90%E7%A0%81/"},{"name":"MVVM","slug":"MVVM","permalink":"http://wzr1998.github.io/tags/MVVM/"},{"name":"webpack","slug":"webpack","permalink":"http://wzr1998.github.io/tags/webpack/"},{"name":"Vuex","slug":"Vuex","permalink":"http://wzr1998.github.io/tags/Vuex/"},{"name":"Vue-Router","slug":"Vue-Router","permalink":"http://wzr1998.github.io/tags/Vue-Router/"},{"name":"git","slug":"git","permalink":"http://wzr1998.github.io/tags/git/"},{"name":"Node.js","slug":"Node-js","permalink":"http://wzr1998.github.io/tags/Node-js/"},{"name":"数据库","slug":"数据库","permalink":"http://wzr1998.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://wzr1998.github.io/tags/MongoDB/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://wzr1998.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://wzr1998.github.io/tags/ES6/"},{"name":"jQuery","slug":"jQuery","permalink":"http://wzr1998.github.io/tags/jQuery/"},{"name":"CSS","slug":"CSS","permalink":"http://wzr1998.github.io/tags/CSS/"},{"name":"CSS3","slug":"CSS3","permalink":"http://wzr1998.github.io/tags/CSS3/"},{"name":"HTML","slug":"HTML","permalink":"http://wzr1998.github.io/tags/HTML/"},{"name":"布局","slug":"布局","permalink":"http://wzr1998.github.io/tags/%E5%B8%83%E5%B1%80/"},{"name":"HTML5","slug":"HTML5","permalink":"http://wzr1998.github.io/tags/HTML5/"}]}